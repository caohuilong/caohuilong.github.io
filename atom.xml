<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WooOh&#39;s blog</title>
  
  <subtitle>愿所有的等待，终能遇见幸福</subtitle>
  <link href="http://caohuilong.github.io/atom.xml" rel="self"/>
  
  <link href="http://caohuilong.github.io/"/>
  <updated>2021-10-11T11:27:59.000Z</updated>
  <id>http://caohuilong.github.io/</id>
  
  <author>
    <name>WooOh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>cgroups是如何工作的？</title>
    <link href="http://caohuilong.github.io/2021/10/11/cgroups%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F/"/>
    <id>http://caohuilong.github.io/2021/10/11/cgroups%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F/</id>
    <published>2021-10-11T11:27:59.000Z</published>
    <updated>2021-10-11T11:27:59.000Z</updated>
    
    <content type="html"><![CDATA[<p>cgroups是docker容器的三大关键技术之一，它是Linux内核中用来给进程设置资源限制的一个重要功能，可以被限制的资源包括CPU、内存、磁盘、网络带宽等等。</p><a id="more"></a><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。使用mount命令把它们展示出来，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># mount -t cgroup</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name&#x3D;systemd)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br></pre></td></tr></table></figure><p>这条命令的输出结果，是一系列的文件系统目录，可以看到很多诸如cpuset、cpu、memory这样的子目录，也叫子系统。这些都是我这台机器当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p# ls &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu</span><br><span class="line">cgroup.clone_children  cpuacct.stat       cpuacct.usage_percpu       cpuacct.usage_sys   cpu.cfs_quota_us  notify_on_release  tasks</span><br><span class="line">cgroup.procs           cpuacct.usage      cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares        release_agent      user.slice</span><br><span class="line">cgroup.sane_behavior   cpuacct.usage_all  cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat          system.slice</span><br></pre></td></tr></table></figure><p>以上配置文件的名称代表了对应参数的作用，比如 cpu.cfs_period_us 和 cpu.cfs_quota_us 组合起来使用，表示限制进程在长度为 cfs_period_us 的一段时间内，只能被分配到总量为 cfs_quota_us 的 CPU 时间。</p><h4 id="cgroup使用案例"><a href="#cgroup使用案例" class="headerlink" title="cgroup使用案例"></a>cgroup使用案例</h4><p>你需要在对应的子系统下面创建一个目录，比如，我们现在进入 /sys/fs/cgroup/cpu 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Virtual-Machine:&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu# mkdir container</span><br><span class="line">root@Virtual-Machine:&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu# ls container&#x2F;</span><br><span class="line">cgroup.clone_children  cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares      cpu.uclamp.min</span><br><span class="line">cgroup.procs           cpuacct.usage_all     cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat        notify_on_release</span><br><span class="line">cpuacct.stat           cpuacct.usage_percpu  cpuacct.usage_sys          cpu.cfs_quota_us    cpu.uclamp.max  tasks</span><br></pre></td></tr></table></figure><p>这个目录就称为一个“控制组”。你会发现，操作系统会在你新创建的 container 目录下，自动生成该子系统对应的资源限制文件。</p><p>现在，我们在后台执行这样一条脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># while : ; do : ; done &amp;</span><br><span class="line">[1] 16622</span><br></pre></td></tr></table></figure><p>显然，它执行了一个死循环，可以把计算机的 CPU 吃到 100%，根据它的输出，我们可以看到这个脚本在后台运行的进程号（PID）是 16622。</p><p>这样，我们可以用 top 指令来确认一下 CPU 有没有被打满：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># top</span><br><span class="line">%Cpu(s): 98.9.0 us,  2.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure><p>在输出里可以看到，CPU 的使用率已经接近 100% 了（%Cpu0 :98.9.0 us）。</p><p>而此时，我们可以通过查看 container 目录下的文件，看到 container 控制组里的 CPU quota还没有任何限制（即：-1），CPU period 则是默认的 100 ms（100000 us）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_quota_us</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line"># cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_period_us</span><br><span class="line">100000</span><br></pre></td></tr></table></figure><p>接下来，我们可以通过修改这些文件的内容来设置限制。<br>比如，向 container 组里的 cfs_quota 文件写入 20 ms（20000 us）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo 20000 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_quota_us</span><br></pre></td></tr></table></figure><p>结合前面的介绍，你应该能明白这个操作的含义，它意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是说这个进程只能使用到 20% 的 CPU 带宽。接下来，我们把被限制的进程的 PID 写入 container 组里的 tasks 文件，上面的设置就会对该进程生效了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo 16622 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;tasks</span><br></pre></td></tr></table></figure><p>我们可以用 top 指令查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># top</span><br><span class="line">%Cpu(s): 20.3 us,  2.6 sy,  0.0 ni, 73.2 id,  1.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure><p>可以看到，计算机的 CPU 使用率立刻降到了 20%（%Cpu0 : 20.3 us）。除 CPU 子系统外，Cgroups 的每一项子系统都有其独有的资源限制能力，比如：</p><ul><li>blkio，为 块 设 备 设 定 I/O 限 制，一般用于磁盘等设备；</li><li>cpuset，为进程分配单独的 CPU 核和对应的内存节点；</li><li>memory，为进程设定内存使用的限制。</li></ul><p>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。</p><p>而至于在这些控制组下面的资源文件里填上什么值，就靠用户执行 docker run 时的参数指定了，比如这样一条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -it --cpu-period&#x3D;100000 --cpu-quota&#x3D;20000 ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>在启动这个容器后，我们可以通过查看 Cgroups 文件系统下，CPU 子系统中，“docker”这个控制组里的资源限制文件的内容来确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;5d5c9f67d&#x2F;cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line"></span><br><span class="line"># cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;5d5c9f67d&#x2F;cpu.cfs_quota_us</span><br><span class="line">20000</span><br></pre></td></tr></table></figure><p>这就意味着这个 Docker 容器，只能使用到 20% 的 CPU 带宽。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;cgroups是docker容器的三大关键技术之一，它是Linux内核中用来给进程设置资源限制的一个重要功能，可以被限制的资源包括CPU、内存、磁盘、网络带宽等等。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://caohuilong.github.io/categories/Linux/"/>
    
    
    <category term="cgroups" scheme="http://caohuilong.github.io/tags/cgroups/"/>
    
  </entry>
  
  <entry>
    <title>反转链表及其变体</title>
    <link href="http://caohuilong.github.io/2021/08/17/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/"/>
    <id>http://caohuilong.github.io/2021/08/17/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/</id>
    <published>2021-08-16T16:41:47.000Z</published>
    <updated>2021-08-16T16:41:47.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录反转链表的几个典型例题，从迭代和递归的两种方法解决以下几个问题：</p><ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></li><li>反转链表前N个节点</li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">反转链表 II</a></li><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></li></ul><a id="more"></a><h5 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h5><p><strong>题目：</strong>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>1、迭代解法：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp := cur.Next<span class="comment">// 暂存 cur 的 next 节点</span></span><br><span class="line">cur.Next = pre<span class="comment">// 将 pre 节点赋值给 cur.Next</span></span><br><span class="line">pre = cur<span class="comment">// pre向后移动一步</span></span><br><span class="line">cur = tmp<span class="comment">// cur向后移动一步</span></span><br></pre></td></tr></table></figure><p>可以把上面的步骤合并成一句，完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        pre, cur, cur.Next = cur, cur.Next, pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义 pre 节点的时候，用 <code>var</code> 关键字声明并初始化为零值，即 nil。如果用短变量声明操作符 <code>:=</code> 做不到将 pre 设置为 nil。</p></blockquote><p><strong>2、递归解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    last := reverseList(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归解法的时间复杂度与迭代解法一样都是O(N)，但是递归使用的栈空间大小是 O(N)，而迭代解法是 O(1)。但是递归解法思路很清晰，就是将一个大的问题化解为一个更小一点的问题，直到临界情况下直接返回结果即可，这对后续题目的解决提供了一种思路。</p><hr><h5 id="反转链表前N个节点"><a href="#反转链表前N个节点" class="headerlink" title="反转链表前N个节点"></a>反转链表前N个节点</h5><p><strong>题目：</strong>将链表的前 n 个节点反转（n &lt;= 链表长度）</p><p><strong>1、迭代解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    cur := head</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        pre, cur, cur.Next = cur, cur.Next, pre</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    preHead.Next.Next = cur</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、递归解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> successor  *ListNode<span class="comment">// 用于记录第n个节点的next节点 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> helper <span class="function"><span class="keyword">func</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span></span><br><span class="line">    helper = <span class="function"><span class="keyword">func</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">            successor = head.Next</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        last := helper(head.Next, n<span class="number">-1</span>)</span><br><span class="line">        head.Next.Next = head</span><br><span class="line">        head.Next = successor</span><br><span class="line">        <span class="keyword">return</span> last</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(head, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h5><p><strong>题目：</strong>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表。</p><p><strong>1、迭代解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    pre, cur, next := preHead, head, head.Next</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; left &#123;</span><br><span class="line">            pre, cur, next = cur, next, next.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i &gt;= left &amp;&amp; i &lt; right &#123;</span><br><span class="line">            cur, next, next.Next = next, next.Next, cur</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.Next.Next = next<span class="comment">// 当超过范围之后，将pre.Next节点next节点指向next</span></span><br><span class="line">            pre.Next = cur<span class="comment">// pre节点的next指向指向cur</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、递归解法</strong></p><p>当left = 1时，利用reverseN的思路求解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head.Next = reverseBetween(head.Next, left<span class="number">-1</span>, right<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> successor  *ListNode<span class="comment">// 用于记录第n个节点的next节点 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> helper <span class="function"><span class="keyword">func</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span></span><br><span class="line">    helper = <span class="function"><span class="keyword">func</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">            successor = head.Next</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        last := helper(head.Next, n<span class="number">-1</span>)</span><br><span class="line">        head.Next.Next = head</span><br><span class="line">        head.Next = successor</span><br><span class="line">        <span class="keyword">return</span> last</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(head, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h5><p><strong>题目：</strong>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>1、迭代解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">    pre := preHead</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail := pre</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">            <span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> preHead.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next := tail.Next</span><br><span class="line">        head, tail = reverse(head, tail)</span><br><span class="line">        pre.Next = head</span><br><span class="line">        tail.Next = next</span><br><span class="line">        pre = tail</span><br><span class="line">        head = tail.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head, tail *ListNode)</span> <span class="params">(*ListNode, *ListNode)</span></span> &#123;</span><br><span class="line">    pre := tail.Next</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> pre != tail &#123;</span><br><span class="line">        next := cur.Next</span><br><span class="line">        cur.Next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail, head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、递归解法</strong></p><p>每k个节点递归，对k个节点反转利用反转链表的思路：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a, b := head, head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        b = b.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newHead := reverse(a, b)</span><br><span class="line">    a.Next = reverseKGroup(b, k)</span><br><span class="line">    <span class="keyword">return</span> newHead</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转[a, b)的节点，当b=nil时，即反转整个链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(a, b *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    cur := a</span><br><span class="line">    <span class="keyword">for</span> cur != b &#123;</span><br><span class="line">        pre, cur, cur.Next = cur, cur.Next, pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录反转链表的几个典型例题，从迭代和递归的两种方法解决以下几个问题：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list/&quot;&gt;反转链表&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;反转链表前N个节点&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-linked-list-ii/&quot;&gt;反转链表 II&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://leetcode-cn.com/problems/reverse-nodes-in-k-group/&quot;&gt;K 个一组翻转链表&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://caohuilong.github.io/categories/algorithm/"/>
    
    
    <category term="LeetCode" scheme="http://caohuilong.github.io/tags/LeetCode/"/>
    
    <category term="反转链表" scheme="http://caohuilong.github.io/tags/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>单链表解题技巧</title>
    <link href="http://caohuilong.github.io/2021/08/11/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
    <id>http://caohuilong.github.io/2021/08/11/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</id>
    <published>2021-08-11T12:24:35.000Z</published>
    <updated>2021-08-11T12:24:35.000Z</updated>
    
    <content type="html"><![CDATA[<p>单链表是经典题型，本文列出了单链表最常出现的部分题型，并给出了每道题最合适最高效的解决方法，主要的解题方法技巧包含以下三种：</p><ul><li>双指针</li><li>快慢指针</li><li>最小堆</li></ul><a id="more"></a><h5 id="1、合并两个有序链表"><a href="#1、合并两个有序链表" class="headerlink" title="1、合并两个有序链表"></a>1、合并两个有序链表</h5><p><strong>依次迭代</strong>：设置一个伪头节点 preHead 用于指向返回结果的头节点，并将当前节点 cur 指向 preHead。然后对比两个链表的头节点，将 cur 的next指向更小的节点，并将该链表的头节点指向下一个节点。直到有一个链表为空，将另一个链表的剩余部分拼接到 cur 的next节点即可。最后返回伪头节点的 next 节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;&#125;<span class="comment">// dummy节点，用于返回结果</span></span><br><span class="line">    cur := preHead</span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">            cur.Next = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.Next = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        cur.Next = l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        cur.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(N)</p></li><li><p>空间复杂度：O(1)</p></li></ul><hr><h5 id="2、合并-k-个有序链表"><a href="#2、合并-k-个有序链表" class="headerlink" title="2、合并 k 个有序链表"></a>2、合并 <code>k</code> 个有序链表</h5><p><strong>最小堆</strong>：利用 go 语言的提供的 heap 堆，自己实现 heap.Interface 接口定义的五个方法，从而实现一个最小堆。将所有的链表的头节点放入堆中，然后取出堆顶节点放入结果链表中，判断该节点的next节点是否为 nil，如果是 nil 表示该节点所在链表已遍历完毕；如果不是 nil，则将该节点的next节点放入堆中。继续遍历，直到堆的长度为0，表示所有的链表都已遍历完毕。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    h := &amp;minHeap&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> list != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, list)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preHead := &amp;ListNode&#123;&#125;</span><br><span class="line">    cur := preHead</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tmp := heap.Pop(h).(*ListNode)<span class="comment">// 从堆中找出最小的节点，插入到结果链表</span></span><br><span class="line">        cur.Next = tmp</span><br><span class="line">        <span class="keyword">if</span> tmp.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, tmp.Next)<span class="comment">// 将最小节点的next节点放入堆中</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> minHeap []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i].Val &lt; h[j].Val &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(*ListNode))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设链表数量是 k，链表长度是 N：</p><ul><li>时间复杂度：O(Nlogk)</li><li>空间复杂度：O(k)</li></ul><hr><h5 id="3、寻找-删除单链表的倒数第-k-个节点"><a href="#3、寻找-删除单链表的倒数第-k-个节点" class="headerlink" title="3、寻找/删除单链表的倒数第 k 个节点"></a>3、寻找/删除单链表的倒数第 <code>k</code> 个节点</h5><p><strong>双指针</strong>：first 指针先从链表头节点移动 k 步，然后 second 与 first 指针同时移动，当 first 指针指向链表尾部的时候，second 指针指向的就是链表的倒数第 k 个节点。</p><p>寻找和删除倒数第 k 个节点都是相同的思路，下面的代码展示的是删除，不同点在于用了一个 pre 指针指向 second 节点，用于删除要删除的节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    first := head</span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;<span class="comment">// 第一个节点先移动n步</span></span><br><span class="line">        first = first.Next</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre, second := preHead, head</span><br><span class="line">    <span class="keyword">for</span> first != <span class="literal">nil</span> &#123;<span class="comment">// 两个节点一起移动，直到first到达链表尾部</span></span><br><span class="line">        pre, second = second, second.Next</span><br><span class="line">        first = first.Next</span><br><span class="line">    &#125;</span><br><span class="line">    pre.Next = second.Next</span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><hr><h5 id="4、寻找单链表的中点"><a href="#4、寻找单链表的中点" class="headerlink" title="4、寻找单链表的中点"></a>4、寻找单链表的中点</h5><p><strong>快慢指针</strong>：slow 每次移动一步，fast 每次移动两步，当 fast 或者 fast.Next 为空时，slow指针移到了链表的中间节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><hr><h5 id="5、判断单链表是否包含环并找出环起点"><a href="#5、判断单链表是否包含环并找出环起点" class="headerlink" title="5、判断单链表是否包含环并找出环起点"></a>5、判断单链表是否包含环并找出环起点</h5><p><strong>快慢指针</strong>：首先，快慢指针都从表头开始移动，慢指针每次移动一步，快指针每次移动两步，直到两者相遇；然后将快指针指向链表表头，快慢指针再以相同的速度向后移动，当两者再次相遇时，相遇的位置就是环的起点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            slow := head<span class="comment">// fast指向头节点，然后fast与slow以相同的速度相后移动</span></span><br><span class="line">            <span class="keyword">for</span> slow != fast &#123;<span class="comment">// 当slow与fast再次相遇时，代表找到了环的头节点</span></span><br><span class="line">                slow = slow.Next</span><br><span class="line">                fast = fast.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span><span class="comment">// 如果链表没有环，会在fast到达结尾时跳出循环，因此在这里返回nil即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><hr><h5 id="6、判断两个单链表是否相交并找出交点"><a href="#6、判断两个单链表是否相交并找出交点" class="headerlink" title="6、判断两个单链表是否相交并找出交点"></a>6、判断两个单链表是否相交并找出交点</h5><p><strong>双指针</strong>：首先用两个指针分别从两个链表的头节点逐步移动，当指针指向链表结尾时，将该指针指向另一个链表的头节点，直到这两个指针相等时，就代表找到了两个链表相交的节点。</p><blockquote><p>如果两个链表没有相交，最后两个指针都会移到链表结尾，都是 nil，最后返回 nil。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    curA, curB := headA, headB</span><br><span class="line">    <span class="keyword">for</span> curA != curB &#123;</span><br><span class="line">        <span class="keyword">if</span> curA == <span class="literal">nil</span> &#123;</span><br><span class="line">            curA = headB</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curA = curA.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> curB == <span class="literal">nil</span> &#123;</span><br><span class="line">            curB = headA</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curB = curB.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;单链表是经典题型，本文列出了单链表最常出现的部分题型，并给出了每道题最合适最高效的解决方法，主要的解题方法技巧包含以下三种：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;双指针&lt;/li&gt;
&lt;li&gt;快慢指针&lt;/li&gt;
&lt;li&gt;最小堆&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://caohuilong.github.io/categories/algorithm/"/>
    
    
    <category term="LeetCode" scheme="http://caohuilong.github.io/tags/LeetCode/"/>
    
    <category term="单链表" scheme="http://caohuilong.github.io/tags/%E5%8D%95%E9%93%BE%E8%A1%A8/"/>
    
  </entry>
  
  <entry>
    <title>如何寻找veth pair的peer设备</title>
    <link href="http://caohuilong.github.io/2021/04/21/%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BEveth%20pair%E7%9A%84peer%E8%AE%BE%E5%A4%87/"/>
    <id>http://caohuilong.github.io/2021/04/21/%E5%A6%82%E4%BD%95%E6%9F%A5%E6%89%BEveth%20pair%E7%9A%84peer%E8%AE%BE%E5%A4%87/</id>
    <published>2021-04-21T14:17:53.000Z</published>
    <updated>2021-04-21T14:17:53.000Z</updated>
    
    <content type="html"><![CDATA[<p>在网络虚拟化环境中，veth pair常被用跨network namespace的通信，Docker容器的网络就是基于veth pair与network namespace来实现的通，常将veth pair一端置于容器中，另一端连接到虚拟网桥上，从而实现容器网络。但是在网络调试时，经常会需要在veth pair设备上面抓包，在一些虚拟网络设备较多的场景下，不太容易肉眼观察容器中的虚拟网卡与宿主机的虚拟网桥连接的veth pair设备。因此需要方法来寻找veth pair的peer设备。</p><a id="more"></a><p>这里通过创建一个network namespace来模拟一个容器，查找添加到network namespace的veth pair在宿主机的根namespace中的peer设备。</p><h5 id="1、创建虚拟网卡对"><a href="#1、创建虚拟网卡对" class="headerlink" title="1、创建虚拟网卡对"></a>1、创建虚拟网卡对</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip link add veth1 <span class="built_in">type</span> veth peer name veth2</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link <span class="built_in">set</span> veth1 up</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link <span class="built_in">set</span> veth2 up</span></span><br></pre></td></tr></table></figure><h5 id="2、创建network-namespace，并添加虚拟网卡"><a href="#2、创建network-namespace，并添加虚拟网卡" class="headerlink" title="2、创建network namespace，并添加虚拟网卡"></a>2、创建network namespace，并添加虚拟网卡</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip netns add ns1</span></span><br><span class="line"><span class="meta">#</span><span class="bash"> ip link <span class="built_in">set</span> dev veth1 netns ns1</span></span><br></pre></td></tr></table></figure><h5 id="3、在不同命名空间中查看veth-pair的peer设备"><a href="#3、在不同命名空间中查看veth-pair的peer设备" class="headerlink" title="3、在不同命名空间中查看veth-pair的peer设备"></a>3、在不同命名空间中查看veth-pair的peer设备</h5><ul><li><p>方法一</p><p>在目标命名空间中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip netns <span class="built_in">exec</span> ns1 cat /sys/class/net/veth1/iflink</span></span><br><span class="line">7</span><br></pre></td></tr></table></figure><p>然后，在主机上遍历/sys/claas/net下面的全部目录，查看子目录ifindex的值和容器里查出来的iflink值相当的veth名字，这样就找到了容器和主机的veth pair关系。例如，下面的例子中主机上veth2的ifindex刚好是7，意味着是目标容器veth pair的另一端。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> cat /sys/class/net/veth2/ifindex</span> </span><br><span class="line">7</span><br></pre></td></tr></table></figure></li><li><p>方法二</p><p>在目标命名空间中查看：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip netns <span class="built_in">exec</span> ns1 ip link list</span></span><br><span class="line">1: lo: &lt;LOOPBACK&gt; mtu 65536 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00</span><br><span class="line">8: veth1@if7: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether c2:d7:5c:a1:d1:e2 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure><p>从上面的命令输出可以看到8: veth1@if7，其中8是veth1接口的index，7是和它成对的veth的index。当host执行下面的命令时，可以看到对应7的veth网卡是哪一个，这样就得到了容器和veth pair的关系。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip link list</span></span><br><span class="line">7: veth2@if8: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN mode DEFAULT group default qlen 1000</span><br><span class="line">    link/ether da:5e:1a:ea:e6:80 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure></li><li><p>方法三</p><p>可以通过ethtool-S命令列出veth pair对端的网卡index，例如：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip netns <span class="built_in">exec</span> ns1 ethtool -S veth1</span></span><br><span class="line">NIC statistics:</span><br><span class="line">     peer_ifindex: 7</span><br></pre></td></tr></table></figure><p>而主机上index为6的网卡为：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ip addr</span></span><br><span class="line">7: veth2@if8: &lt;BROADCAST,MULTICAST&gt; mtu 1500 qdisc noop state DOWN group default qlen 1000</span><br><span class="line">    link/ether da:5e:1a:ea:e6:80 brd ff:ff:ff:ff:ff:ff link-netnsid 0</span><br></pre></td></tr></table></figure></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;在网络虚拟化环境中，veth pair常被用跨network namespace的通信，Docker容器的网络就是基于veth pair与network namespace来实现的通，常将veth pair一端置于容器中，另一端连接到虚拟网桥上，从而实现容器网络。但是在网络调试时，经常会需要在veth pair设备上面抓包，在一些虚拟网络设备较多的场景下，不太容易肉眼观察容器中的虚拟网卡与宿主机的虚拟网桥连接的veth pair设备。因此需要方法来寻找veth pair的peer设备。&lt;/p&gt;</summary>
    
    
    
    <category term="网络虚拟化" scheme="http://caohuilong.github.io/categories/%E7%BD%91%E7%BB%9C%E8%99%9A%E6%8B%9F%E5%8C%96/"/>
    
    
    <category term="veth pair" scheme="http://caohuilong.github.io/tags/veth-pair/"/>
    
    <category term="namespace" scheme="http://caohuilong.github.io/tags/namespace/"/>
    
  </entry>
  
  <entry>
    <title>Golang互斥锁与读写锁</title>
    <link href="http://caohuilong.github.io/2021/03/14/Golang%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/"/>
    <id>http://caohuilong.github.io/2021/03/14/Golang%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/</id>
    <published>2021-03-14T09:07:44.000Z</published>
    <updated>2021-03-14T09:07:44.000Z</updated>
    
    <content type="html"><![CDATA[<p>Go语言通过 go 关键字可以很方便的创建 goroutine 实现并发编程，但是不同的 goroutine 同时访问或者修改公共资源时会带来一些意想不到的结果。在并发编程时，可以借助 Golang 的锁机制来保证数据安全，本文将介绍 Golang 的两种锁：<strong>互斥锁</strong>与<strong>读写锁</strong>，首先对这两种锁进行概念上的对比，然后通过实验对比不加锁与加锁的区别，最后介绍读写锁的读锁与写锁的互斥原则。</p><a id="more"></a><h5 id="互斥锁与读写锁的区别"><a href="#互斥锁与读写锁的区别" class="headerlink" title="互斥锁与读写锁的区别"></a>互斥锁与读写锁的区别</h5><p>Go 语言标准库 <code>sync</code> 提供了 2 种锁，互斥锁 <code>sync.Mutex</code> 和读写锁 <code>sync.RWMutex</code> 。他们的区别如下：</p><ul><li>互斥锁：互斥即不可同时运行。即使用了互斥锁的两个代码片段互相排斥，只有其中一个代码片段执行完成后，另一个才能执行。Go 标准库中提供了 sync.Mutex 互斥锁类型及其两个方法：<ul><li>Lock 加锁</li><li>Unlock 释放锁</li></ul></li><li>读写锁：读写锁分为读锁和写锁，读锁是允许同时执行的，但写锁是互斥的。Go 标准库中提供了 sync.RWMutex 互斥锁类型及其四个方法：<ul><li>Lock 加写锁</li><li>Unlock 释放写锁</li><li>RLock 加读锁</li><li>RUnlock 释放读锁</li></ul></li></ul><h5 id="不加锁与加互斥锁的区别"><a href="#不加锁与加互斥锁的区别" class="headerlink" title="不加锁与加互斥锁的区别"></a>不加锁与加互斥锁的区别</h5><p>下面的代码，开启了三个协程，每个协程让一个公共变量 count 加 10000 次 1，初看下来，最终的 count 值应该是 30000</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++ &#123;</span><br><span class="line">count = count + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;count=%d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际上运行的结果可能并不等于 30000，而且每次运行的结果各不相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次</span></span><br><span class="line">count=<span class="number">19623</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次</span></span><br><span class="line">count=<span class="number">15833</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次</span></span><br><span class="line">count=<span class="number">20865</span></span><br></pre></td></tr></table></figure><p>原因就在于这三个协程在执行时，先读取 count 再更新 count 的值，而这个过程并不具备原子性，所以导致了数据的不准确。</p><p>解决这个问题的方法，就是给修改 count 的代码加上 Mutex 互斥锁，要求同一时刻，仅能有一个协程能对 count 操作。修改上面的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">lock := sync.Mutex&#123;&#125;<span class="comment">// 定义一个互斥锁</span></span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++ &#123;</span><br><span class="line">lock.Lock()<span class="comment">// 操作count之前加锁</span></span><br><span class="line">count = count + <span class="number">1</span></span><br><span class="line">lock.Unlock()<span class="comment">// 操作完之后释放锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;count=%d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管执行多少次上面的程序，输出都只有一个结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count=<span class="number">30000</span></span><br></pre></td></tr></table></figure><p>使用 Mutext 锁虽然很简单，但仍然有几点需要注意：</p><ul><li>同一协程里，不要在尚未解锁时再次使加锁</li><li>同一协程里，不要对已解锁的锁再次解锁</li><li>加了锁后，别忘了解锁，必要时使用 defer 语句</li></ul><h5 id="读锁与写锁的互斥原则"><a href="#读锁与写锁的互斥原则" class="headerlink" title="读锁与写锁的互斥原则"></a>读锁与写锁的互斥原则</h5><p>主要的互斥原则如下：</p><ol><li>读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。</li><li>写锁之间是互斥的，存在写锁，其他写锁阻塞。</li><li>写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。</li></ol><p>先来看一下下面的程序，有四个协程，有两个加写锁，还有两个加读锁，加锁之后分别休眠 1s，表示处理逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">lock = sync.RWMutex&#123;&#125;</span><br><span class="line">wg = sync.WaitGroup&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeLock</span><span class="params">(s <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">lock.Lock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine %s get write lock\n&quot;</span>, s)</span><br><span class="line">time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine %s release write lock\n&quot;</span>, s)</span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readLock</span><span class="params">(s <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">lock.RLock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine %s get read lock\n&quot;</span>, s)</span><br><span class="line">time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine %s release read lock\n&quot;</span>, s)</span><br><span class="line">lock.RUnlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">wg.Add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> writeLock(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> writeLock(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> readLock(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> readLock(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">goroutine A get write lock&#x2F;&#x2F; 协程A获得写锁之后，其他协程必须等它释放写锁之后才能加锁 ——验证了写锁与其他的锁互斥</span><br><span class="line">goroutine A release write lock</span><br><span class="line">goroutine D get read lock&#x2F;&#x2F; 协程C与D在A释放写锁之后，同时获得了读锁，处理逻辑可以并行执行 ——验证了读锁之间不互斥</span><br><span class="line">goroutine C get read lock</span><br><span class="line">goroutine D release read lock</span><br><span class="line">goroutine C release read lock</span><br><span class="line">goroutine B get write lock&#x2F;&#x2F; 协程B必须要等C和D都释放读锁之后，才能加写锁 ——验证了读锁与写锁互斥，存在读锁，写锁阻塞</span><br><span class="line">goroutine B release write lock</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;Go语言通过 go 关键字可以很方便的创建 goroutine 实现并发编程，但是不同的 goroutine 同时访问或者修改公共资源时会带来一些意想不到的结果。在并发编程时，可以借助 Golang 的锁机制来保证数据安全，本文将介绍 Golang 的两种锁：&lt;strong&gt;互斥锁&lt;/strong&gt;与&lt;strong&gt;读写锁&lt;/strong&gt;，首先对这两种锁进行概念上的对比，然后通过实验对比不加锁与加锁的区别，最后介绍读写锁的读锁与写锁的互斥原则。&lt;/p&gt;</summary>
    
    
    
    <category term="Golang" scheme="http://caohuilong.github.io/categories/Golang/"/>
    
    
    <category term="互斥锁" scheme="http://caohuilong.github.io/tags/%E4%BA%92%E6%96%A5%E9%94%81/"/>
    
    <category term="读写锁" scheme="http://caohuilong.github.io/tags/%E8%AF%BB%E5%86%99%E9%94%81/"/>
    
  </entry>
  
  <entry>
    <title>kms</title>
    <link href="http://caohuilong.github.io/2021/03/08/kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://caohuilong.github.io/2021/03/08/kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2021-03-07T17:13:29.000Z</published>
    <updated>2021-03-07T17:13:29.000Z</updated>
    
    <content type="html"><![CDATA[<p><a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys">https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys</a></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/windows%E6%9C%AA%E6%BF%80%E6%B4%BB.png" alt="image-20211117142459997"></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85%E4%BA%A7%E5%93%81%E5%AF%86%E9%92%A5.png" alt="image-20211117143106411"></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%88%90%E5%8A%9F%E8%AE%BE%E7%BD%AEkms%E6%9C%8D%E5%8A%A1%E5%9C%B0%E5%9D%80.png" alt="image-20211117143548790"></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%88%90%E5%8A%9F%E6%BF%80%E6%B4%BBwindows.png" alt="image-20211117143803951"></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/windows%E5%B7%B2%E6%BF%80%E6%B4%BB.png" alt="image-20211117143928887"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;a href=&quot;https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys&quot;&gt;https://docs.microsoft.com/zh-cn/windows</summary>
      
    
    
    
    <category term="Winodows" scheme="http://caohuilong.github.io/categories/Winodows/"/>
    
    
    <category term="kms激活" scheme="http://caohuilong.github.io/tags/kms%E6%BF%80%E6%B4%BB/"/>
    
  </entry>
  
  <entry>
    <title>Windows镜像制作</title>
    <link href="http://caohuilong.github.io/2021/01/17/Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"/>
    <id>http://caohuilong.github.io/2021/01/17/Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</id>
    <published>2021-01-16T17:16:49.000Z</published>
    <updated>2021-01-16T17:16:49.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文以 windows server 2016 系统为例，介绍在 KVM 环境制作 windows 虚机镜像的过程，该镜像主要用于 Kubernetes kubevirt 项目创建虚机，能供通过 cloudBase-init 完成虚机的初始化。</p><a id="more"></a><h4 id="一、创建windows"><a href="#一、创建windows" class="headerlink" title="一、创建windows"></a>一、创建windows</h4><h5 id="1、下载镜像"><a href="#1、下载镜像" class="headerlink" title="1、下载镜像"></a>1、下载镜像</h5><p>可以在 <a href="http://www.itellyou.cn/">www.itellyou.cn</a> 网站上面下载官方系统镜像文件 ，这里下载windows server 2016的镜像，下载好之后放到 KVM 主机中，在 /var/lib/libvirt/images/ 中新建一个 windows 文件夹，用户存放 iso 和后面创建的虚机安装磁盘 qcow2 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/libvirt/images/</span><br><span class="line">mkdir windows</span><br><span class="line">cd windows</span><br></pre></td></tr></table></figure><h5 id="2、创建系统安装磁盘文件"><a href="#2、创建系统安装磁盘文件" class="headerlink" title="2、创建系统安装磁盘文件"></a>2、创建系统安装磁盘文件</h5><p>用 qemu-img 命令创建一个 qcow2 格式的磁盘文件，大小设置 20G：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 cn_windows_server_2016_x64_dvd_9718765.qcow2 20G</span><br></pre></td></tr></table></figure><h5 id="3、创建虚机"><a href="#3、创建虚机" class="headerlink" title="3、创建虚机"></a>3、创建虚机</h5><p>通过virt-install命令创建虚机，指定虚机系统文件是 iso 文件，安装磁盘是 qcow2 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt-install --name cn_windows_server_2016_x64_dvd_9718765 --memory 8192 --vcpus 4  --cdrom&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;windows&#x2F;cn_windows_server_2016_x64_dvd_9718765.iso  --disk path&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;windows&#x2F;cn_windows_server_2016_x64_dvd_9718765.qcow2,format&#x3D;qcow2 --network default --graphics vnc,port&#x3D;5945,listen&#x3D;0.0.0.0 --channel unix,target_type&#x3D;virtio,name&#x3D;org.qemu.guest_agent.0  --virt-type kvm --os-variant windows --noautoconsole</span><br></pre></td></tr></table></figure><p>通过 vnc 登录虚机，进入 windows 系统安装程序</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/windows%E5%AE%89%E8%A3%85%E7%95%8C%E9%9D%A2.png" alt="windows安装界面"></p><p>没有产品密钥，点击 <u>我没有产品密钥</u>：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E6%BF%80%E6%B4%BBwindows.png" alt="激活windows"></p><p>选择要安装的操作系统，选择第二个有桌面的，点击下一步：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E9%80%89%E6%8B%A9%E8%A6%81%E5%AE%89%E8%A3%85%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" alt="选择要安装的操作系统"></p><p>接受许可条款之后，点击下一步。进入下面的界面，选择 <u>自定义：仅安装 Windows（高级）</u>：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E9%80%89%E6%8B%A9%E5%AE%89%E8%A3%85%E7%B1%BB%E5%9E%8B.png" alt="选择安装类型"></p><p>选择唯一的一个驱动器，点击下一步：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84.png" alt="安装路径"></p><p>进入 windows 系统安装过程，这个过程自动完成：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E6%AD%A3%E5%9C%A8%E5%AE%89%E8%A3%85windows.png" alt="正在安装windows"></p><p>完成上面的系统安装过程之后，虚机会自动关机。</p><p>先不要开机，先按照后面的步骤进行操作。</p><h5 id="4、卸载系统iso文件"><a href="#4、卸载系统iso文件" class="headerlink" title="4、卸载系统iso文件"></a>4、卸载系统iso文件</h5><p>通过下面的命令直接修改虚机 xml 模板，如果不卸载，下次重启还会进入安装系统的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh edit cn_windows_server_2016_x64_dvd_9718765</span><br></pre></td></tr></table></figure><p>删除下面几行的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;cdrom&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/var/lib/libvirt/images/windows/cn_windows_server_2016_x64_dvd_9718765.iso&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hdb&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ide&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;drive&#x27;</span> <span class="attr">controller</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">target</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续后续的操作。</p><hr><h4 id="二、安装windows镜像需要的驱动"><a href="#二、安装windows镜像需要的驱动" class="headerlink" title="二、安装windows镜像需要的驱动"></a>二、安装windows镜像需要的驱动</h4><p>主要需要的驱动有：pci scsi驱动、ballon驱动、virtio serial驱动</p><p>这些驱动在 virtio 的驱动文件中都能找到，<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso</a> 通过这个链接可以下载最新的稳定版本，也是一个 iso 文件。</p><p>下载之后，放到上面创建的 windows 目录下，并通过修改虚机 xml 文件模板将驱动文件挂载到虚机中</p><h5 id="1、将-virtio-win-iso-挂载到虚机上："><a href="#1、将-virtio-win-iso-挂载到虚机上：" class="headerlink" title="1、将 virtio-win.iso 挂载到虚机上："></a>1、将 virtio-win.iso 挂载到虚机上：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;cdrom&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/var/lib/libvirt/images/windows/virtio-win-0.1.204.iso&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hdb&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ide&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、添加SCSI控制器驱动——磁盘"><a href="#2、添加SCSI控制器驱动——磁盘" class="headerlink" title="2、添加SCSI控制器驱动——磁盘"></a>2、添加SCSI控制器驱动——磁盘</h5><p>给虚机挂载一个任意一个磁盘，设置其通道为 virtio 型，这样虚机启动之后就会提示需要安装相应的驱动</p><p>用以下命令随便创建一个磁盘文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create test.iso 10k</span><br></pre></td></tr></table></figure><p>修改虚机 xml 模板文件，添加下面的磁盘配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;disk&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/var/lib/libvirt/images/windows/test.iso&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hdd&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3、添加以太网控制器驱动——网卡"><a href="#3、添加以太网控制器驱动——网卡" class="headerlink" title="3、添加以太网控制器驱动——网卡"></a>3、添加以太网控制器驱动——网卡</h5><p>在虚机 xml 模板中找到网络接口配置，将网卡设备类型设置为 virtio：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;network&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;52:54:00:10:a2:f4&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">network</span>=<span class="string">&#x27;default&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x03&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4、添加PCI简易设备驱动——qemu-guest-agent与宿主机连接"><a href="#4、添加PCI简易设备驱动——qemu-guest-agent与宿主机连接" class="headerlink" title="4、添加PCI简易设备驱动——qemu-guest-agent与宿主机连接"></a>4、添加PCI简易设备驱动——qemu-guest-agent与宿主机连接</h5><p>虚机xml中添加以下设备：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">channel</span> <span class="attr">type</span>=<span class="string">&#x27;unix&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">mode</span>=<span class="string">&#x27;bind&#x27;</span> <span class="attr">path</span>=<span class="string">&#x27;/var/lib/libvirt/qemu/org.qemu.guest_agent.0&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;org.qemu.guest_agent.0&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;virtio-serial&#x27;</span> <span class="attr">controller</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">channel</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果有就不需要重复添加。qemu-guest-agent 相关参考链接：<a href="https://pve.proxmox.com/wiki/Qemu-guest-agent">https://pve.proxmox.com/wiki/Qemu-guest-agent</a></p></blockquote><h5 id="5、启动虚机，安装驱动"><a href="#5、启动虚机，安装驱动" class="headerlink" title="5、启动虚机，安装驱动"></a>5、启动虚机，安装驱动</h5><p>使用命令启动虚机，并通过 vnc 界面登录虚机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh start cn_windows_server_2016_x64_dvd_9718765</span><br></pre></td></tr></table></figure><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81.png" alt="设置初始密码"></p><p>输入 CTRL-ALT-DELETE之后，输入 Administrator 的密码，进入系统</p><p>打开设备管理器，看到有几个设备都提示感叹号，这是因为这些设备的驱动还未安装：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8.png" alt="设备管理器"></p><p>依次安装下列驱动：</p><ul><li>PCI简单通讯控制器驱动</li><li>PCI设备驱动</li><li>SCSI控制器驱动</li><li>以太网控制器驱动</li></ul><p>从计算机上面查找驱动程序</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E6%B5%8F%E8%A7%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%A5%E6%9F%A5%E6%89%BE%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.png" alt="浏览计算机以查找驱动程序"></p><p>选择 CD 驱动器(D:) virtio-win-0.1.204</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E9%80%89%E6%8B%A9CD%E9%A9%B1%E5%8A%A8%E5%99%A8.png" alt="选择CD驱动器"></p><p>选择后点击下一步：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/D%E7%9B%98.png" alt="D盘"></p><p>完成驱动程序安装：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8.png" alt="成功安装驱动"></p><h5 id="6、安装qumu-guest-agent"><a href="#6、安装qumu-guest-agent" class="headerlink" title="6、安装qumu-guest-agent"></a>6、安装qumu-guest-agent</h5><p>也从 CD 驱动器(D:) virtio-win-0.1.204 中找到下面路径的安装程序，点击安装</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E5%AE%89%E8%A3%85qemu-guest-agent.png" alt="安装qemu-guest-agent"></p><p>安装完成之后，进入最后一步安装 cloudBase-init</p><hr><h4 id="三、windows虚机CloudBaseInit配置"><a href="#三、windows虚机CloudBaseInit配置" class="headerlink" title="三、windows虚机CloudBaseInit配置"></a>三、windows虚机CloudBaseInit配置</h4><p>首先需要在虚机里面安装 cloudBase-init，可以在虚机里面访问 cloudBase-init 网站，或者在宿主机中下载后，通过磁盘挂载到虚机中进行安装，参考我之前的博客：<u>windows虚机挂载磁盘共享宿主机文件</u>。</p><p>安装好 cloudBase-init之后，需要配置 cloudBase-init</p><h5 id="1、cloudBaseInit-conf文件配置"><a href="#1、cloudBaseInit-conf文件配置" class="headerlink" title="1、cloudBaseInit conf文件配置"></a>1、cloudBaseInit conf文件配置</h5><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/cloudbase-init.png" alt="cloudbase-init"></p><p>配置的元数据服务是 noCloudService，并设置需要用到的插件。</p><h5 id="2、windows镜像执行sysprep"><a href="#2、windows镜像执行sysprep" class="headerlink" title="2、windows镜像执行sysprep"></a>2、windows镜像执行sysprep</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd C:\Program Files\CloudBase Solution\Cloudbase-Init\Conf</span><br><span class="line">&gt; C:\Windows\System32\Sysprep\sysprep.exe &#x2F;generalize &#x2F;oobe &#x2F;unattend:Unattend.xml</span><br></pre></td></tr></table></figure><blockquote><p>注意：需要在administrator用户下执行才行，要不然会报找不到Unattend.xml文件的错误</p></blockquote><h5 id="3、用户数据注入"><a href="#3、用户数据注入" class="headerlink" title="3、用户数据注入"></a>3、用户数据注入</h5><p>下面测试通过元数据注入的方式，给windows虚机设置初始密码</p><p>==必须要设置一个新的instan-id，虚机启动的时候才会重新根据用户数据初始话==</p><ul><li><p>meta_data</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance-id: cn_windows_server_2016_x64_dvd_9718765</span><br><span class="line">local-hostname: windows2016</span><br></pre></td></tr></table></figure></li><li><p>user_data</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#cloud-config</span><br><span class="line">users:</span><br><span class="line"> -</span><br><span class="line">  name: Administrator</span><br><span class="line">  groups: Administrators</span><br><span class="line">  passwd: windows2016</span><br><span class="line">  inactive: False</span><br></pre></td></tr></table></figure><h5 id="4、kvm创建虚机注入用户数据"><a href="#4、kvm创建虚机注入用户数据" class="headerlink" title="4、kvm创建虚机注入用户数据"></a>4、kvm创建虚机注入用户数据</h5></li><li><p>将用户数据打包成磁盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## create a disk to attach with some user-data and meta-data</span><br><span class="line">$ genisoimage  -output seed.iso -volid cidata -joliet -rock user-data meta-data</span><br></pre></td></tr></table></figure></li><li><p>挂载到虚机，虚机xml模板添加以下磁盘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;disk type&#x3D;&#39;file&#39; device&#x3D;&#39;cdrom&#39;&gt;</span><br><span class="line">     &lt;driver name&#x3D;&#39;qemu&#39; type&#x3D;&#39;raw&#39;&#x2F;&gt;</span><br><span class="line">     &lt;source file&#x3D;&#39;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;data&#x2F;seed.iso&#39;&#x2F;&gt;</span><br><span class="line">     &lt;target dev&#x3D;&#39;hdb&#39; bus&#x3D;&#39;ide&#39;&#x2F;&gt;</span><br><span class="line">     &lt;readonly&#x2F;&gt;</span><br><span class="line">     &lt;address type&#x3D;&#39;drive&#39; controller&#x3D;&#39;0&#39; bus&#x3D;&#39;0&#39; target&#x3D;&#39;0&#39; unit&#x3D;&#39;1&#39;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;disk&gt;</span><br></pre></td></tr></table></figure><p>虚机重启之后，就能完成 windows 虚机的初始化。</p></li></ul><hr><p>。。。。终于写完了，这个写的好麻烦，过程步骤太多，细节也很多，写的有点晕 T_T 。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文以 windows server 2016 系统为例，介绍在 KVM 环境制作 windows 虚机镜像的过程，该镜像主要用于 Kubernetes kubevirt 项目创建虚机，能供通过 cloudBase-init 完成虚机的初始化。&lt;/p&gt;</summary>
    
    
    
    <category term="KVM" scheme="http://caohuilong.github.io/categories/KVM/"/>
    
    
    <category term="镜像" scheme="http://caohuilong.github.io/tags/%E9%95%9C%E5%83%8F/"/>
    
    <category term="Winodws" scheme="http://caohuilong.github.io/tags/Winodws/"/>
    
    <category term="CloudBase-init" scheme="http://caohuilong.github.io/tags/CloudBase-init/"/>
    
  </entry>
  
  <entry>
    <title>windows虚机挂载磁盘共享宿主机文件</title>
    <link href="http://caohuilong.github.io/2021/01/15/%E5%88%9B%E5%BB%BA%E5%8F%AF%E6%8C%82%E8%BD%BD%E5%88%B0windows%E8%99%9A%E6%9C%BA%E7%9A%84%E7%A3%81%E7%9B%98/"/>
    <id>http://caohuilong.github.io/2021/01/15/%E5%88%9B%E5%BB%BA%E5%8F%AF%E6%8C%82%E8%BD%BD%E5%88%B0windows%E8%99%9A%E6%9C%BA%E7%9A%84%E7%A3%81%E7%9B%98/</id>
    <published>2021-01-15T11:52:31.000Z</published>
    <updated>2021-01-15T11:52:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>在 KVM 环境创建具有图形化界面的 windows 虚机之后，虚机可能在某些情况下无法连接外网，比如网卡驱动未安装的情况下。这时需要在虚机里面安装软件就显得特别麻烦，比如需要安装 windows 虚机镜像初始化软件 cloudBase-init。本文介绍一种通过给 windows 虚机挂载磁盘的方式共享宿主机文件的方法。</p><a id="more"></a><h5 id="准备文件"><a href="#准备文件" class="headerlink" title="准备文件"></a>准备文件</h5><p>先将需要放到 iso 中的文件准备好，我这里准备了 cloudBase-init 的安装程序，放到 cloudbase 目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls cloudbase/</span></span><br><span class="line">CloudbaseInitSetup_Stable_x64.msi</span><br></pre></td></tr></table></figure><h5 id="创建iso镜像文件"><a href="#创建iso镜像文件" class="headerlink" title="创建iso镜像文件"></a>创建iso镜像文件</h5><p>然后用 mkisofs 命令将 cloudbase/ 目录打包到一个名叫 cloudbase.iso 的镜像文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkisofs -r -v -o cloudbase.iso cloudbase/</span></span><br><span class="line">I: -input-charset not specified, using utf-8 (detected in locale settings)</span><br><span class="line">genisoimage 1.1.11 (Linux)</span><br><span class="line">Scanning cloudbase/</span><br><span class="line">Writing:   Initial Padblock                        Start Block 0</span><br><span class="line">Done with: Initial Padblock                        Block(s)    16</span><br><span class="line">Writing:   Primary Volume Descriptor               Start Block 16</span><br><span class="line">Done with: Primary Volume Descriptor               Block(s)    1</span><br><span class="line">Writing:   End Volume Descriptor                   Start Block 17</span><br><span class="line">Done with: End Volume Descriptor                   Block(s)    1</span><br><span class="line">Writing:   Version block                           Start Block 18</span><br><span class="line">Done with: Version block                           Block(s)    1</span><br><span class="line">Writing:   Path table                              Start Block 19</span><br><span class="line">Done with: Path table                              Block(s)    4</span><br><span class="line">Writing:   Directory tree                          Start Block 23</span><br><span class="line">Done with: Directory tree                          Block(s)    1</span><br><span class="line">Writing:   Directory tree cleanup                  Start Block 24</span><br><span class="line">Done with: Directory tree cleanup                  Block(s)    0</span><br><span class="line">Writing:   Extension record                        Start Block 24</span><br><span class="line">Done with: Extension record                        Block(s)    1</span><br><span class="line">Writing:   The File(s)                             Start Block 25</span><br><span class="line"> 18.61% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line"> 37.25% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line"> 55.83% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line"> 74.46% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line"> 93.04% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line">Total translation table size: 0</span><br><span class="line">Total rockridge attributes bytes: 365</span><br><span class="line">Total directory bytes: 0</span><br><span class="line">Path table size(bytes): 10</span><br><span class="line">Done with: The File(s)                             Block(s)    26697</span><br><span class="line">Writing:   Ending Padblock                         Start Block 26722</span><br><span class="line">Done with: Ending Padblock                         Block(s)    150</span><br><span class="line">Max brk space used 0</span><br><span class="line">26872 extents written (52 MB)</span><br></pre></td></tr></table></figure><h5 id="挂载到虚机中使用"><a href="#挂载到虚机中使用" class="headerlink" title="挂载到虚机中使用"></a>挂载到虚机中使用</h5><p>修改虚机 xml 模板文件，添加上述的 iso 镜像文件作为一块磁盘：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;cdrom&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/var/lib/libvirt/images/windows/cloudbase.iso&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hdd&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ide&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;drive&#x27;</span> <span class="attr">controller</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">target</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动虚机之后，即打开磁盘即可访问到磁盘中的文件，如图</p><img src="./2021-01-15-创建可挂载到windows虚机的磁盘/可见磁盘.png" style="zoom:50%;" />]]></content>
    
    
    <summary type="html">&lt;p&gt;在 KVM 环境创建具有图形化界面的 windows 虚机之后，虚机可能在某些情况下无法连接外网，比如网卡驱动未安装的情况下。这时需要在虚机里面安装软件就显得特别麻烦，比如需要安装 windows 虚机镜像初始化软件 cloudBase-init。本文介绍一种通过给 windows 虚机挂载磁盘的方式共享宿主机文件的方法。&lt;/p&gt;</summary>
    
    
    
    <category term="KVM" scheme="http://caohuilong.github.io/categories/KVM/"/>
    
    
    <category term="Windows" scheme="http://caohuilong.github.io/tags/Windows/"/>
    
    <category term="磁盘" scheme="http://caohuilong.github.io/tags/%E7%A3%81%E7%9B%98/"/>
    
  </entry>
  
  <entry>
    <title>CentOS6.5安装cloudinit-18</title>
    <link href="http://caohuilong.github.io/2020/12/09/CentOS6-5%E5%AE%89%E8%A3%85cloudinit-18/"/>
    <id>http://caohuilong.github.io/2020/12/09/CentOS6-5%E5%AE%89%E8%A3%85cloudinit-18/</id>
    <published>2020-12-09T08:40:19.000Z</published>
    <updated>2020-12-09T08:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前有个 CentOS6.x 的系统镜像，默认支持 cloud-init-0.7.5 版本 rpm，但是 cloud-init-0.7.5 无法通过本地化 QEMU 利用 NoCloud 数据源进行 IP 地址管理，因此无法实现虚机的网络初始化，需要手动进行配置。经过测试实验，cloud-init 17 以上版本能够支持 NoCloud 数据源信息注入，但是 cloud-init 17 及以上版本需要 python2.7 或者 python3 才能运行，而 CentOS6.x 系统默认使用 python2.6。因此为了在 CentOS6.x 上安装 cloud-init 17 以上的版本，需要先升级 python2.7，然后再安装 cloud-init。</p><a id="more"></a><hr><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h3 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h3><h5 id="1、安装-EPEL-源"><a href="#1、安装-EPEL-源" class="headerlink" title="1、安装 EPEL 源"></a>1、安装 EPEL 源</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>如果安装软件出现问题，见后续的问题记录1。</p></li><li><p>此外，安装 EPEL 源之后，安装软件还可能出问题，继续见后续问题记录2。</p></li></ul></blockquote><h5 id="2、安装-cloud-init-等软件包"><a href="#2、安装-cloud-init-等软件包" class="headerlink" title="2、安装 cloud-init 等软件包"></a>2、安装 cloud-init 等软件包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install qemu-guest-agent cloud-utils-growpart gdisk libicu cloud-init dracut-modules-growroot</span><br></pre></td></tr></table></figure><h5 id="3、安装-versionlock-并锁定-cloud-init"><a href="#3、安装-versionlock-并锁定-cloud-init" class="headerlink" title="3、安装 versionlock 并锁定 cloud-init"></a>3、安装 versionlock 并锁定 cloud-init</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install yum-plugin-versionlock</span><br><span class="line">yum versionlock add cloud-init</span><br></pre></td></tr></table></figure><h5 id="4、修改配置"><a href="#4、修改配置" class="headerlink" title="4、修改配置"></a>4、修改配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa kernel | sed &#39;s&#x2F;^kernel-&#x2F;&#x2F;&#39;  | xargs -I &#123;&#125; dracut -f &#x2F;boot&#x2F;initramfs-&#123;&#125;.img &#123;&#125;</span><br><span class="line"></span><br><span class="line">chkconfig cloud-config on</span><br><span class="line">chkconfig cloud-init on</span><br><span class="line">chkconfig cloud-final on</span><br><span class="line"></span><br><span class="line">sed -i &#39;&#x2F;$cloud_init $CLOUDINITARGS init&#x2F;a \</span><br><span class="line">    service network restart&#39; &#x2F;etc&#x2F;init.d&#x2F;cloud-init</span><br></pre></td></tr></table></figure><h3 id="安装-python2-7"><a href="#安装-python2-7" class="headerlink" title="安装 python2.7"></a>安装 python2.7</h3><h5 id="1、源码安装-python"><a href="#1、源码安装-python" class="headerlink" title="1、源码安装 python"></a>1、源码安装 python</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc openssl-devel bzip2-devel</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;2.7.16&#x2F;Python-2.7.16.tgz</span><br><span class="line">tar xzf Python-2.7.16.tgz</span><br><span class="line">cd Python-2.7.16</span><br><span class="line">.&#x2F;configure --enable-optimizations</span><br><span class="line">make altinstall</span><br><span class="line">curl &quot;https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py&quot; -o &quot;get-pip.py&quot;</span><br><span class="line">python2.7 get-pip.py</span><br></pre></td></tr></table></figure><blockquote><p>下载 get-pip.py 脚本时可能碰到 curl: (35) SSL connect error 的问题，见问题记录3。</p></blockquote><h5 id="2、下载-cloud-init-依赖的-python-包"><a href="#2、下载-cloud-init-依赖的-python-包" class="headerlink" title="2、下载 cloud-init 依赖的 python 包"></a>2、下载 cloud-init 依赖的 python 包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip2.7 install six</span><br><span class="line">pip2.7 install pyyaml</span><br><span class="line">pip2.7 install requests</span><br><span class="line">pip2.7 install jsonpatch</span><br><span class="line">pip2.7 install configobj</span><br></pre></td></tr></table></figure><blockquote><p>pip 下载失败可以更换国内源，见问题记录4。</p></blockquote><h3 id="更新-Cloud-init"><a href="#更新-Cloud-init" class="headerlink" title="更新 Cloud-init"></a>更新 Cloud-init</h3><h5 id="1、下载安装-cloud-init"><a href="#1、下载安装-cloud-init" class="headerlink" title="1、下载安装 cloud-init"></a>1、下载安装 cloud-init</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">mkdir cloud-init</span><br><span class="line">cd cloud-init</span><br><span class="line">wget http:&#x2F;&#x2F;ftp.riken.jp&#x2F;Linux&#x2F;cern&#x2F;centos&#x2F;7&#x2F;updates&#x2F;x86_64&#x2F;Packages&#x2F;cloud-init-18.5-3.el7.centos.x86_64.rpm</span><br><span class="line">rpm2cpio cloud-init-18.5-3.el7.centos.x86_64.rpm  | cpio -idmv</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;etc&#x2F;bash_completion.d&#x2F;* &#x2F;etc&#x2F;bash_completion.d</span><br><span class="line">rm -rf &#x2F;etc&#x2F;cloud&#x2F;</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;etc&#x2F;cloud  &#x2F;etc&#x2F;</span><br><span class="line">mv -f &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;etc&#x2F;rsyslog.d&#x2F;* &#x2F;etc&#x2F;rsyslog.d&#x2F;</span><br><span class="line">mkdir -p &#x2F;run&#x2F;cloud-init</span><br><span class="line">sed -i &#39;s&#x2F;\&#x2F;usr\&#x2F;bin\&#x2F;python&#x2F;\&#x2F;usr\&#x2F;local\&#x2F;bin\&#x2F;python2.7&#x2F;g&#39; &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;bin&#x2F;*</span><br><span class="line">mv -f &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;* &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;lib&#x2F;tmpfiles.d</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;lib&#x2F;tmpfiles.d&#x2F;* &#x2F;usr&#x2F;lib&#x2F;tmpfiles.d&#x2F;</span><br><span class="line">rm -rf &#x2F;usr&#x2F;libexec&#x2F;cloud-init</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;libexec&#x2F;* &#x2F;usr&#x2F;libexec&#x2F;</span><br><span class="line">rm -rf &#x2F;usr&#x2F;local&#x2F;src&#x2F;*</span><br></pre></td></tr></table></figure><h5 id="2、修改-cloud-init-配置"><a href="#2、修改-cloud-init-配置" class="headerlink" title="2、修改 cloud-init 配置"></a>2、修改 cloud-init 配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s&#x2F;disable_root.*&#x2F;disable_root\: 0&#x2F;;s&#x2F;ssh_pwauth.*&#x2F;ssh_pwauth\: 0&#x2F;&quot; &#x2F;etc&#x2F;cloud&#x2F;cloud.cfg</span><br></pre></td></tr></table></figure><p>最后执行验证 cloud-init 更新成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cloud-init</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;cloud-init 18.5</span><br></pre></td></tr></table></figure><p>大功告成！！！后面就可以对虚机做一些别的配置，最后制作成一个镜像了。</p><hr><h1 id="可能遇到的问题记录"><a href="#可能遇到的问题记录" class="headerlink" title="可能遇到的问题记录"></a>可能遇到的问题记录</h1><h5 id="1、yum-下载软件包出错-Error-Cannot-find-a-valid-baseurl-for-repo-base"><a href="#1、yum-下载软件包出错-Error-Cannot-find-a-valid-baseurl-for-repo-base" class="headerlink" title="1、yum 下载软件包出错 Error: Cannot find a valid baseurl for repo: base"></a>1、yum 下载软件包出错 Error: Cannot find a valid baseurl for repo: base</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y epel-release</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">YumRepo Error: All mirror URLs are not using ftp, http[s] or file.</span><br><span class="line"> Eg. Invalid release&#x2F;repo&#x2F;arch combination&#x2F;</span><br><span class="line">removing mirrorlist with no valid mirrors: &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;6&#x2F;base&#x2F;mirrorlist.txt</span><br><span class="line">Error: Cannot find a valid baseurl for repo: base</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：修改 yum 源，更换成国内源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.bak</span><br><span class="line">curl http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS5-Base-163.repo -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>使用 yum 再次安装又出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y epel-release</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">http:&#x2F;&#x2F;mirrors.163.com&#x2F;centos&#x2F;6&#x2F;addons&#x2F;x86_64&#x2F;repodata&#x2F;repomd.xml: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 404 Not Found&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: addons. Please verify its path and try again</span><br></pre></td></tr></table></figure><p>再次搜索之后，发现可以使用 <strong>vault.centos.org</strong> 作为更新源</p><p><strong>具体操作步骤：</strong></p><ol><li><p>关闭 fastestmirror</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;yum&#x2F;pluginconf.d&#x2F;fastestmirror.conf</span><br><span class="line">#修改参数</span><br><span class="line">enable&#x3D;0</span><br></pre></td></tr></table></figure></li><li><p>备份原来的源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mv &#x2F;etc&#x2F;yum.repo.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repo.d&#x2F;CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure></li><li><p>更换 yum 源</p><ul><li><p>阿里云 Vault 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;www.xmpan.com&#x2F;Centos-6-Vault-Aliyun.repo </span><br><span class="line"></span><br><span class="line"># wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;static.lty.fun&#x2F;%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90&#x2F;SourcesList&#x2F;Centos-6-Vault-Aliyun.repo</span><br></pre></td></tr></table></figure><blockquote><p>我的虚机上面没有 wget 命令，所以用 curl 命令来下载文件。</p></blockquote></li><li><p>官方 Vault 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;static.lty.fun&#x2F;%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90&#x2F;SourcesList&#x2F;Centos-6-Vault-Official.repo</span><br></pre></td></tr></table></figure></li></ul></li><li><p>清理并构建缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum repolist</span><br></pre></td></tr></table></figure><p>再次使用 yum 安装软件，成功。</p></li></ol><hr><h5 id="2、安装-EPEL-源后，使用报错"><a href="#2、安装-EPEL-源后，使用报错" class="headerlink" title="2、安装 EPEL 源后，使用报错"></a>2、安装 EPEL 源后，使用报错</h5><p>具体错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># yum install cloud-init</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: epel. Please verify its path and try again</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong>修改 /etc/yum.repo.d/epel.repo，将 mirrorlist=<a href="https://xxxx/">https://xxxx</a> 修改为 http，即可正常使用。</p><hr><h5 id="3、curl-35-SSL-connect-error-问题处理"><a href="#3、curl-35-SSL-connect-error-问题处理" class="headerlink" title="3、curl: (35) SSL connect error 问题处理"></a>3、curl: (35) SSL connect error 问题处理</h5><p>下载 get-pip.py 脚本出现下面错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># curl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py -o get-pip.py</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:--  0:00:03 --:--:--     0</span><br><span class="line">curl: (35) SSL connect error</span><br></pre></td></tr></table></figure><p>解决方法：无法在服务器使用 curl 命令访问 https 域名，原因是 nss 版本有点旧了，<code>yum -y update nss</code> 更新一下，重新 curl 即可！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update nss</span><br></pre></td></tr></table></figure><hr><h5 id="4、更换-pip-源"><a href="#4、更换-pip-源" class="headerlink" title="4、更换 pip 源"></a>4、更换 pip 源</h5><p>在 <code>~/.pip/pip.conf</code> 文件中添加或修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># mkdir ~&#x2F;.pip</span><br><span class="line"># cat ~&#x2F;.pip&#x2F;pip.conf</span><br><span class="line">[global]</span><br><span class="line">index-url &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前有个 CentOS6.x 的系统镜像，默认支持 cloud-init-0.7.5 版本 rpm，但是 cloud-init-0.7.5 无法通过本地化 QEMU 利用 NoCloud 数据源进行 IP 地址管理，因此无法实现虚机的网络初始化，需要手动进行配置。经过测试实验，cloud-init 17 以上版本能够支持 NoCloud 数据源信息注入，但是 cloud-init 17 及以上版本需要 python2.7 或者 python3 才能运行，而 CentOS6.x 系统默认使用 python2.6。因此为了在 CentOS6.x 上安装 cloud-init 17 以上的版本，需要先升级 python2.7，然后再安装 cloud-init。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://caohuilong.github.io/categories/Linux/"/>
    
    
    <category term="CentOS" scheme="http://caohuilong.github.io/tags/CentOS/"/>
    
    <category term="Cloud-init" scheme="http://caohuilong.github.io/tags/Cloud-init/"/>
    
    <category term="镜像" scheme="http://caohuilong.github.io/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubeadm快速部署kubernetes</title>
    <link href="http://caohuilong.github.io/2020/10/21/Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/"/>
    <id>http://caohuilong.github.io/2020/10/21/Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/</id>
    <published>2020-10-20T16:48:19.000Z</published>
    <updated>2020-10-20T16:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于kubeadm快速部署一套Kubernetes集群用于个人学习和测试，针对国内网络环境选择合适的镜像源，减少镜像下载时间，并安装calico网络插件。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本次环境由两台虚拟机来部署，安装CentOS7.6系统：</p><table><thead><tr><th align="center">主机名</th><th align="center">IP</th></tr></thead><tbody><tr><td align="center">master</td><td align="center">10.0.0.3</td></tr><tr><td align="center">node1</td><td align="center">10.0.0.4</td></tr></tbody></table><h3 id="配置hostname与host"><a href="#配置hostname与host" class="headerlink" title="配置hostname与host"></a>配置hostname与host</h3><p>分别在两台主机上执行命令，修改主机名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.3节点</span></span><br><span class="line">hostnamectl set-hostname master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.4节点</span></span><br><span class="line">hostnamectl set-hostname node1</span><br></pre></td></tr></table></figure><blockquote><p>hostnamectl 命令会替换<code>/etc/hostname</code>文件中的主机名，保证重启后主机名还是生效；</p><p>hostname 命令可以临时修改主机名，重启后失效。</p></blockquote><p>两台机器都要配置host，允许主机通过主机名直接通信，<code>/etc/hosts</code>文件添加一下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.3 master</span><br><span class="line">10.0.0.4 node1</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config  # 永久 需重启</span><br><span class="line">setenforce 0   # 临时</span><br></pre></td></tr></table></figure><h3 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;s/^[^#].*swap/#&amp;/&#x27; /etc/fstab</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>若要启用swap设备，则需要在集群初始化时添加 <code>--ignore-preflight-errors=swap</code>，可忽略因swap设备导致的报错。</p><h3 id="关闭ipv6"><a href="#关闭ipv6" class="headerlink" title="关闭ipv6"></a>关闭ipv6</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo net.ipv6.conf.all.disable_ipv6=1 &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo NETWORKING_IPV6=no &gt;&gt; /etc/sysconfig/network</span><br><span class="line">sed -i &#x27;s/IPV6INIT=yes/IPV6INIT=no/g&#x27; /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">sysctl -p</span><br><span class="line">ip a             # 查看ipv6是否关闭</span><br></pre></td></tr></table></figure><h3 id="将桥接的ipv4流量传递到iptables"><a href="#将桥接的ipv4流量传递到iptables" class="headerlink" title="将桥接的ipv4流量传递到iptables"></a>将桥接的ipv4流量传递到iptables</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/sysctl.d/kubernetes.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables =1</span><br><span class="line">net.bridge.bridge-nf-call-iptables =1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl --system  # 生效</span><br></pre></td></tr></table></figure><blockquote><p>这个不知道什么意思但是通过Kubeadm安装Kubenetes集群时会校验。这里也搜到<a href="https://www.joeys.top/2021/01/iptable-net-bridge-bridge-nf-call-iptables%E7%9A%84%E4%BD%9C%E7%94%A8/">一篇文章</a>说明<code>net.bridge.bridge-nf-call-iptables的作用</code>参数作用，不明所以。</p></blockquote><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>容器运行时是运行容器的基础，有多种可选的容器运行时，这里选择kubernetes默认的Docker。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 yum-utils</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 yum 源为阿里云方便下载 Docker Engine</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装最新版的docker，不同版本的k8s适配的docker版本不同，所以可能需要指定docker版本</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取docker版本列表</span></span><br><span class="line">sudo yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装指定版本的docker</span></span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="line">sudo yum install docker-ce-19.03.9-3.el7 docker-ce-cli-19.03.9-3.el7 containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动</span></span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p><strong>并且配置Docker的Cgroup Driver为systemd：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ul><li><p>什么是cgroups?</p><p>首先说下容器是什么？容器是一个视图隔离、资源可限制、独立文件系统的进程集合。cgroups(Control Groups) 是 linux 内核提供的一种机制，作用就是可以对资源进行限制。此外，视图隔离是通过namespace实现，而文件系统是通过chroot实现。</p></li><li><p>为什么要修改Cgroup Driver？</p><p>Docker默认的Cgroup Driver是cgroupfs，而Kubernetes 推荐使用 systemd 来代替 cgroupfs。如果不修改，那么同时运行有两个cgroup控制管理器，当资源有压力的情况时，有可能出现不稳定的情况。并且在kubeadm init时也会出现警告。</p></li></ul><h3 id="master节点配置免密登录node节点"><a href="#master节点配置免密登录node节点" class="headerlink" title="master节点配置免密登录node节点"></a>master节点配置免密登录node节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa # 一路默认回车即可</span><br><span class="line">ssh-copy-id master   # 过程中需要输入密码</span><br><span class="line">ssh-copy-id node1</span><br><span class="line"></span><br><span class="line">ssh root@node1   # 测试是否成功</span><br></pre></td></tr></table></figure><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h3 id="安装kubeadm、kubelet、kubectl"><a href="#安装kubeadm、kubelet、kubectl" class="headerlink" title="安装kubeadm、kubelet、kubectl"></a>安装kubeadm、kubelet、kubectl</h3><p>以下操作在所有节点进行</p><ul><li><p>添加阿里云YUM源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>指定版本安装软件，这里安装1.19.8版本，1.20不再把Docker作为默认的容器运行时，所以这里选择1.19版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet-1.19.8 kubeadm-1.19.8 kubectl-1.19.8</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure><h3 id="Master节点安装"><a href="#Master节点安装" class="headerlink" title="Master节点安装"></a>Master节点安装</h3></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=1.19.8 --image-repository=registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure><p>安装成功之后，按照提示执行下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>同时要记住打印出的下列命令，用于添加Node节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 10.0.0.3:6443 --token j91yvn.qvhw9t0n0nvjd9j7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:68f5132eed6c9a9f1dc59cd304220542e4635dbf629cc789d0d0e0b91bb909cd</span><br></pre></td></tr></table></figure><p>若没注意，可通过<code>kubeadm token list</code>查看当前的token，默认有效期为24小时，若忘记token或token过期，可使用命令<code>kubeadm token create --print-join-command</code>重新生成，若初始有问题可通过命令<code>kubeadm reset</code>重置。</p><p>启动kubelet：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet</span><br></pre></td></tr></table></figure><h3 id="Node节点安装"><a href="#Node节点安装" class="headerlink" title="Node节点安装"></a>Node节点安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet</span><br><span class="line"></span><br><span class="line">kubeadm join 10.0.0.3:6443 --token j91yvn.qvhw9t0n0nvjd9j7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:68f5132eed6c9a9f1dc59cd304220542e4635dbf629cc789d0d0e0b91bb909cd</span><br></pre></td></tr></table></figure><h3 id="安装calico"><a href="#安装calico" class="headerlink" title="安装calico"></a>安装calico</h3><p>master与node节点安装好之后，获取一下节点信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/nodes_not_ready.png" alt="node notReady"></p><p>可以看到master节点与node1节点都处于NotReady状态。查看kubelet的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/systemctl_status_kubelet.png" alt="systemctl status kubelet"></p><p> <code>No networks found in /etc/cni/net.d</code> 这行错误信息表示节点没有CNI网络插件，这是因为kubeadm目标是在不安装其他功能插件的基础上，建立一个通过Kubernetes一致性测试Kubernetes Conformance tests的最小可行集群。它在设计上并不会安装网络解决方案，而是需要用户自行安装第三方符合CNI的网络解决方案（如：flannel，calico，weave network等）。</p><p>fannel和calico算是目前网络实现最热门的2个插件，经过简单的对比，calico在性能更好以外，还可以与服务网格 Istio 集成，所以毫不犹豫的选择calico。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -o calico.yaml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f calico.yaml </span><br></pre></td></tr></table></figure><p>安装好calico相关组件之后，再次查看节点状态变为Ready：</p><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/nodes_ready.png" alt="node ready"></p><p>再查看基础应用：</p><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/pods.png" alt="system pod"></p><p>到此，一个kubenetes集群就搭建完毕，可以在该集群上创建deployment部署应用，创建service暴露服务了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文基于kubeadm快速部署一套Kubernetes集群用于个人学习和测试，针对国内网络环境选择合适的镜像源，减少镜像下载时间，并安装calico网络插件。&lt;/p&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="http://caohuilong.github.io/categories/Kubernetes/"/>
    
    
    <category term="kubeadm" scheme="http://caohuilong.github.io/tags/kubeadm/"/>
    
  </entry>
  
  <entry>
    <title>Rancher部署k8s</title>
    <link href="http://caohuilong.github.io/2020/10/01/Rancher%E9%83%A8%E7%BD%B2k8s/"/>
    <id>http://caohuilong.github.io/2020/10/01/Rancher%E9%83%A8%E7%BD%B2k8s/</id>
    <published>2020-10-01T15:07:33.000Z</published>
    <updated>2020-10-01T15:07:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rancher是一个开源的企业级容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。本文记录Rancher部署k8s的过程。</p><a id="more"></a><h3 id="1-基本环境"><a href="#1-基本环境" class="headerlink" title="1. 基本环境"></a>1. 基本环境</h3><p>本文基于Ubuntu 16.04部署 Rancher，首先需要安装好 Docker。</p><blockquote><p>刚开始部署 Rancher 时，因为 Ubuntu 20.04 已经更新很久了都没有使用过，所以就尝试了用 Ubuntu 20.04来部署。但是在部署过程中一直不成功，仔细检查了一下才发现 Docker 针对 Ubuntu 20.04 只提供了 Docker 19.0.x 版本，官方下载链接中不支持其他的低版本。最后只能选择 Ubuntu 16.04 来部署（至于如何在 Ubuntu 20.04 上安装更低版本的后面再尝试了）。</p></blockquote><p>支持的Docker版本:</p><ul><li>17.03.x</li><li>18.06.x</li><li>18.09.x</li></ul><p><strong>安装 Docker 首先设置存储库：</strong></p><ol><li><p>更新<code>apt</code>软件包索引并安装软件包以允许<code>apt</code>通过HTTPS使用存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加Docker的官方GPG密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>使用以下命令来设置<strong>稳定的</strong>存储库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure></li></ol><p><strong>安装DOCKER引擎：</strong></p><ol><li><p>要安装<em>特定版本</em>的 Docker Engine，请在存储库中列出可用版本，然后选择并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br><span class="line">  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.1~ce~3-0~ubuntu       | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.0~ce~3-0~ubuntu       | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br></pre></td></tr></table></figure></li><li><p>更新<code>apt</code>程序包索引，并安装指定版本的Docker Engine和容器，或转到下一步以安装特定版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"> $ sudo apt-get install docker-ce&#x3D;5:18.09.1~3-0~ubuntu-xenial docker-ce-cli&#x3D;5:18.09.1~3-0~ubuntu-xenial containerd.io</span><br></pre></td></tr></table></figure></li><li><p>将当前用户加入 docker 用户组，下次登陆后执行 docker 命令可不加 sudo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="2-安装Rancher"><a href="#2-安装Rancher" class="headerlink" title="2. 安装Rancher"></a>2. 安装Rancher</h3><p>执行以下命令安装 Rancher server：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --restart&#x3D;unless-stopped -v &lt;主机路径&gt;:&#x2F;var&#x2F;lib&#x2F;rancher&#x2F; -p 80:80 -p 443:443 rancher&#x2F;rancher:stable</span><br></pre></td></tr></table></figure><hr><h3 id="3-登录Rancher，并创建集群"><a href="#3-登录Rancher，并创建集群" class="headerlink" title="3. 登录Rancher，并创建集群"></a>3. 登录Rancher，并创建集群</h3><p>稍等片刻之后，可以使用主机的 IP 在浏览器中登录 Rancher UI，并创建集群。参考链接：<a href="https://docs.rancher.cn/rancher2x/quick-start.html#_4-%E7%99%BB%E5%BD%95rancher">登录Rancher</a>。</p><hr><h3 id="4-复制向集群添加主机"><a href="#4-复制向集群添加主机" class="headerlink" title="4. 复制向集群添加主机"></a>4. 复制向集群添加主机</h3><p>接着在前端界面的主机角色选项中勾选 <code>etcd</code> 以及 <code>Control</code>，然后复制添加主机的命令到对应的主机中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --privileged --restart&#x3D;unless-stopped --net&#x3D;host -v &#x2F;etc&#x2F;kubernetes:&#x2F;etc&#x2F;kubernetes -v &#x2F;var&#x2F;run:&#x2F;var&#x2F;run rancher&#x2F;rancher-agent:v2.4.5 --server https:&#x2F;&#x2F;192.168.184.129 --token hhkvrndn7lktsmz6fxnjw9jltppq5w6ttt466rbmzsr7pwxktjq6hr --ca-checksum fc92e9aa8d072c2e2731a34d9242bb71e8abcee3b059c6c6bcddd685acbd16b1 --etcd --controlplane --worker</span><br></pre></td></tr></table></figure><p>这个过程中需要下载较多 docker 容器镜像，需要等待较长时间。</p><hr><h3 id="5-部署工作负载"><a href="#5-部署工作负载" class="headerlink" title="5. 部署工作负载"></a>5. 部署工作负载</h3><p>这个也可以参考链接：<a href="https://docs.rancher.cn/rancher2x/quick-start.html#_6-%E9%83%A8%E7%BD%B2%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD">部署工作负载</a>，这里就不截图展示了。</p><hr><h3 id="6-删除-Rancher"><a href="#6-删除-Rancher" class="headerlink" title="6. 删除 Rancher"></a>6. 删除 Rancher</h3><p>可使用一下脚本删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">docker rm -f $(sudo docker ps -aq);</span><br><span class="line">docker volume rm $(sudo docker volume ls -q);</span><br><span class="line"></span><br><span class="line">rm -rf /etc/ceph \</span><br><span class="line">       /etc/cni \</span><br><span class="line">       /etc/kubernetes \</span><br><span class="line">       /opt/cni \</span><br><span class="line">       /opt/rke \</span><br><span class="line">       /run/secrets/kubernetes.io \</span><br><span class="line">       /run/calico \</span><br><span class="line">       /run/flannel \</span><br><span class="line">       /var/lib/calico \</span><br><span class="line">       /var/lib/etcd \</span><br><span class="line">       /var/lib/cni \</span><br><span class="line">       /var/lib/kubelet \</span><br><span class="line">       /var/lib/rancher/rke/<span class="built_in">log</span> \</span><br><span class="line">       /var/<span class="built_in">log</span>/containers \</span><br><span class="line">       /var/<span class="built_in">log</span>/pods \</span><br><span class="line">       /var/run/calico</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> mount <span class="keyword">in</span> $(mount | grep tmpfs | grep <span class="string">&#x27;/var/lib/kubelet&#x27;</span> | awk <span class="string">&#x27;&#123; print $3 &#125;&#x27;</span>) /var/lib/kubelet /var/lib/rancher; <span class="keyword">do</span> umount <span class="variable">$mount</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">rm -f /var/lib/containerd/io.containerd.metadata.v1.bolt/meta.db</span><br><span class="line">sudo systemctl restart containerd</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">IPTABLES=<span class="string">&quot;/sbin/iptables&quot;</span></span><br><span class="line">cat /proc/net/ip_tables_names | <span class="keyword">while</span> <span class="built_in">read</span> table; <span class="keyword">do</span></span><br><span class="line">  <span class="variable">$IPTABLES</span> -t <span class="variable">$table</span> -L -n | <span class="keyword">while</span> <span class="built_in">read</span> c chain rest; <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;X<span class="variable">$c</span>&quot;</span> = <span class="string">&quot;XChain&quot;</span> ; <span class="keyword">then</span></span><br><span class="line">        <span class="variable">$IPTABLES</span> -t <span class="variable">$table</span> -F <span class="variable">$chain</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="variable">$IPTABLES</span> -t <span class="variable">$table</span> -X</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>不仅要删除相关的容器，还需要删除对应的 docker volume，以及其他的一些配置，最后重启主机，之后才能重新运行新的 Rancher 平台。</p><hr><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>在我多次尝试之后，发现 Docker 是关键，包括 Docker 的版本以及对应的镜像源，都对 Rancher 的成功部署有重要的影响。</p><p>在基本的 Docker 环境没有问题之后，用过 Rancher 来管理 Kubernetes 真的是太简单了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rancher是一个开源的企业级容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。本文记录Rancher部署k8s的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="http://caohuilong.github.io/categories/Kubernetes/"/>
    
    
    <category term="Rancher" scheme="http://caohuilong.github.io/tags/Rancher/"/>
    
  </entry>
  
  <entry>
    <title>数据库锁</title>
    <link href="http://caohuilong.github.io/2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    <id>http://caohuilong.github.io/2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</id>
    <published>2020-09-14T12:23:31.000Z</published>
    <updated>2020-09-14T12:23:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。本文记录在学习数据库锁过程中的关键概念以及一些个人的理解。</p><a id="more"></a><h5 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h5><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）——DML（Data Manipulate Language）、数据定义语句（包括建表、修改表结构等）——DDL（Data Definition Language）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都 select 出来存成文本。但是在备份过程中整个库完全处于只读状态，如果在主库上面备份，那么在备份期间都不能执行更新，业务基本停摆；如果在从库备份，那么备份期间不能执行从主库同步过来的binlog，会导致主从延迟。</p><p>所以更好的备份方法是在可重复读隔离级别下开启一个事务，在整个备份过程中，都能拿到一致性视图，并且数据可以正常更新。但是可重复读隔离级别需要引擎支持才能使用，对于MyISAM等不支持事务的引擎，只能使用FTWRL全局锁的方式备份。<!--这也是使用 InnoDB 替代 MyISAM 的原因之一-->。</p><p>还有另一种方法实现全库只读——<code>set global readonly=true</code>，但是相比之下，还是推荐用FTWRL方式，原因如下：</p><ul><li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。</li><li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><h5 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h5><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><ul><li><strong>表锁</strong>的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li><li><strong>元数据锁 MDL</strong>（metadata lock)不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。<ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul></li></ul><h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，<!--这也是 MyISAM 被 InnoDB 替代的重要原因之一-->。</p><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是<strong>两阶段锁协议</strong>。如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。当出现死锁以后，有两种解决策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。默认是50s，当出现死锁时，第一个被锁住的线程需要过50s才会超时退出，然后其他线程才有可能继续执行，这个时间对于在线业务是无法接受的。但是如果把这个时间设置成一个很小的时间，比如1s，会导致普通的锁等待也超时退出，造成误伤。1</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁，这是一个时间复杂度为O(n)的操作。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。本文记录在学习数据库锁过程中的关键概念以及一些个人的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>B+树与索引</title>
    <link href="http://caohuilong.github.io/2020/09/01/B+%E6%A0%91%E4%B8%8E%E7%B4%A2%E5%BC%95/"/>
    <id>http://caohuilong.github.io/2020/09/01/B+%E6%A0%91%E4%B8%8E%E7%B4%A2%E5%BC%95/</id>
    <published>2020-09-01T12:19:04.000Z</published>
    <updated>2020-09-01T12:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="B-树与数据库索引"><a href="#B-树与数据库索引" class="headerlink" title="B+树与数据库索引"></a>B+树与数据库索引</h4><p>MySQL InnoDB引擎中，使用了B+树的索引模型，数据都是存储在B+树中的，每一个索引在InnoDB中都是一棵B+树。本文首先介绍B+树的概念，然后介绍MySQL的索引。</p><a id="more"></a><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>数据库引擎有很多可用的数据结构，如哈希表、有序数组、二叉树搜索树。</p><ul><li>哈希表：键值对，把值放在数组中，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置，如果有哈希冲突，其中一种解决方法是链表。哈希表只适用于等值查询的场景。</li><li>有序数组：按顺序存储，查询用二分法可以快速查询，但是更新效率低，只适用于静态存储引擎。</li><li>二叉树搜索树：每个节点的左儿子小于父节点，父节点小于右儿子，查询和更新时间复杂度都是O(logN)。</li></ul><p>在上述三种数据结构中，只有二叉搜索树能够适用的场景更多，但是直接通过二叉搜索树也不太适合数据库存储，因为二叉搜索树的树高太高，而每一层的数据不太可能存在连续的数据块中，因此一次查询需要访问的数据块太多，尤其是在数据库可能存在磁盘中，速度就更慢了，所以一般都采用“N叉”树。InnoDB采用的是B+树结构，因为B+树能够很好地配合磁盘的读写特性，减少单词查询的磁盘访问次数。</p><p>B+树的查询效率更加稳定：由于非终节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><p>数据库索引用于提高数据查询效率，索引类型分为主键索引和非主键索引（普通索引）：</p><ul><li><p><strong>主键索引</strong>的叶子节点存的是整行数据；</p></li><li><p><strong>非主键索引</strong>的叶子节点内容是主键的值，所以非主键索引也被称为二级索引，通过普通索引查询时，需要先搜索非主键索引树，找到主键，然后再到主键索引树中再搜索一次，这个过程称为回表。基于非主键索引的查询需要多扫描一棵索引树，因此在应用中应该尽量使用主键索引。如果不通过索引来查询，就是遍历主键索引树，因此效率是最低的。</p></li></ul><p>优化数据库索引的一些方法：</p><ul><li>覆盖索引：假设有一张表，主键是ID，还有一个字段k，并且对k建立了一个非主键索引，在执行<code>select ID from T where k between 3 and 5</code>语句时，因为只需要查询主键ID的值，而主键ID是非主键索引k的叶子节点的值，因此索引k已经“覆盖了”我们的查询需求，不需要回表过程，这就被称为覆盖索引。</li><li>前缀索引：B+树这种索引结构，可以利用索引的“最左前缀”来定位记录。对于联合索引的最左N个字段或者字符串索引最左M个字符，都可以利用索引来加速检索。</li><li>索引下推：索引下推指的是可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;B-树与数据库索引&quot;&gt;&lt;a href=&quot;#B-树与数据库索引&quot; class=&quot;headerlink&quot; title=&quot;B+树与数据库索引&quot;&gt;&lt;/a&gt;B+树与数据库索引&lt;/h4&gt;&lt;p&gt;MySQL InnoDB引擎中，使用了B+树的索引模型，数据都是存储在B+树中的，每一个索引在InnoDB中都是一棵B+树。本文首先介绍B+树的概念，然后介绍MySQL的索引。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="http://caohuilong.github.io/2020/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>http://caohuilong.github.io/2020/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-08-18T08:10:05.000Z</published>
    <updated>2020-08-18T08:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录在学习数据库事务中的一些关键概念，包括事务的ACID特性、多事务同时执行可能存在的问题、事务的隔离级别，最后对数据库的长连接与长事务做了一个对比。</p><a id="more"></a><h5 id="事务的ACID特性："><a href="#事务的ACID特性：" class="headerlink" title="事务的ACID特性："></a>事务的ACID特性：</h5><ul><li>原子性（Atomicity）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读、提交读、可重复读和串行化。</li><li>持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h5 id="多事务同时执行可能存在的问题："><a href="#多事务同时执行可能存在的问题：" class="headerlink" title="多事务同时执行可能存在的问题："></a>多事务同时执行可能存在的问题：</h5><ul><li>脏读（dirty read）：读到其他事务未提交的数据。</li><li>不可重复读（non-repeatable read）：前后读取的记录内容不一致。</li><li>幻读（phantom read）：前后读取的记录数量不一致。</li></ul><h5 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h5><ul><li>读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化（serializable）：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h5 id="长连接与长事务"><a href="#长连接与长事务" class="headerlink" title="长连接与长事务"></a>长连接与长事务</h5><ul><li><p>长连接：是指连接数据库成功后，如果客户端持续有请求，则一直使用同一个连接。对应的短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，<strong>也就是尽量使用长连接</strong>。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p></li><li><p>长事务：一直不提交的事务，就是长事务。<strong>尽量不要使用长事务</strong>，因为长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录在学习数据库事务中的一些关键概念，包括事务的ACID特性、多事务同时执行可能存在的问题、事务的隔离级别，最后对数据库的长连接与长事务做了一个对比。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>redo log与bin log的个人理解</title>
    <link href="http://caohuilong.github.io/2020/08/06/redo%20log%E4%B8%8Ebin%20log%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://caohuilong.github.io/2020/08/06/redo%20log%E4%B8%8Ebin%20log%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</id>
    <published>2020-08-05T17:08:45.000Z</published>
    <updated>2020-08-05T17:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据库的更新流程涉及两个重要的日志模块：redo log与bin log，本文记录一下在学习丁奇大佬的《MySQL实战45讲》过程中我个人的一些理解，如有不对的地方，欢迎指正。</p><a id="more"></a><h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><ul><li><p><strong>特点：</strong>InnoDB引擎所特有的；是物理日志，记录的是数据“做了什么改动”；redo log循环写，空间固定，会用完。</p></li><li><p><strong>作用：</strong>用于保证数据库发生异常重启恢复数据，之前提交的记录都不会丢失，也就是 <strong>crash-safe</strong>。</p></li><li><p><strong>理解：</strong>数据库更新的部分数据可以暂时保存在内存中，并不是立马写到磁盘中，这样可以减少读写磁盘的次数。但是保存在内存中的数据可能会因为数据库出现异常重启的情况而导致数据丢失，无法从磁盘中的数据恢复最新的数据。有了redo log之后可以解决这个问题，每次更新完数据之前，会在redo log文件中记录数据的变更操作，这样在数据库异常重启之后，会根据磁盘中的数据以及redo log，恢复最新的数据。</p></li></ul><h5 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h5><ul><li><strong>特点：</strong>MySQL server层实现的日志，所有存储引擎插件都可以使用；是逻辑日志，记录的是这个语句的原始逻辑（有两种模式，statement格式记录sql语句，row格式会记录行的内容，记两条，更新前与更新后都有）；bin log可以追加写，文件写到一定大小会写到下一个文件，不会覆盖以前的日志。</li><li><strong>作用：</strong>将数据库rollback至某个操作或者某个时间点之前的状态，或者用于备份数据。</li><li><strong>理解：</strong>无法通过redo log来实现这个rollback操作，因为redo log记录的是内存数据与磁盘数据的变化，就算要通过redo log来rollback，那也只能将最新的数据库回滚到内存中某个时间点的状态，而无法回滚到磁盘中数据的某个时间点。但是通过bin log可以实现这种回滚需求，假设需要回滚至某个删表操作之前的状态，只需要从删除操作之前最近的一个数据备份开始，重新执行bin log中从数据备份开始至删除操作之前的bin log即可。</li></ul><blockquote><p>通过对redo log与bin log的介绍与理解，可知二者作用不同，需同时存在才能实现数据库的某些可用性与可靠性。但是二者之间必须按照某个特定的逻辑顺序来处理才能处理一些出现错误的场景，也就是redo log的两阶段提交，先执行写redo log的prepare阶段，然后执行写bin log，最后执行写redo log的commit阶段，如果中间有某个阶段出错，都会让redo log、bin log回滚。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL数据库的更新流程涉及两个重要的日志模块：redo log与bin log，本文记录一下在学习丁奇大佬的《MySQL实战45讲》过程中我个人的一些理解，如有不对的地方，欢迎指正。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>二分查找算法总结</title>
    <link href="http://caohuilong.github.io/2019/04/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://caohuilong.github.io/2019/04/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-04-01T05:51:32.000Z</published>
    <updated>2019-04-01T05:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找或二分搜索（binary search），是一种在有序数组中查找某一特定元素的搜索算法。必须满足以下特征：</p><ul><li>存储在数组中</li><li>有序排列</li></ul><blockquote><p>如果是用链表存储的，就无法应用二分查找了，因为链表不能通过下标随机访问其元素。</p></blockquote><p>本文介绍基本的二分查找及其各种变体。</p><a id="more"></a><h4 id="1-基本二分查找"><a href="#1-基本二分查找" class="headerlink" title="1.基本二分查找"></a>1.基本二分查找</h4><p>基本二分查找的搜索过程是从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果中间元素大于目标值，则在数组小于中间元素的那一半中查找；如果中间元素小于目标值，则在数组大于中间元素的那一半查找。如果在某一步数组为空，则代表找不到。二分查找算法每一次比较都会使搜索范围缩小一半。</p><p>基本二分查找的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">basic_binary_search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//target在左边，改右边界</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//target在右边，改左边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-各种变体"><a href="#2-各种变体" class="headerlink" title="2. 各种变体"></a>2. 各种变体</h4><p>二分查找除了基本的查找某个元素的位置之外，还有很多的变体。比如查找第一个大于target的元素位置，这经常用于寻找要插入的位置；反过来，也会查找第一个比target小的元素的位置。有时也会查找某个元素在数组中的上下界，也就是查找不大于target的最后一个元素的位置或是查找不小于target的第一个元素的位置。最后还会出现数组中有多个target元素时，需要查找第一次或最后一次出现target元素的位置。</p><p>因此，如下分成了六种变体，在编写相应的二分查找算法的代码时，需要注意的就是判断条件以及返回值的问题。不多说，先看代码：</p><h5 id="变体1：查找第一个大于target的元素位置"><a href="#变体1：查找第一个大于target的元素位置" class="headerlink" title="变体1：查找第一个大于target的元素位置"></a>变体1：查找第一个大于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_greater</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size())</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体2：查找最后一个小于target的元素位置"><a href="#变体2：查找最后一个小于target的元素位置" class="headerlink" title="变体2：查找最后一个小于target的元素位置"></a>变体2：查找最后一个小于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_less</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与标准库中 upper_bound 函数功能一致。</p></blockquote><hr><h5 id="变体3：查找第一个大于等于target的元素位置"><a href="#变体3：查找第一个大于等于target的元素位置" class="headerlink" title="变体3：查找第一个大于等于target的元素位置"></a>变体3：查找第一个大于等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_greater_equal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size())</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与标准库中 lower_bound 函数的功能是一样的。</p></blockquote><hr><h5 id="变体4：查找最后一个小于等于target的元素位置"><a href="#变体4：查找最后一个小于等于target的元素位置" class="headerlink" title="变体4：查找最后一个小于等于target的元素位置"></a>变体4：查找最后一个小于等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_less_equal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体5：查找第一个等于target的元素位置"><a href="#变体5：查找第一个等于target的元素位置" class="headerlink" title="变体5：查找第一个等于target的元素位置"></a>变体5：查找第一个等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_first</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size() &amp;&amp; nums[left] == target)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体6：查找最后一个等于target的元素位置"><a href="#变体6：查找最后一个等于target的元素位置" class="headerlink" title="变体6：查找最后一个等于target的元素位置"></a>变体6：查找最后一个等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_last</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == target)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>看以上循环部分的代码都有一种结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">    mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (target ➀ nums[mid])</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ➁;</span><br></pre></td></tr></table></figure><p>不同的地方有两个：</p><ul><li><p>循环体内部的判断条件：<code>if (target ➀ nums[mid])</code></p><p>➀所在的位置的比较符号是 &lt; 或 &lt;= 。不存在大于或大于等于的情况。</p></li><li><p>返回值：<code>return ➁;</code></p><p>➁所在位置返回值是 left 或 right。</p></li></ul><blockquote><p>循环的终止条件都是 left &gt; right。</p></blockquote><p>不同变体的情况下，➀➁处的取值如下表：</p><table><thead><tr><th align="center">变体</th><th align="center">➀</th><th align="center">➁</th></tr></thead><tbody><tr><td align="center">查找<strong>第一个大于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个小于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">right</td></tr><tr><td align="center">查找<strong>第一个大于等于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个小于等于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">right</td></tr><tr><td align="center">查找<strong>第一个等于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个等于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">right</td></tr></tbody></table><p>根据上表，再根据问题的一些特点可以得出以下一些规律：</p><ul><li>查找第一个（大于、大于等于、等于）target的元素位置，也就是找左边界，返回 left。</li><li>查找最后一个（小于、小于等于、等于）target的元素位置，也就是找右边界，返回 right。</li></ul><blockquote><p>另外，其实变体 5、6 在元素存在于数组中时，与变体3、4是一样的解法。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找或二分搜索（binary search），是一种在有序数组中查找某一特定元素的搜索算法。必须满足以下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储在数组中&lt;/li&gt;
&lt;li&gt;有序排列&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果是用链表存储的，就无法应用二分查找了，因为链表不能通过下标随机访问其元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文介绍基本的二分查找及其各种变体。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://caohuilong.github.io/categories/algorithm/"/>
    
    
    <category term="二分查找" scheme="http://caohuilong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找数组中重复的元素</title>
    <link href="http://caohuilong.github.io/2019/03/20/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://caohuilong.github.io/2019/03/20/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2019-03-20T14:27:28.000Z</published>
    <updated>2019-03-20T14:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>查找数组中重复的元素：在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。</p><a id="more"></a><h2 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h2><h4 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h4><p>最简单的方法就是用一个集合 set，遍历数组的每一个元素，在 set 中查找是否存在该元素，如果存在则返回；不存在则放入集合，并继续循环。</p><p>复杂度：</p><ul><li>空间复杂度为：<code>O(N)</code></li><li>时间复杂度为：<code>O(NlogN)</code> （遍历数组为 <code>O(N)</code>，set 中查找为 <code>O(logN)</code>）</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> n, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; Set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Set.find(numbers[i]) != Set.end())&#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set.insert(numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="改进：使用hash表"><a href="#改进：使用hash表" class="headerlink" title="改进：使用hash表"></a>改进：使用hash表</h4><p>使用一个长度为 n 的数组来作为 hash 表，初始化为 0。然后遍历数组，利用数组元素作为 hash 表的索引，如果其对应的值为 1，说明是第二次访问该索引，那么该索引就是原数组中重复的元素；如果其对应的值为 0，说明是第一次访问，设置为 1。</p><p>复杂度：</p><ul><li>空间复杂度为：<code>O(N)</code></li><li>时间复杂度为：<code>O(N)</code> </li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_table[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_table[numbers[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hash_table[numbers[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="常数空间"><a href="#常数空间" class="headerlink" title="常数空间"></a>常数空间</h4><p>上面的方法都会使用 O(N) 的内存空间，如果只能使用 O(1) 的空间，那么可以考虑下面的方法。</p><p>一种类似于基数排序的方法：</p><p>索引 i 从 0 开始遍历数组，</p><ul><li>如果 i == numbers[i]，说明 numbers[i] 在正确的位置上；</li><li>如果 i != numbers[i]，<ul><li>如果 numbers[i] != numbers[numbers[i]]，交换 numbers[i] 和 numbers[numbers[i]]，那么 numbers[numbers[i]] 将会在正确的位置上。</li><li>否则 numbers[i] == numbers[numbers[i]]，那么就找到了 numbers[i]。</li></ul></li></ul><p>复杂度：</p><ul><li>空间复杂度：O(1)</li><li>时间复杂度：O(N)</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != numbers[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                swap(numbers[i], numbers[numbers[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;查找数组中重复的元素：在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://caohuilong.github.io/categories/algorithm/"/>
    
    
    <category term="数组" scheme="http://caohuilong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中 sizeof 的用法总结</title>
    <link href="http://caohuilong.github.io/2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://caohuilong.github.io/2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-12T09:42:41.000Z</published>
    <updated>2019-03-12T09:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h4><p>需要注意的是 sizeof() 是运算符，而不是一个函数，在编译时就计算好了，用于计算数据空间的字节数。因此，sizeof 不能用来返回动态分配的内存空间的大小。sizeof 常用于返回类型和静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。</p><p>本文将介绍使用 sizeof 来判定 <strong>共用体</strong>、<strong>结构体</strong>、<strong>嵌套结构体</strong>、<strong>混合结构体</strong> 以及 <strong>类对象</strong> 所占空间的大小。</p><a id="more"></a><hr><h4 id="不同数据类型所占的内存大小"><a href="#不同数据类型所占的内存大小" class="headerlink" title="不同数据类型所占的内存大小"></a>不同数据类型所占的内存大小</h4><table><thead><tr><th align="center"></th><th align="center">32 位</th><th align="center">64 位</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">long</td><td align="center">4</td><td align="center">8</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">指针</td><td align="center">4</td><td align="center">8</td></tr></tbody></table><p>long 类型与指针类型在 32 位机器上只占 4 字节，在 64 位机器上占 8 字节。其他类型在 32 位机器和 64 位机器都是占同样的大小空间。</p><hr><h4 id="共用体的大小"><a href="#共用体的大小" class="headerlink" title="共用体的大小"></a>共用体的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union A&#123;</span><br><span class="line">    int a[5];</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面求出共用体的大小为：<strong>24</strong></p><p>union 中变量共用内存，应以最长的为准，A 中最长的成员是数组 a，其长度为 20。与结果不一样，这是因为在共用体内变量的默认对齐方式，必须以最长的 double（8Byte）对齐，所以得到 sizeof(A) = 24。所以将共用体内的 int a[5] 修改成 int a[6] 后，结果仍然不变；但如果将 int a[5] 修改成 int a[7]，结果就变成 32。</p><blockquote><p><strong>对齐系数</strong>：每个平台上的编译器都有默认对齐系数 n，但是可以通过 <code>#pragma pack(n)</code> 来设定。</p><p><strong>有效对齐系数</strong>：对于一个复杂类型变量，有效对齐系数 = min(对齐系数 n，复杂类型中最长数据类型的长度)。比如设定的对齐系数为 8，而结构体中最长的是 int，4个字节，那么有效对齐值为 4。</p></blockquote><p>通过下面的例子说明有效对齐系数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出为：<strong>20</strong></p><p>这是因为通过 <code>#pragma pack(n)</code> 设置对齐系数为 4，所以实际的有效对齐系数为：min(4, sizeof(double)) = 4，所以最后共用体 A 的大小为 5*int(4) = 20。</p><hr><h4 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h4><p>首先介绍一个概念和两条原则：</p><p><strong>偏移量</strong> ：偏移量指的是 <u>结构体变量中成员的地址</u> 和 <u>结构体变量地址</u> 的差。</p><p>存储变量时地址要求对齐，编译器在编译程序时会遵循<strong>两条原则</strong>：</p><ol><li>结构体变量中成员的偏移量必须是成员大小的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</li></ol><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出为：<strong>24</strong></p><p>这是因为 char a 的偏移量为 0，占用 1Byte；double b 指的下一个可用的地址的偏移量为 1，不是 sizeof(double)=8 的整数倍，需要补足 7Byte 才能是偏移量为 8；int c 指的下一个可用的地址的偏移量为 16，是 sizeof(int)=4 的整数倍，满足 int 的对齐方式。</p><p>故所有成员的变量都分配了空间，空间总的大小为 1+7+8+4 = 20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数 sizeof(double)=8）的倍数，所以需要填充 4Byte，以满足结构的大小为 sizeof(double)=8 的倍数，即 24 。</p><hr><h4 id="嵌套结构体的大小"><a href="#嵌套结构体的大小" class="headerlink" title="嵌套结构体的大小"></a>嵌套结构体的大小</h4><p>对于嵌套的结构体，需要将其展开。对嵌套结构体求 sizeof 时，上述原则变为：</p><ol><li>展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li></ol><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">    &#125; ss;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(C) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<strong>16</strong></p><p>char a 的偏移量为 0，占用 1Byte；但是对于展开后的结构体的第一个成员 char b，下一个可用的地址的偏移量为 1，不是被展开结构体中最大成员 int c 的整数倍，需补充 3Byte 才能是偏移量变为 4；char b 占用 1Byte，下一个可用地址的偏移量是 5，又不是 int c 大小的整数倍，又需补充 3Byte 变为 8；short d 的偏移量为 12，满足 short 的对齐方式。</p><p>故所有成员变量都分配了空间，空间总的大小为 1+3+1+3+4+2 = 14，结尾还得填充 2Byte，以满足为 4 的倍数，所以总的大小为 16。</p><hr><h4 id="混合结构体的大小"><a href="#混合结构体的大小" class="headerlink" title="混合结构体的大小"></a>混合结构体的大小</h4><p>混合结构体指的是结构体中包含有共用体（或数组）等比较复杂的结构体。如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">int</span> k[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125; UDATE;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cat;</span><br><span class="line">    UDATE cow;</span><br><span class="line">    <span class="keyword">double</span> dog;</span><br><span class="line">&#125;too;</span><br><span class="line">UDATE temp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(struct data) + <span class="keyword">sizeof</span>(temp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>摘自《后台开发：核心技术与应用实践》例1.16，书中后面的解释有部分错误。</p></blockquote><p>输出：<strong>64</strong></p><p>假设测试机器是 64 位。UDATE 是一个 union，作为变量公用空间。里面占用字节数最多的变量是数组 int k[5]，有 20Byte，但是它要与 long 类型的 8Byte 对齐，所以占用 24Byte。data 是一个 struct，每个变量分开占用空间，依次为 int(4+4) + UDATE(24) + double(8) = 40，字节已对齐，故 sizeof(struct data) 是 40。所以最后的结果为 40+24 = 64。</p><hr><h4 id="类对象的大小"><a href="#类对象的大小" class="headerlink" title="类对象的大小"></a>类对象的大小</h4><p>关于类占用的内存空间，有以下几点需要注意：</p><ol><li><p>如果类中含有虚函数，则编译器需要为类构建虚函数表，类中需要存储一个指针指向这个虚函数表的首地址，注意不管有几个虚函数，都只建立一张表，所有的虚函数地址都存在这张表里，类中只需要一个指针指向虚函数表首地址即可。</p></li><li><p>类中的静态成员是被类所有实例所共享的，它不计入sizeof计算的空间。</p></li><li><p>类中的普通函数或静态普通函数都存储在栈中，不计入sizeof计算的空间。</p></li><li><p>类成员采用字节对齐的方式分配空间。</p></li></ol><p><strong>总的来说</strong>，类对象占用的内存空间为：<u>非静态成员变量总和</u> 加上 <u>编译器为了 CPU 计算做出的数据对齐处理</u> 和 <u>支持虚函数所产生的负担</u> 的总和。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual void funa();</span><br><span class="line">        virtual void funb();</span><br><span class="line">        void func();</span><br><span class="line">        static void fund();</span><br><span class="line">        static int si; </span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        char c;</span><br><span class="line">        int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上类的大小：<strong>sizeof(B) = 12（32位）</strong>；<strong>sizeof(B) = 16（64位）</strong>。</p><p>根据以上的规则，多个虚函数只建立一张虚函数表，类中只存有一个指向虚函数表首地址的指针；普通函数 <code>func()</code> 不计入；静态成员 <code>fund()</code> 与 <code>si</code> 也不计入；char c 占用 1Byte，再需补充 3Byte；int i 占用 4Byte。所以总的大小为：一个指针大小+1+3+4。32位系统指针大小为 4Byte，所以为 12Byte；64位系统指针大小为 8Byte，所以总大小为 16Byte。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;sizeof-运算符&quot;&gt;&lt;a href=&quot;#sizeof-运算符&quot; class=&quot;headerlink&quot; title=&quot;sizeof 运算符&quot;&gt;&lt;/a&gt;sizeof 运算符&lt;/h4&gt;&lt;p&gt;需要注意的是 sizeof() 是运算符，而不是一个函数，在编译时就计算好了，用于计算数据空间的字节数。因此，sizeof 不能用来返回动态分配的内存空间的大小。sizeof 常用于返回类型和静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。&lt;/p&gt;
&lt;p&gt;本文将介绍使用 sizeof 来判定 &lt;strong&gt;共用体&lt;/strong&gt;、&lt;strong&gt;结构体&lt;/strong&gt;、&lt;strong&gt;嵌套结构体&lt;/strong&gt;、&lt;strong&gt;混合结构体&lt;/strong&gt; 以及 &lt;strong&gt;类对象&lt;/strong&gt; 所占空间的大小。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://caohuilong.github.io/categories/C/"/>
    
    
    <category term="sizeof" scheme="http://caohuilong.github.io/tags/sizeof/"/>
    
  </entry>
  
  <entry>
    <title>GDB 使用简介</title>
    <link href="http://caohuilong.github.io/2019/03/03/GDB%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://caohuilong.github.io/2019/03/03/GDB%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2019-03-03T05:38:05.000Z</published>
    <updated>2019-03-03T05:38:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容是我个人觉得在使用 gdb 时经常会用到的一些东西，根据以下参考链接中的内容整理而来，如需更全面的内容请查看参考链接。</p><p>参考链接：</p><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/">Debugging with GDB</a></p><p><a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F#.E6.98.BE.E7.A4.BA.E6.BA.90.E4.BB.A3.E7.A0.81">用GDB调试程序</a></p><a id="more"></a><hr><h3 id="1-使用-GDB-调试-C-C-程序"><a href="#1-使用-GDB-调试-C-C-程序" class="headerlink" title="1.  使用 GDB 调试 C/C++ 程序"></a>1.  使用 GDB 调试 C/C++ 程序</h3><p>要调试 C/C++ 程序，在使用 gcc/g++ 编译器编译生成可执行文件时要加上 -g 选项，把调试信息加到可执行文件中。编译如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g hello.c -o hello</span><br><span class="line">$ g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure><blockquote><p>如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。</p></blockquote><p>当你用 -g 把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用 gdb 来调试他。</p><hr><h3 id="2-启动-GDB-并加载被调试程序"><a href="#2-启动-GDB-并加载被调试程序" class="headerlink" title="2.  启动 GDB 并加载被调试程序"></a>2.  启动 GDB 并加载被调试程序</h3><p>启动 gdb 并加载被调试程序的方式有以下几种：</p><ul><li><p><code>gdb &lt;program&gt;</code></p><p>program也就是你的执行文件，一般在当前目录下。</p></li><li><p><code>gdb &lt;program&gt; core</code></p><p>用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。</p></li><li><p><code>gdb &lt;program&gt; &lt;PID&gt;</code></p><p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p></li></ul><blockquote><p>以上三种都是在启动 gdb 的同时加载被调试程序。也可以先进入gdb环境，然后再加载被调试程序，方法如下：</p><ol><li>先启动 gdb：终端输入命令 gdb</li><li>加载被调试程序：在 gdb 环境中执行 <code>file &lt;program&gt;</code></li></ol><p>注：上面两步与 <code>gdb &lt;program&gt;</code> 等效。</p></blockquote><p>进入 gdb 的调试环境后，可以使用 help 命令来查看 gdb 相关的命令，这些帮助信息都是可以根据提示来操作的。</p><hr><h3 id="3-查看源代码"><a href="#3-查看源代码" class="headerlink" title="3.  查看源代码"></a>3.  查看源代码</h3><h4 id="3-1-显示源代码"><a href="#3-1-显示源代码" class="headerlink" title="3.1  显示源代码"></a>3.1  显示源代码</h4><p>GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看<strong>查看源代码的GDB命令</strong>：</p><ul><li><p><code>list &lt;n&gt;</code></p><p>显示程序第 n 行周围的源程序</p></li><li><p><code>list &lt;function&gt;</code></p><p>显示函数名为function的函数的源程序</p></li><li><p><code>list</code></p><p>显示当前行 <strong>后面</strong> 的源程序</p></li><li><p><code>list -</code></p><p>显示当前行 <strong>前面</strong> 的源程序</p></li></ul><p>一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行。当然，你也可以定制显示的范围，使用下面命令可以<strong>设置一次显示源程序的行数</strong>：</p><ul><li><p><code>set listsize &lt;count&gt;</code></p><p>设置一次显示 count 行源代码</p></li><li><p><code>show listsize</code></p><p>查看当前 listsize 的设置</p></li></ul><p><strong>list命令还有下面的用法：</strong></p><ul><li><p><code>list &lt;first&gt;, &lt;last&gt;</code></p><p>显示从 first 行到 last 行之间的源代码</p></li><li><p><code>list ,&lt;last&gt;</code></p><p>显示从当前行到last行之间的源代码</p></li><li><p><code>list +</code></p><p>往后显示源代码</p></li></ul><p><strong>总结一下，一般来说在list后面可以跟以下这些参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;linenum&gt;   行号</span><br><span class="line">&lt;+offset&gt;   当前行号的正偏移量</span><br><span class="line">&lt;-offset&gt;   当前行号的负偏移量</span><br><span class="line">&lt;filename:linenum&gt;  哪个文件的哪一行</span><br><span class="line">&lt;function&gt;  函数名</span><br><span class="line">&lt;filename:function&gt; 哪个文件中的哪个函数</span><br><span class="line">&lt;*address&gt;  程序运行时的语句在内存中的地址</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-搜索源代码"><a href="#3-2-搜索源代码" class="headerlink" title="3.2  搜索源代码"></a>3.2  搜索源代码</h4><p>GDB 提供了以下源代码搜索命令：</p><ul><li><p><code>search &lt;regexp&gt;</code> 或 <code>forward-search &lt;regexp&gt;</code></p><p><strong>往下查找</strong>第一个符合正则表达式 regexp 的行</p></li><li><p><code>reverse-search &lt;regexp&gt;</code></p><p><strong>往上查找</strong>第一个符合正则表达式 regexp 的行</p></li></ul><hr><h4 id="3-3-指定源文件的路径"><a href="#3-3-指定源文件的路径" class="headerlink" title="3.3  指定源文件的路径"></a>3.3  指定源文件的路径</h4><p>某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。</p><ul><li><p><code>directory &lt;dirname ...&gt;</code> 或 <code>dir &lt;dirname ...&gt;</code></p><p>添加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。</p></li><li><p><code>directory</code></p><p>重置源文件路径为默认值（<code>$cdir:$cwd</code> on Unix systems）。需要确认</p></li><li><p><code>show directories</code></p><p>显示定义了的源文件搜索路径</p></li></ul><hr><h3 id="4-在-GDB-中运行程序"><a href="#4-在-GDB-中运行程序" class="headerlink" title="4.  在 GDB 中运行程序"></a>4.  在 GDB 中运行程序</h3><p>当以 <code>gdb &lt;program&gt;</code> 方式启动 gdb 后，运行程序使用 <code>r</code> 或是 <code>run</code> 命令。程序的运行，你有可能需要设置下面四方面的事：</p><ol><li><p>程序运行参数</p><p><code>set args</code> ：可指定运行时参数。（如：<code>set args 10 20 30 40 50</code>）<br><code>show args</code> ：命令可以查看设置好的运行参数。</p></li><li><p>运行环境</p><p><code>path &lt;dir&gt;</code> ：可设定程序的运行路径。<br><code>show paths</code>： 查看程序的运行路径。<br><code>set environment varname [=value]</code>： 设置环境变量。如：<code>set env USER=hchen</code><br><code>show environment [varname]</code> ：查看环境变量。</p></li><li><p>工作目录</p><p><code>cd &lt;dir&gt;</code> ：相当于 shell 的 cd 命令。<br><code>pwd</code>： 显示当前的所在目录。</p></li><li><p>程序的输入输出</p><p><code>info terminal</code>：显示你程序用到的终端的模式。<br><code>run &gt; outfile</code> ：使用重定向控制程序输出。<br><code>tty /dev/ttyb</code>：tty命令可以指定输入输出的终端设备。</p></li></ol><hr><h3 id="5-暂停程序运行"><a href="#5-暂停程序运行" class="headerlink" title="5.  暂停程序运行"></a>5.  暂停程序运行</h3><p>调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变量，以及运行时的流程。</p><p>当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。</p><p>在gdb中，我们可以有以下几种暂停方式：</p><ul><li>断点（BreakPoint）；</li><li>观察点（Watch Point）；</li><li>捕捉点（Catch Point）；</li><li>信号（Signals）；</li><li>线程停止（Thread Stops）。</li></ul><p>如果要恢复程序运行，可以使用 c 或是 continue命令。</p><h4 id="5-1-断点设置"><a href="#5-1-断点设置" class="headerlink" title="5.1  断点设置"></a>5.1  断点设置</h4><p>我们用 break 命令（简写为 b）来设置断点。下面有几点<strong>设置断点的方法</strong>：</p><ul><li><p><code>break &lt;function&gt;</code></p><p>在进入指定函数时停住。C++ 中可以使用 class::function 或 function(type,type) 格式来指定函数名.</p></li><li><p><code>break &lt;linenum&gt;</code></p><p>在指定行号设置断点。</p></li><li><p><code>break +offset</code> 与 <code>break -offset</code></p><p>在当前行号的前面或后面的 offset 行停住。offiset为自然数。</p></li><li><p><code>break filename:linenum</code></p><p>在源文件 filename 的 linenum 行处停住。</p></li><li><p><code>break filename:linenum</code></p><p>在源文件 filename 的 function 函数的入口处停住。</p></li><li><p><code>break *address</code></p><p>在程序运行的内存地址处停住。</p></li><li><p><code>break</code></p><p>break命令没有参数时，表示在下一条指令处停住。</p></li><li><p><code>break ... if &lt;condition&gt;</code></p><p>…可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置break if i==100，表示当i为100时停住程序。</p></li></ul><p><strong>查看断点时，可使用info命令</strong>，如下所示：</p><ul><li><code>info breakpoints [n]</code></li><li><code>info break [n]</code></li></ul><blockquote><p>注：n表示断点号。也可以不加 n，表示显示所有断点。</p><p><strong>断点菜单：</strong></p><p>在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break <function>不能告诉GDB要停在哪个函数的入口。当然，你可以使用break &lt;function(type)&gt;也就是把函数的参数类型告诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的断点。你只要输入你菜单列表中的编号就可以了。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b String::after</span><br><span class="line">[0] cancel</span><br><span class="line">[1] all</span><br><span class="line">[2] file:String.cc; line number:867</span><br><span class="line">[3] file:String.cc; line number:860</span><br><span class="line">[4] file:String.cc; line number:875</span><br><span class="line">[5] file:String.cc; line number:853</span><br><span class="line">[6] file:String.cc; line number:846</span><br><span class="line">[7] file:String.cc; line number:735</span><br><span class="line">&gt; 2 4 6</span><br><span class="line">Breakpoint 1 at 0xb26c: file String.cc, line 867.</span><br><span class="line">Breakpoint 2 at 0xb344: file String.cc, line 875.</span><br><span class="line">Breakpoint 3 at 0xafcc: file String.cc, line 846.</span><br><span class="line">Multiple breakpoints were set.</span><br><span class="line">Use the &quot;delete&quot; command to delete unwanted</span><br><span class="line">breakpoints.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>可见，GDB 列出了所有 after 的重载函数，你可以选一下列表编号就行了。0表示放弃设置断点，1表示所有函数都设置断点。</p></blockquote><hr><h4 id="5-2-观察点设置"><a href="#5-2-观察点设置" class="headerlink" title="5.2  观察点设置"></a>5.2  观察点设置</h4><p>观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。我们有下面的几种方法来<strong>设置观察点</strong>：</p><ul><li><p><code>watch &lt;expr&gt;</code></p><p>为表达式（变量）expr 设置一个观察点。一表达式值有变化时，马上停住程序。</p></li><li><p><code>rwatch &lt;expr&gt;</code></p><p>当表达式（变量）expr被读时，停住程序。</p></li><li><p><code>awatch &lt;expr&gt;</code></p><p>当表达式（变量）的值被读或被写时，停住程序。</p></li><li><p><code>info watchpoints</code></p><p>列出当前所设置的所有观察点。</p></li></ul><hr><h4 id="5-3-捕捉点设置"><a href="#5-3-捕捉点设置" class="headerlink" title="5.3  捕捉点设置"></a>5.3  捕捉点设置</h4><p>你可设置捕捉点来捕捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。用以下格式<strong>设置捕捉点</strong>：</p><ul><li><p><code>catch &lt;event&gt;</code></p><p>当event发生时，停住程序。event可以是下面的内容：</p><ul><li>throw 一个C++抛出的异常。（throw为关键字）</li><li>catch 一个C++捕捉到的异常。（catch为关键字）</li><li>exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）</li><li>fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）</li><li>vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）</li><li>load 或 load <libname> 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX下有用）</li><li>unload 或 unload <libname> 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在HP-UX下有用）</li></ul></li><li><p><code>tcatch &lt;event&gt;</code></p><p>只设置一次捕捉点，当程序停住以後，该点被自动删除。</p></li></ul><hr><h4 id="5-4-维护停止点"><a href="#5-4-维护停止点" class="headerlink" title="5.4  维护停止点"></a>5.4  维护停止点</h4><p>上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你觉得已定义好的停止点没有用了，你可以使用delete、clear、disable、enable这几个命令来进行维护：</p><ul><li><p><code>clear</code></p><p>清除所有的已定义的停止点。</p></li><li><p><code>clear &lt;function&gt;</code> 与 <code>clear &lt;filename:function&gt;</code></p><p>清除所有设置在函数上的停止点。</p></li><li><p><code>clear &lt;linenum&gt;</code> 与 <code>clear &lt;filename:linenum&gt;</code></p><p>清除所有设置在指定行上的停止点。</p></li><li><p><code>delete [breakpoints][range...]</code></p><p>删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为 d。</p></li><li><p><code>disable [breakpoints][range...]</code></p><p>disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis。这是一种比删除更好的方法，在需要时可以通过 enable 再次启用。</p></li><li><p><code>enable [breakpoints][range...]</code></p><p>enable所指定的停止点，breakpoints为停止点号。</p></li><li><p><code>enable [breakpoints] once range...</code></p><p>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。</p></li><li><p><code>enable [breakpoints] delete range...</code></p><p>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。</p></li></ul><hr><h3 id="6-恢复程序运行和单步调试"><a href="#6-恢复程序运行和单步调试" class="headerlink" title="6.  恢复程序运行和单步调试"></a>6.  恢复程序运行和单步调试</h3><p>当程序被停住了，你可以用 continue 命令恢复程序的运行直到程序结束，或下一个断点到来。也可以使用 step或 next 命令单步跟踪程序。</p><ul><li><p><code>continue [ignore-count]</code> 或 <code>c [ignore-count]</code> 或 <code>fg [ignore-count]</code></p><p>恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。</p></li><li><p><code>step &lt;count&gt;</code></p><p>单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p></li><li><p><code>next &lt;count&gt;</code></p><p>同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p></li><li><p><code>set step-mode</code>  或 <code>set step-mode on</code></p><p>打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有 debug 信息而不停住。这个参数很有利于查看机器码。</p></li><li><p><code>set step-mode off</code></p><p>关闭step-mode模式</p></li><li><p><code>finish</code></p><p>运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。</p></li><li><p><code>until</code> 或 <code>u</code></p><p>当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</p></li><li><p><code>stepi</code> 或 <code>si</code> | <code>nexti</code> 或 <code>ni</code></p><p>单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是 “display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</p></li></ul><hr><h3 id="7-查看栈信息"><a href="#7-查看栈信息" class="headerlink" title="7.  查看栈信息"></a>7.  查看栈信息</h3><p>当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。</p><p>下面是一些<strong>查看函数调用栈信息</strong>的 GDB 命令：</p><ul><li><p><code>backtrace</code> 或 <code>bt</code></p><p>打印当前的函数调用栈的所有信息。</p></li><li><p><code>backtrace &lt;n&gt;</code> 或 <code>bt &lt;n&gt;</code></p><p>n是一个正整数，表示只打印栈顶上n层的栈信息。</p></li><li><p><code>backtrace &lt;-n&gt;</code> 或 <code>bt &lt;-n&gt;</code> </p><p>-n表一个负整数，表示只打印栈底下n层的栈信息。</p></li></ul><p>如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是<strong>切换当前栈</strong>：</p><ul><li><p><code>frame &lt;n&gt;</code> 或 <code>f &lt;n&gt;</code></p><p>n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。</p></li><li><p><code>up &lt;n&gt;</code></p><p>表示向栈的上面移动n层，可以不打n，表示向上移动一层。</p></li><li><p><code>down &lt;n&gt;</code></p><p>表示向栈的下面移动n层，可以不打n，表示向下移动一层。</p></li></ul><p><strong>查看当前栈层的信息</strong>，你可以用以下GDB命令：</p><ul><li><p><code>frame</code> 或 <code>f</code></p><p>会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。</p></li><li><p><code>info frame</code> 或 <code>info f</code></p><p>这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。</p></li><li><p><code>info args</code></p><p>打印出当前函数的参数名及其值。</p></li><li><p><code>info locals</code></p><p>打印出当前函数中所有局部变量及其值。</p></li><li><p><code>info catch</code></p><p>打印出当前的函数中的异常处理信息。</p></li></ul><hr><h3 id="8-查看运行时数据"><a href="#8-查看运行时数据" class="headerlink" title="8.  查看运行时数据"></a>8.  查看运行时数据</h3><p>在你调试程序时，当程序被停住时，你可以使用 print 命令（简写命令为p），或是同义命令 inspect 来查看当前程序的运行数据。print 命令的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print &lt;expr&gt;</span><br><span class="line">print &#x2F;&lt;f&gt; &lt;expr&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;expr&gt;</code> 是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），<code>&lt;f&gt;</code> 是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是 <code>/x</code>。</p><h4 id="8-1-程序变量"><a href="#8-1-程序变量" class="headerlink" title="8.1  程序变量"></a>8.1  程序变量</h4><p>在GDB中，你可以随时查看以下三种变量的值：</p><ol><li>全局变量（所有文件可见的）</li><li>静态全局变量（当前文件可见的）</li><li>局部变量（当前Scope可见的）</li></ol><p>如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用 print 显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用 “::” 操作符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print  file::variable</span><br><span class="line">print  function::variable</span><br></pre></td></tr></table></figure><hr><h4 id="8-2-自动显示"><a href="#8-2-自动显示" class="headerlink" title="8.2  自动显示"></a>8.2  自动显示</h4><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是 display：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display &lt;expr&gt;</span><br><span class="line">display&#x2F;&lt;fmt&gt; &lt;expr&gt;</span><br><span class="line">display&#x2F;&lt;fmt&gt; &lt;addr&gt;</span><br></pre></td></tr></table></figure><p>expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</p><p>下面是一些和display相关的GDB命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undisplay &lt;dnums...&gt;</span><br><span class="line">delete display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><p>删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable display &lt;dnums...&gt;</span><br><span class="line">enable display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><p>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info display</span><br></pre></td></tr></table></figure><p>查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当前调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。</p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文内容是我个人觉得在使用 gdb 时经常会用到的一些东西，根据以下参考链接中的内容整理而来，如需更全面的内容请查看参考链接。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sourceware.org/gdb/onlinedocs/gdb/&quot;&gt;Debugging with GDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F#.E6.98.BE.E7.A4.BA.E6.BA.90.E4.BB.A3.E7.A0.81&quot;&gt;用GDB调试程序&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://caohuilong.github.io/categories/Linux/"/>
    
    
    <category term="GDB" scheme="http://caohuilong.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>给新 Git 账户添加 ssh-key</title>
    <link href="http://caohuilong.github.io/2019/02/21/%E7%BB%99%E6%96%B0git%E8%B4%A6%E6%88%B7%E6%B7%BB%E5%8A%A0ssh-key/"/>
    <id>http://caohuilong.github.io/2019/02/21/%E7%BB%99%E6%96%B0git%E8%B4%A6%E6%88%B7%E6%B7%BB%E5%8A%A0ssh-key/</id>
    <published>2019-02-21T09:02:23.000Z</published>
    <updated>2019-02-21T09:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用 git 的时候，git 与远程服务器一般通过 https 进行传输，这种传输方式在每次 push 和 pull 时都需要输入账户和密码，比较麻烦。所以更好的方法是通过 ssh 进行传输，这需要在本机上创建 ssh-key 密钥对，并把其中的公钥添加到远程的 Git 服务器中。但有时又会使用到多个 git 账户登录不同的 git 服务器，所以就涉及到添加 ssh-key 密钥对了。</p><a id="more"></a><p>我的环境中最初是针对 GitHub 的账户设置了 ssh 的密钥对，然后我现在需要针对另一个 git 账户进行设置密钥对，比如牛客网的 git 服务器。</p><h2 id="添加操作过程"><a href="#添加操作过程" class="headerlink" title="添加操作过程"></a>添加操作过程</h2><p><strong>1. 新建 SSH key：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxx@email.com&quot;</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;chl&#x2F;.ssh&#x2F;id_rsa): id_rsa_nowcoder</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in id_rsa_nowcoder.</span><br><span class="line">Your public key has been saved in id_rsa_nowcoder.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:hjOHuHTiXqCjTPCBf81owybsdflq&#x2F;HVWcq4jBZjnCNs xxx@email.com</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|   . o           |</span><br><span class="line">|o   Oo o         |</span><br><span class="line">|&#x3D;...oBoo         |</span><br><span class="line">| &#x3D;.+*+O.S o      |</span><br><span class="line">|+.o&#x3D;EB.&#x3D;.&#x3D;       |</span><br><span class="line">|o.* +.o .o .     |</span><br><span class="line">|.o + o.o.        |</span><br><span class="line">|o.  o  ...       |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><blockquote><p>上面设置名称为 id_rsa_nowcoder</p></blockquote><p><strong>2. 新秘钥添加到 SSH agent 中</strong></p><p>因为默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将其添加到 SSH agent 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa_nowcoder</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><p>但是出现了 Could not open a connection to your authentication agent. 的错误，用一下方法解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa_nowcoder</span><br><span class="line">Identity added: ~&#x2F;.ssh&#x2F;id_rsa_nowcoder (~&#x2F;.ssh&#x2F;id_rsa_nowcoder)</span><br></pre></td></tr></table></figure><p><strong>3. 在 git 账户中添加 SSH key</strong></p><p>登录 git 账户中添加，完成之后，SSH key 就生效了。检测方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone 你的仓库ssh地址</span><br></pre></td></tr></table></figure><p>若这时不再询问密码，说明设置生效。</p><p><strong>4. 更改远程仓库地址</strong></p><ul><li><p>修改命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin 你的仓库ssh地址</span><br></pre></td></tr></table></figure></li><li><p>或者先删后加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm origin</span><br><span class="line">$ git remote add origin 你的仓库ssh地址</span><br></pre></td></tr></table></figure></li><li><p>或者修改 config 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e</span><br><span class="line">修改 url</span><br></pre></td></tr></table></figure><p>更改完成之后，再通过 git push 或 git pull 就不需要输入账号和密码了。</p></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用 git 的时候，git 与远程服务器一般通过 https 进行传输，这种传输方式在每次 push 和 pull 时都需要输入账户和密码，比较麻烦。所以更好的方法是通过 ssh 进行传输，这需要在本机上创建 ssh-key 密钥对，并把其中的公钥添加到远程的 Git 服务器中。但有时又会使用到多个 git 账户登录不同的 git 服务器，所以就涉及到添加 ssh-key 密钥对了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://caohuilong.github.io/categories/Linux/"/>
    
    
    <category term="Git" scheme="http://caohuilong.github.io/tags/Git/"/>
    
  </entry>
  
</feed>
