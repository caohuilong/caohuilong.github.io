<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WooOh&#39;s blog</title>
  
  <subtitle>愿所有的等待，终能遇见幸福</subtitle>
  <link href="http://caohuilong.github.io/atom.xml" rel="self"/>
  
  <link href="http://caohuilong.github.io/"/>
  <updated>2020-12-09T08:40:19.000Z</updated>
  <id>http://caohuilong.github.io/</id>
  
  <author>
    <name>WooOh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CentOS6.5安装cloudinit-18</title>
    <link href="http://caohuilong.github.io/2020/12/09/CentOS6-5%E5%AE%89%E8%A3%85cloudinit-18/"/>
    <id>http://caohuilong.github.io/2020/12/09/CentOS6-5%E5%AE%89%E8%A3%85cloudinit-18/</id>
    <published>2020-12-09T08:40:19.000Z</published>
    <updated>2020-12-09T08:40:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>目前有个 CentOS6.x 的系统镜像，默认支持 cloud-init-0.7.5 版本 rpm，但是 cloud-init-0.7.5 无法通过本地化 QEMU 利用 NoCloud 数据源进行 IP 地址管理，因此无法实现虚机的网络初始化，需要手动进行配置。经过测试实验，cloud-init 17 以上版本能够支持 NoCloud 数据源信息注入，但是 cloud-init 17 及以上版本需要 python2.7 或者 python3 才能运行，而 CentOS6.x 系统默认使用 python2.6。因此为了在 CentOS6.x 上安装 cloud-init 17 以上的版本，需要先升级 python2.7，然后再安装 cloud-init。</p><a id="more"></a><hr><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h3 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h3><h5 id="1、安装-EPEL-源"><a href="#1、安装-EPEL-源" class="headerlink" title="1、安装 EPEL 源"></a>1、安装 EPEL 源</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>如果安装软件出现问题，见后续的问题记录1。</p></li><li><p>此外，安装 EPEL 源之后，安装软件还可能出问题，继续见后续问题记录2。</p></li></ul></blockquote><h5 id="2、安装-cloud-init-等软件包"><a href="#2、安装-cloud-init-等软件包" class="headerlink" title="2、安装 cloud-init 等软件包"></a>2、安装 cloud-init 等软件包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install qemu-guest-agent cloud-utils-growpart gdisk libicu cloud-init dracut-modules-growroot</span><br></pre></td></tr></table></figure><h5 id="3、安装-versionlock-并锁定-cloud-init"><a href="#3、安装-versionlock-并锁定-cloud-init" class="headerlink" title="3、安装 versionlock 并锁定 cloud-init"></a>3、安装 versionlock 并锁定 cloud-init</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install yum-plugin-versionlock</span><br><span class="line">yum versionlock add cloud-init</span><br></pre></td></tr></table></figure><h5 id="4、修改配置"><a href="#4、修改配置" class="headerlink" title="4、修改配置"></a>4、修改配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa kernel | sed &#39;s&#x2F;^kernel-&#x2F;&#x2F;&#39;  | xargs -I &#123;&#125; dracut -f &#x2F;boot&#x2F;initramfs-&#123;&#125;.img &#123;&#125;</span><br><span class="line"></span><br><span class="line">chkconfig cloud-config on</span><br><span class="line">chkconfig cloud-init on</span><br><span class="line">chkconfig cloud-final on</span><br><span class="line"></span><br><span class="line">sed -i &#39;&#x2F;$cloud_init $CLOUDINITARGS init&#x2F;a \</span><br><span class="line">    service network restart&#39; &#x2F;etc&#x2F;init.d&#x2F;cloud-init</span><br></pre></td></tr></table></figure><h3 id="安装-python2-7"><a href="#安装-python2-7" class="headerlink" title="安装 python2.7"></a>安装 python2.7</h3><h5 id="1、源码安装-python"><a href="#1、源码安装-python" class="headerlink" title="1、源码安装 python"></a>1、源码安装 python</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc openssl-devel bzip2-devel</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;2.7.16&#x2F;Python-2.7.16.tgz</span><br><span class="line">tar xzf Python-2.7.16.tgz</span><br><span class="line">cd Python-2.7.16</span><br><span class="line">.&#x2F;configure --enable-optimizations</span><br><span class="line">make altinstall</span><br><span class="line">curl &quot;https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py&quot; -o &quot;get-pip.py&quot;</span><br><span class="line">python2.7 get-pip.py</span><br></pre></td></tr></table></figure><blockquote><p>下载 get-pip.py 脚本时可能碰到 curl: (35) SSL connect error 的问题，见问题记录3。</p></blockquote><h5 id="2、下载-cloud-init-依赖的-python-包"><a href="#2、下载-cloud-init-依赖的-python-包" class="headerlink" title="2、下载 cloud-init 依赖的 python 包"></a>2、下载 cloud-init 依赖的 python 包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip2.7 install six</span><br><span class="line">pip2.7 install pyyaml</span><br><span class="line">pip2.7 install requests</span><br><span class="line">pip2.7 install jsonpatch</span><br><span class="line">pip2.7 install configobj</span><br></pre></td></tr></table></figure><blockquote><p>pip 下载失败可以更换国内源，见问题记录4。</p></blockquote><h3 id="更新-Cloud-init"><a href="#更新-Cloud-init" class="headerlink" title="更新 Cloud-init"></a>更新 Cloud-init</h3><h5 id="1、下载安装-cloud-init"><a href="#1、下载安装-cloud-init" class="headerlink" title="1、下载安装 cloud-init"></a>1、下载安装 cloud-init</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">mkdir cloud-init</span><br><span class="line">cd cloud-init</span><br><span class="line">wget http:&#x2F;&#x2F;ftp.riken.jp&#x2F;Linux&#x2F;cern&#x2F;centos&#x2F;7&#x2F;updates&#x2F;x86_64&#x2F;Packages&#x2F;cloud-init-18.5-3.el7.centos.x86_64.rpm</span><br><span class="line">rpm2cpio cloud-init-18.5-3.el7.centos.x86_64.rpm  | cpio -idmv</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;etc&#x2F;bash_completion.d&#x2F;* &#x2F;etc&#x2F;bash_completion.d</span><br><span class="line">rm -rf &#x2F;etc&#x2F;cloud&#x2F;</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;etc&#x2F;cloud  &#x2F;etc&#x2F;</span><br><span class="line">mv -f &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;etc&#x2F;rsyslog.d&#x2F;* &#x2F;etc&#x2F;rsyslog.d&#x2F;</span><br><span class="line">mkdir -p &#x2F;run&#x2F;cloud-init</span><br><span class="line">sed -i &#39;s&#x2F;\&#x2F;usr\&#x2F;bin\&#x2F;python&#x2F;\&#x2F;usr\&#x2F;local\&#x2F;bin\&#x2F;python2.7&#x2F;g&#39; &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;bin&#x2F;*</span><br><span class="line">mv -f &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;* &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;lib&#x2F;tmpfiles.d</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;lib&#x2F;tmpfiles.d&#x2F;* &#x2F;usr&#x2F;lib&#x2F;tmpfiles.d&#x2F;</span><br><span class="line">rm -rf &#x2F;usr&#x2F;libexec&#x2F;cloud-init</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;libexec&#x2F;* &#x2F;usr&#x2F;libexec&#x2F;</span><br><span class="line">rm -rf &#x2F;usr&#x2F;local&#x2F;src&#x2F;*</span><br></pre></td></tr></table></figure><h5 id="2、修改-cloud-init-配置"><a href="#2、修改-cloud-init-配置" class="headerlink" title="2、修改 cloud-init 配置"></a>2、修改 cloud-init 配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s&#x2F;disable_root.*&#x2F;disable_root\: 0&#x2F;;s&#x2F;ssh_pwauth.*&#x2F;ssh_pwauth\: 0&#x2F;&quot; &#x2F;etc&#x2F;cloud&#x2F;cloud.cfg</span><br></pre></td></tr></table></figure><p>最后执行验证 cloud-init 更新成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cloud-init</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;cloud-init 18.5</span><br></pre></td></tr></table></figure><p>大功告成！！！后面就可以对虚机做一些别的配置，最后制作成一个镜像了。</p><hr><h1 id="可能遇到的问题记录"><a href="#可能遇到的问题记录" class="headerlink" title="可能遇到的问题记录"></a>可能遇到的问题记录</h1><h5 id="1、yum-下载软件包出错-Error-Cannot-find-a-valid-baseurl-for-repo-base"><a href="#1、yum-下载软件包出错-Error-Cannot-find-a-valid-baseurl-for-repo-base" class="headerlink" title="1、yum 下载软件包出错 Error: Cannot find a valid baseurl for repo: base"></a>1、yum 下载软件包出错 Error: Cannot find a valid baseurl for repo: base</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y epel-release</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">YumRepo Error: All mirror URLs are not using ftp, http[s] or file.</span><br><span class="line"> Eg. Invalid release&#x2F;repo&#x2F;arch combination&#x2F;</span><br><span class="line">removing mirrorlist with no valid mirrors: &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;6&#x2F;base&#x2F;mirrorlist.txt</span><br><span class="line">Error: Cannot find a valid baseurl for repo: base</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：修改 yum 源，更换成国内源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.bak</span><br><span class="line">curl http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS5-Base-163.repo -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>使用 yum 再次安装又出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y epel-release</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">http:&#x2F;&#x2F;mirrors.163.com&#x2F;centos&#x2F;6&#x2F;addons&#x2F;x86_64&#x2F;repodata&#x2F;repomd.xml: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 404 Not Found&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: addons. Please verify its path and try again</span><br></pre></td></tr></table></figure><p>再次搜索之后，发现可以使用 <strong>vault.centos.org</strong> 作为更新源</p><p><strong>具体操作步骤：</strong></p><ol><li><p>关闭 fastestmirror</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;yum&#x2F;pluginconf.d&#x2F;fastestmirror.conf</span><br><span class="line">#修改参数</span><br><span class="line">enable&#x3D;0</span><br></pre></td></tr></table></figure></li><li><p>备份原来的源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mv &#x2F;etc&#x2F;yum.repo.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repo.d&#x2F;CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure></li><li><p>更换 yum 源</p><ul><li><p>阿里云 Vault 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;www.xmpan.com&#x2F;Centos-6-Vault-Aliyun.repo </span><br><span class="line"></span><br><span class="line"># wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;static.lty.fun&#x2F;%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90&#x2F;SourcesList&#x2F;Centos-6-Vault-Aliyun.repo</span><br></pre></td></tr></table></figure><blockquote><p>我的虚机上面没有 wget 命令，所以用 curl 命令来下载文件。</p></blockquote></li><li><p>官方 Vault 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;static.lty.fun&#x2F;%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90&#x2F;SourcesList&#x2F;Centos-6-Vault-Official.repo</span><br></pre></td></tr></table></figure></li></ul></li><li><p>清理并构建缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum repolist</span><br></pre></td></tr></table></figure><p>再次使用 yum 安装软件，成功。</p></li></ol><hr><h5 id="2、安装-EPEL-源后，使用报错"><a href="#2、安装-EPEL-源后，使用报错" class="headerlink" title="2、安装 EPEL 源后，使用报错"></a>2、安装 EPEL 源后，使用报错</h5><p>具体错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># yum install cloud-init</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: epel. Please verify its path and try again</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong>修改 /etc/yum.repo.d/epel.repo，将 mirrorlist=<a href="https://xxxx/">https://xxxx</a> 修改为 http，即可正常使用。</p><hr><h5 id="3、curl-35-SSL-connect-error-问题处理"><a href="#3、curl-35-SSL-connect-error-问题处理" class="headerlink" title="3、curl: (35) SSL connect error 问题处理"></a>3、curl: (35) SSL connect error 问题处理</h5><p>下载 get-pip.py 脚本出现下面错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># curl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py -o get-pip.py</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:--  0:00:03 --:--:--     0</span><br><span class="line">curl: (35) SSL connect error</span><br></pre></td></tr></table></figure><p>解决方法：无法在服务器使用 curl 命令访问 https 域名，原因是 nss 版本有点旧了，<code>yum -y update nss</code> 更新一下，重新 curl 即可！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update nss</span><br></pre></td></tr></table></figure><hr><h5 id="4、更换-pip-源"><a href="#4、更换-pip-源" class="headerlink" title="4、更换 pip 源"></a>4、更换 pip 源</h5><p>在 <code>~/.pip/pip.conf</code> 文件中添加或修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># mkdir ~&#x2F;.pip</span><br><span class="line"># cat ~&#x2F;.pip&#x2F;pip.conf</span><br><span class="line">[global]</span><br><span class="line">index-url &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;p&gt;目前有个 CentOS6.x 的系统镜像，默认支持 cloud-init-0.7.5 版本 rpm，但是 cloud-init-0.7.5 无法通过本地化 QEMU 利用 NoCloud 数据源进行 IP 地址管理，因此无法实现虚机的网络初始化，需要手动进行配置。经过测试实验，cloud-init 17 以上版本能够支持 NoCloud 数据源信息注入，但是 cloud-init 17 及以上版本需要 python2.7 或者 python3 才能运行，而 CentOS6.x 系统默认使用 python2.6。因此为了在 CentOS6.x 上安装 cloud-init 17 以上的版本，需要先升级 python2.7，然后再安装 cloud-init。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://caohuilong.github.io/categories/Linux/"/>
    
    
    <category term="CentOS" scheme="http://caohuilong.github.io/tags/CentOS/"/>
    
    <category term="Cloud-init" scheme="http://caohuilong.github.io/tags/Cloud-init/"/>
    
    <category term="镜像" scheme="http://caohuilong.github.io/tags/%E9%95%9C%E5%83%8F/"/>
    
  </entry>
  
  <entry>
    <title>Kubeadm快速部署kubernetes</title>
    <link href="http://caohuilong.github.io/2020/10/21/Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/"/>
    <id>http://caohuilong.github.io/2020/10/21/Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/</id>
    <published>2020-10-20T16:48:19.000Z</published>
    <updated>2020-10-20T16:48:19.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文基于kubeadm快速部署一套Kubernetes集群用于个人学习和测试，针对国内网络环境选择合适的镜像源，减少镜像下载时间，并安装calico网络插件。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本次环境由两台虚拟机来部署，安装CentOS7.6系统：</p><table><thead><tr><th align="center">主机名</th><th align="center">IP</th></tr></thead><tbody><tr><td align="center">master</td><td align="center">10.0.0.3</td></tr><tr><td align="center">node1</td><td align="center">10.0.0.4</td></tr></tbody></table><h3 id="配置hostname与host"><a href="#配置hostname与host" class="headerlink" title="配置hostname与host"></a>配置hostname与host</h3><p>分别在两台主机上执行命令，修改主机名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.3节点</span></span><br><span class="line">hostnamectl set-hostname master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.4节点</span></span><br><span class="line">hostnamectl set-hostname node1</span><br></pre></td></tr></table></figure><blockquote><p>hostnamectl 命令会替换<code>/etc/hostname</code>文件中的主机名，保证重启后主机名还是生效；</p><p>hostname 命令可以临时修改主机名，重启后失效。</p></blockquote><p>两台机器都要配置host，允许主机通过主机名直接通信，<code>/etc/hosts</code>文件添加一下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.3 master</span><br><span class="line">10.0.0.4 node1</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config  # 永久 需重启</span><br><span class="line">setenforce 0   # 临时</span><br></pre></td></tr></table></figure><h3 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;s/^[^#].*swap/#&amp;/&#x27; /etc/fstab</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>若要启用swap设备，则需要在集群初始化时添加 <code>--ignore-preflight-errors=swap</code>，可忽略因swap设备导致的报错。</p><h3 id="关闭ipv6"><a href="#关闭ipv6" class="headerlink" title="关闭ipv6"></a>关闭ipv6</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo net.ipv6.conf.all.disable_ipv6=1 &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo NETWORKING_IPV6=no &gt;&gt; /etc/sysconfig/network</span><br><span class="line">sed -i &#x27;s/IPV6INIT=yes/IPV6INIT=no/g&#x27; /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">sysctl -p</span><br><span class="line">ip a             # 查看ipv6是否关闭</span><br></pre></td></tr></table></figure><h3 id="将桥接的ipv4流量传递到iptables"><a href="#将桥接的ipv4流量传递到iptables" class="headerlink" title="将桥接的ipv4流量传递到iptables"></a>将桥接的ipv4流量传递到iptables</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/sysctl.d/kubernetes.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables =1</span><br><span class="line">net.bridge.bridge-nf-call-iptables =1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl --system  # 生效</span><br></pre></td></tr></table></figure><blockquote><p>这个不知道什么意思但是通过Kubeadm安装Kubenetes集群时会校验。这里也搜到<a href="https://www.joeys.top/2021/01/iptable-net-bridge-bridge-nf-call-iptables%E7%9A%84%E4%BD%9C%E7%94%A8/">一篇文章</a>说明<code>net.bridge.bridge-nf-call-iptables的作用</code>参数作用，不明所以。</p></blockquote><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>容器运行时是运行容器的基础，有多种可选的容器运行时，这里选择kubernetes默认的Docker。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 yum-utils</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 yum 源为阿里云方便下载 Docker Engine</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装最新版的docker，不同版本的k8s适配的docker版本不同，所以可能需要指定docker版本</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取docker版本列表</span></span><br><span class="line">sudo yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装指定版本的docker</span></span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="line">sudo yum install docker-ce-19.03.9-3.el7 docker-ce-cli-19.03.9-3.el7 containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动</span></span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p><strong>并且配置Docker的Cgroup Driver为systemd：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ul><li><p>什么是cgroups?</p><p>首先说下容器是什么？容器是一个视图隔离、资源可限制、独立文件系统的进程集合。cgroups(Control Groups) 是 linux 内核提供的一种机制，作用就是可以对资源进行限制。此外，视图隔离是通过namespace实现，而文件系统是通过chroot实现。</p></li><li><p>为什么要修改Cgroup Driver？</p><p>Docker默认的Cgroup Driver是cgroupfs，而Kubernetes 推荐使用 systemd 来代替 cgroupfs。如果不修改，那么同时运行有两个cgroup控制管理器，当资源有压力的情况时，有可能出现不稳定的情况。并且在kubeadm init时也会出现警告。</p></li></ul><h3 id="master节点配置免密登录node节点"><a href="#master节点配置免密登录node节点" class="headerlink" title="master节点配置免密登录node节点"></a>master节点配置免密登录node节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa # 一路默认回车即可</span><br><span class="line">ssh-copy-id master   # 过程中需要输入密码</span><br><span class="line">ssh-copy-id node1</span><br><span class="line"></span><br><span class="line">ssh root@node1   # 测试是否成功</span><br></pre></td></tr></table></figure><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h3 id="安装kubeadm、kubelet、kubectl"><a href="#安装kubeadm、kubelet、kubectl" class="headerlink" title="安装kubeadm、kubelet、kubectl"></a>安装kubeadm、kubelet、kubectl</h3><p>以下操作在所有节点进行</p><ul><li><p>添加阿里云YUM源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>指定版本安装软件，这里安装1.19.8版本，1.20不再把Docker作为默认的容器运行时，所以这里选择1.19版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet-1.19.8 kubeadm-1.19.8 kubectl-1.19.8</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure><h3 id="Master节点安装"><a href="#Master节点安装" class="headerlink" title="Master节点安装"></a>Master节点安装</h3></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=1.19.8 --image-repository=registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure><p>安装成功之后，按照提示执行下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>同时要记住打印出的下列命令，用于添加Node节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 10.0.0.3:6443 --token j91yvn.qvhw9t0n0nvjd9j7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:68f5132eed6c9a9f1dc59cd304220542e4635dbf629cc789d0d0e0b91bb909cd</span><br></pre></td></tr></table></figure><p>若没注意，可通过<code>kubeadm token list</code>查看当前的token，默认有效期为24小时，若忘记token或token过期，可使用命令<code>kubeadm token create --print-join-command</code>重新生成，若初始有问题可通过命令<code>kubeadm reset</code>重置。</p><p>启动kubelet：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet</span><br></pre></td></tr></table></figure><h3 id="Node节点安装"><a href="#Node节点安装" class="headerlink" title="Node节点安装"></a>Node节点安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet</span><br><span class="line"></span><br><span class="line">kubeadm join 10.0.0.3:6443 --token j91yvn.qvhw9t0n0nvjd9j7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:68f5132eed6c9a9f1dc59cd304220542e4635dbf629cc789d0d0e0b91bb909cd</span><br></pre></td></tr></table></figure><h3 id="安装calico"><a href="#安装calico" class="headerlink" title="安装calico"></a>安装calico</h3><p>master与node节点安装好之后，获取一下节点信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/nodes_not_ready.png" alt="node notReady"></p><p>可以看到master节点与node1节点都处于NotReady状态。查看kubelet的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/systemctl_status_kubelet.png" alt="systemctl status kubelet"></p><p> <code>No networks found in /etc/cni/net.d</code> 这行错误信息表示节点没有CNI网络插件，这是因为kubeadm目标是在不安装其他功能插件的基础上，建立一个通过Kubernetes一致性测试Kubernetes Conformance tests的最小可行集群。它在设计上并不会安装网络解决方案，而是需要用户自行安装第三方符合CNI的网络解决方案（如：flannel，calico，weave network等）。</p><p>fannel和calico算是目前网络实现最热门的2个插件，经过简单的对比，calico在性能更好以外，还可以与服务网格 Istio 集成，所以毫不犹豫的选择calico。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -o calico.yaml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f calico.yaml </span><br></pre></td></tr></table></figure><p>安装好calico相关组件之后，再次查看节点状态变为Ready：</p><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/nodes_ready.png" alt="node ready"></p><p>再查看基础应用：</p><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/pods.png" alt="system pod"></p><p>到此，一个kubenetes集群就搭建完毕，可以在该集群上创建deployment部署应用，创建service暴露服务了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文基于kubeadm快速部署一套Kubernetes集群用于个人学习和测试，针对国内网络环境选择合适的镜像源，减少镜像下载时间，并安装calico网络插件。&lt;/p&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="http://caohuilong.github.io/categories/Kubernetes/"/>
    
    
    <category term="kubeadm" scheme="http://caohuilong.github.io/tags/kubeadm/"/>
    
  </entry>
  
  <entry>
    <title>Rancher部署k8s</title>
    <link href="http://caohuilong.github.io/2020/10/01/Rancher%E9%83%A8%E7%BD%B2k8s/"/>
    <id>http://caohuilong.github.io/2020/10/01/Rancher%E9%83%A8%E7%BD%B2k8s/</id>
    <published>2020-10-01T15:07:33.000Z</published>
    <updated>2020-10-01T15:07:33.000Z</updated>
    
    <content type="html"><![CDATA[<p>Rancher是一个开源的企业级容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。本文记录Rancher部署k8s的过程。</p><a id="more"></a><h3 id="1-基本环境"><a href="#1-基本环境" class="headerlink" title="1. 基本环境"></a>1. 基本环境</h3><p>本文基于Ubuntu 16.04部署 Rancher，首先需要安装好 Docker。</p><blockquote><p>刚开始部署 Rancher 时，因为 Ubuntu 20.04 已经更新很久了都没有使用过，所以就尝试了用 Ubuntu 20.04来部署。但是在部署过程中一直不成功，仔细检查了一下才发现 Docker 针对 Ubuntu 20.04 只提供了 Docker 19.0.x 版本，官方下载链接中不支持其他的低版本。最后只能选择 Ubuntu 16.04 来部署（至于如何在 Ubuntu 20.04 上安装更低版本的后面再尝试了）。</p></blockquote><p>支持的Docker版本:</p><ul><li>17.03.x</li><li>18.06.x</li><li>18.09.x</li></ul><p><strong>安装 Docker 首先设置存储库：</strong></p><ol><li><p>更新<code>apt</code>软件包索引并安装软件包以允许<code>apt</code>通过HTTPS使用存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加Docker的官方GPG密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>使用以下命令来设置<strong>稳定的</strong>存储库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure></li></ol><p><strong>安装DOCKER引擎：</strong></p><ol><li><p>要安装<em>特定版本</em>的 Docker Engine，请在存储库中列出可用版本，然后选择并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br><span class="line">  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.1~ce~3-0~ubuntu       | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.0~ce~3-0~ubuntu       | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br></pre></td></tr></table></figure></li><li><p>更新<code>apt</code>程序包索引，并安装指定版本的Docker Engine和容器，或转到下一步以安装特定版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"> $ sudo apt-get install docker-ce&#x3D;5:18.09.1~3-0~ubuntu-xenial docker-ce-cli&#x3D;5:18.09.1~3-0~ubuntu-xenial containerd.io</span><br></pre></td></tr></table></figure></li><li><p>将当前用户加入 docker 用户组，下次登陆后执行 docker 命令可不加 sudo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="2-安装Rancher"><a href="#2-安装Rancher" class="headerlink" title="2. 安装Rancher"></a>2. 安装Rancher</h3><p>执行以下命令安装 Rancher server：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --restart&#x3D;unless-stopped -v &lt;主机路径&gt;:&#x2F;var&#x2F;lib&#x2F;rancher&#x2F; -p 80:80 -p 443:443 rancher&#x2F;rancher:stable</span><br></pre></td></tr></table></figure><hr><h3 id="3-登录Rancher，并创建集群"><a href="#3-登录Rancher，并创建集群" class="headerlink" title="3. 登录Rancher，并创建集群"></a>3. 登录Rancher，并创建集群</h3><p>稍等片刻之后，可以使用主机的 IP 在浏览器中登录 Rancher UI，并创建集群。参考链接：<a href="https://docs.rancher.cn/rancher2x/quick-start.html#_4-%E7%99%BB%E5%BD%95rancher">登录Rancher</a>。</p><hr><h3 id="4-复制向集群添加主机"><a href="#4-复制向集群添加主机" class="headerlink" title="4. 复制向集群添加主机"></a>4. 复制向集群添加主机</h3><p>接着在前端界面的主机角色选项中勾选 <code>etcd</code> 以及 <code>Control</code>，然后复制添加主机的命令到对应的主机中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --privileged --restart&#x3D;unless-stopped --net&#x3D;host -v &#x2F;etc&#x2F;kubernetes:&#x2F;etc&#x2F;kubernetes -v &#x2F;var&#x2F;run:&#x2F;var&#x2F;run rancher&#x2F;rancher-agent:v2.4.5 --server https:&#x2F;&#x2F;192.168.184.129 --token hhkvrndn7lktsmz6fxnjw9jltppq5w6ttt466rbmzsr7pwxktjq6hr --ca-checksum fc92e9aa8d072c2e2731a34d9242bb71e8abcee3b059c6c6bcddd685acbd16b1 --etcd --controlplane --worker</span><br></pre></td></tr></table></figure><p>这个过程中需要下载较多 docker 容器镜像，需要等待较长时间。</p><hr><h3 id="5-部署工作负载"><a href="#5-部署工作负载" class="headerlink" title="5. 部署工作负载"></a>5. 部署工作负载</h3><p>这个也可以参考链接：<a href="https://docs.rancher.cn/rancher2x/quick-start.html#_6-%E9%83%A8%E7%BD%B2%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD">部署工作负载</a>，这里就不截图展示了。</p><hr><h3 id="6-删除-Rancher"><a href="#6-删除-Rancher" class="headerlink" title="6. 删除 Rancher"></a>6. 删除 Rancher</h3><p>可使用一下脚本删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">docker rm -f $(sudo docker ps -aq);</span><br><span class="line">docker volume rm $(sudo docker volume ls -q);</span><br><span class="line"></span><br><span class="line">rm -rf /etc/ceph \</span><br><span class="line">       /etc/cni \</span><br><span class="line">       /etc/kubernetes \</span><br><span class="line">       /opt/cni \</span><br><span class="line">       /opt/rke \</span><br><span class="line">       /run/secrets/kubernetes.io \</span><br><span class="line">       /run/calico \</span><br><span class="line">       /run/flannel \</span><br><span class="line">       /var/lib/calico \</span><br><span class="line">       /var/lib/etcd \</span><br><span class="line">       /var/lib/cni \</span><br><span class="line">       /var/lib/kubelet \</span><br><span class="line">       /var/lib/rancher/rke/<span class="built_in">log</span> \</span><br><span class="line">       /var/<span class="built_in">log</span>/containers \</span><br><span class="line">       /var/<span class="built_in">log</span>/pods \</span><br><span class="line">       /var/run/calico</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> mount <span class="keyword">in</span> $(mount | grep tmpfs | grep <span class="string">&#x27;/var/lib/kubelet&#x27;</span> | awk <span class="string">&#x27;&#123; print $3 &#125;&#x27;</span>) /var/lib/kubelet /var/lib/rancher; <span class="keyword">do</span> umount <span class="variable">$mount</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">rm -f /var/lib/containerd/io.containerd.metadata.v1.bolt/meta.db</span><br><span class="line">sudo systemctl restart containerd</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">IPTABLES=<span class="string">&quot;/sbin/iptables&quot;</span></span><br><span class="line">cat /proc/net/ip_tables_names | <span class="keyword">while</span> <span class="built_in">read</span> table; <span class="keyword">do</span></span><br><span class="line">  <span class="variable">$IPTABLES</span> -t <span class="variable">$table</span> -L -n | <span class="keyword">while</span> <span class="built_in">read</span> c chain rest; <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;X<span class="variable">$c</span>&quot;</span> = <span class="string">&quot;XChain&quot;</span> ; <span class="keyword">then</span></span><br><span class="line">        <span class="variable">$IPTABLES</span> -t <span class="variable">$table</span> -F <span class="variable">$chain</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="variable">$IPTABLES</span> -t <span class="variable">$table</span> -X</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>不仅要删除相关的容器，还需要删除对应的 docker volume，以及其他的一些配置，最后重启主机，之后才能重新运行新的 Rancher 平台。</p><hr><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>在我多次尝试之后，发现 Docker 是关键，包括 Docker 的版本以及对应的镜像源，都对 Rancher 的成功部署有重要的影响。</p><p>在基本的 Docker 环境没有问题之后，用过 Rancher 来管理 Kubernetes 真的是太简单了。</p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Rancher是一个开源的企业级容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。本文记录Rancher部署k8s的过程。&lt;/p&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="http://caohuilong.github.io/categories/Kubernetes/"/>
    
    
    <category term="Rancher" scheme="http://caohuilong.github.io/tags/Rancher/"/>
    
  </entry>
  
  <entry>
    <title>数据库锁</title>
    <link href="http://caohuilong.github.io/2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
    <id>http://caohuilong.github.io/2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</id>
    <published>2020-09-14T12:23:31.000Z</published>
    <updated>2020-09-14T12:23:31.000Z</updated>
    
    <content type="html"><![CDATA[<p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。本文记录在学习数据库锁过程中的关键概念以及一些个人的理解。</p><a id="more"></a><h5 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h5><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）——DML（Data Manipulate Language）、数据定义语句（包括建表、修改表结构等）——DDL（Data Definition Language）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都 select 出来存成文本。但是在备份过程中整个库完全处于只读状态，如果在主库上面备份，那么在备份期间都不能执行更新，业务基本停摆；如果在从库备份，那么备份期间不能执行从主库同步过来的binlog，会导致主从延迟。</p><p>所以更好的备份方法是在可重复读隔离级别下开启一个事务，在整个备份过程中，都能拿到一致性视图，并且数据可以正常更新。但是可重复读隔离级别需要引擎支持才能使用，对于MyISAM等不支持事务的引擎，只能使用FTWRL全局锁的方式备份。<!--这也是使用 InnoDB 替代 MyISAM 的原因之一-->。</p><p>还有另一种方法实现全库只读——<code>set global readonly=true</code>，但是相比之下，还是推荐用FTWRL方式，原因如下：</p><ul><li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。</li><li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><h5 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h5><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><ul><li><strong>表锁</strong>的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li><li><strong>元数据锁 MDL</strong>（metadata lock)不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。<ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul></li></ul><h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，<!--这也是 MyISAM 被 InnoDB 替代的重要原因之一-->。</p><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是<strong>两阶段锁协议</strong>。如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。当出现死锁以后，有两种解决策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。默认是50s，当出现死锁时，第一个被锁住的线程需要过50s才会超时退出，然后其他线程才有可能继续执行，这个时间对于在线业务是无法接受的。但是如果把这个时间设置成一个很小的时间，比如1s，会导致普通的锁等待也超时退出，造成误伤。1</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁，这是一个时间复杂度为O(n)的操作。</li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。本文记录在学习数据库锁过程中的关键概念以及一些个人的理解。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>B+树与索引</title>
    <link href="http://caohuilong.github.io/2020/09/01/B+%E6%A0%91%E4%B8%8E%E7%B4%A2%E5%BC%95/"/>
    <id>http://caohuilong.github.io/2020/09/01/B+%E6%A0%91%E4%B8%8E%E7%B4%A2%E5%BC%95/</id>
    <published>2020-09-01T12:19:04.000Z</published>
    <updated>2020-09-01T12:19:04.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="B-树与数据库索引"><a href="#B-树与数据库索引" class="headerlink" title="B+树与数据库索引"></a>B+树与数据库索引</h4><p>MySQL InnoDB引擎中，使用了B+树的索引模型，数据都是存储在B+树中的，每一个索引在InnoDB中都是一棵B+树。本文首先介绍B+树的概念，然后介绍MySQL的索引。</p><a id="more"></a><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>数据库引擎有很多可用的数据结构，如哈希表、有序数组、二叉树搜索树。</p><ul><li>哈希表：键值对，把值放在数组中，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置，如果有哈希冲突，其中一种解决方法是链表。哈希表只适用于等值查询的场景。</li><li>有序数组：按顺序存储，查询用二分法可以快速查询，但是更新效率低，只适用于静态存储引擎。</li><li>二叉树搜索树：每个节点的左儿子小于父节点，父节点小于右儿子，查询和更新时间复杂度都是O(logN)。</li></ul><p>在上述三种数据结构中，只有二叉搜索树能够适用的场景更多，但是直接通过二叉搜索树也不太适合数据库存储，因为二叉搜索树的树高太高，而每一层的数据不太可能存在连续的数据块中，因此一次查询需要访问的数据块太多，尤其是在数据库可能存在磁盘中，速度就更慢了，所以一般都采用“N叉”树。InnoDB采用的是B+树结构，因为B+树能够很好地配合磁盘的读写特性，减少单词查询的磁盘访问次数。</p><p>B+树的查询效率更加稳定：由于非终节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><p>数据库索引用于提高数据查询效率，索引类型分为主键索引和非主键索引（普通索引）：</p><ul><li><p><strong>主键索引</strong>的叶子节点存的是整行数据；</p></li><li><p><strong>非主键索引</strong>的叶子节点内容是主键的值，所以非主键索引也被称为二级索引，通过普通索引查询时，需要先搜索非主键索引树，找到主键，然后再到主键索引树中再搜索一次，这个过程称为回表。基于非主键索引的查询需要多扫描一棵索引树，因此在应用中应该尽量使用主键索引。如果不通过索引来查询，就是遍历主键索引树，因此效率是最低的。</p></li></ul><p>优化数据库索引的一些方法：</p><ul><li>覆盖索引：假设有一张表，主键是ID，还有一个字段k，并且对k建立了一个非主键索引，在执行<code>select ID from T where k between 3 and 5</code>语句时，因为只需要查询主键ID的值，而主键ID是非主键索引k的叶子节点的值，因此索引k已经“覆盖了”我们的查询需求，不需要回表过程，这就被称为覆盖索引。</li><li>前缀索引：B+树这种索引结构，可以利用索引的“最左前缀”来定位记录。对于联合索引的最左N个字段或者字符串索引最左M个字符，都可以利用索引来加速检索。</li><li>索引下推：索引下推指的是可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li></ul>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;B-树与数据库索引&quot;&gt;&lt;a href=&quot;#B-树与数据库索引&quot; class=&quot;headerlink&quot; title=&quot;B+树与数据库索引&quot;&gt;&lt;/a&gt;B+树与数据库索引&lt;/h4&gt;&lt;p&gt;MySQL InnoDB引擎中，使用了B+树的索引模型，数据都是存储在B+树中的，每一个索引在InnoDB中都是一棵B+树。本文首先介绍B+树的概念，然后介绍MySQL的索引。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>数据库事务</title>
    <link href="http://caohuilong.github.io/2020/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
    <id>http://caohuilong.github.io/2020/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</id>
    <published>2020-08-18T08:10:05.000Z</published>
    <updated>2020-08-18T08:10:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文记录在学习数据库事务中的一些关键概念，包括事务的ACID特性、多事务同时执行可能存在的问题、事务的隔离级别，最后对数据库的长连接与长事务做了一个对比。</p><a id="more"></a><h5 id="事务的ACID特性："><a href="#事务的ACID特性：" class="headerlink" title="事务的ACID特性："></a>事务的ACID特性：</h5><ul><li>原子性（Atomicity）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读、提交读、可重复读和串行化。</li><li>持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h5 id="多事务同时执行可能存在的问题："><a href="#多事务同时执行可能存在的问题：" class="headerlink" title="多事务同时执行可能存在的问题："></a>多事务同时执行可能存在的问题：</h5><ul><li>脏读（dirty read）：读到其他事务未提交的数据。</li><li>不可重复读（non-repeatable read）：前后读取的记录内容不一致。</li><li>幻读（phantom read）：前后读取的记录数量不一致。</li></ul><h5 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h5><ul><li>读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化（serializable）：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h5 id="长连接与长事务"><a href="#长连接与长事务" class="headerlink" title="长连接与长事务"></a>长连接与长事务</h5><ul><li><p>长连接：是指连接数据库成功后，如果客户端持续有请求，则一直使用同一个连接。对应的短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，<strong>也就是尽量使用长连接</strong>。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p></li><li><p>长事务：一直不提交的事务，就是长事务。<strong>尽量不要使用长事务</strong>，因为长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p></li></ul>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文记录在学习数据库事务中的一些关键概念，包括事务的ACID特性、多事务同时执行可能存在的问题、事务的隔离级别，最后对数据库的长连接与长事务做了一个对比。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>redo log与bin log的个人理解</title>
    <link href="http://caohuilong.github.io/2020/08/06/redo%20log%E4%B8%8Ebin%20log%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
    <id>http://caohuilong.github.io/2020/08/06/redo%20log%E4%B8%8Ebin%20log%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</id>
    <published>2020-08-05T17:08:45.000Z</published>
    <updated>2020-08-05T17:08:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>MySQL数据库的更新流程涉及两个重要的日志模块：redo log与bin log，本文记录一下在学习丁奇大佬的《MySQL实战45讲》过程中我个人的一些理解，如有不对的地方，欢迎指正。</p><a id="more"></a><h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><ul><li><p><strong>特点：</strong>InnoDB引擎所特有的；是物理日志，记录的是数据“做了什么改动”；redo log循环写，空间固定，会用完。</p></li><li><p><strong>作用：</strong>用于保证数据库发生异常重启恢复数据，之前提交的记录都不会丢失，也就是 <strong>crash-safe</strong>。</p></li><li><p><strong>理解：</strong>数据库更新的部分数据可以暂时保存在内存中，并不是立马写到磁盘中，这样可以减少读写磁盘的次数。但是保存在内存中的数据可能会因为数据库出现异常重启的情况而导致数据丢失，无法从磁盘中的数据恢复最新的数据。有了redo log之后可以解决这个问题，每次更新完数据之前，会在redo log文件中记录数据的变更操作，这样在数据库异常重启之后，会根据磁盘中的数据以及redo log，恢复最新的数据。</p></li></ul><h5 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h5><ul><li><strong>特点：</strong>MySQL server层实现的日志，所有存储引擎插件都可以使用；是逻辑日志，记录的是这个语句的原始逻辑（有两种模式，statement格式记录sql语句，row格式会记录行的内容，记两条，更新前与更新后都有）；bin log可以追加写，文件写到一定大小会写到下一个文件，不会覆盖以前的日志。</li><li><strong>作用：</strong>将数据库rollback至某个操作或者某个时间点之前的状态，或者用于备份数据。</li><li><strong>理解：</strong>无法通过redo log来实现这个rollback操作，因为redo log记录的是内存数据与磁盘数据的变化，就算要通过redo log来rollback，那也只能将最新的数据库回滚到内存中某个时间点的状态，而无法回滚到磁盘中数据的某个时间点。但是通过bin log可以实现这种回滚需求，假设需要回滚至某个删表操作之前的状态，只需要从删除操作之前最近的一个数据备份开始，重新执行bin log中从数据备份开始至删除操作之前的bin log即可。</li></ul><blockquote><p>通过对redo log与bin log的介绍与理解，可知二者作用不同，需同时存在才能实现数据库的某些可用性与可靠性。但是二者之间必须按照某个特定的逻辑顺序来处理才能处理一些出现错误的场景，也就是redo log的两阶段提交，先执行写redo log的prepare阶段，然后执行写bin log，最后执行写redo log的commit阶段，如果中间有某个阶段出错，都会让redo log、bin log回滚。</p></blockquote>]]></content>
    
    
    <summary type="html">&lt;p&gt;MySQL数据库的更新流程涉及两个重要的日志模块：redo log与bin log，本文记录一下在学习丁奇大佬的《MySQL实战45讲》过程中我个人的一些理解，如有不对的地方，欢迎指正。&lt;/p&gt;</summary>
    
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/categories/MySQL/"/>
    
    
    <category term="MySQL" scheme="http://caohuilong.github.io/tags/MySQL/"/>
    
  </entry>
  
  <entry>
    <title>二分查找算法总结</title>
    <link href="http://caohuilong.github.io/2019/04/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://caohuilong.github.io/2019/04/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-04-01T05:51:32.000Z</published>
    <updated>2019-04-01T05:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<p>二分查找或二分搜索（binary search），是一种在有序数组中查找某一特定元素的搜索算法。必须满足以下特征：</p><ul><li>存储在数组中</li><li>有序排列</li></ul><blockquote><p>如果是用链表存储的，就无法应用二分查找了，因为链表不能通过下标随机访问其元素。</p></blockquote><p>本文介绍基本的二分查找及其各种变体。</p><a id="more"></a><h4 id="1-基本二分查找"><a href="#1-基本二分查找" class="headerlink" title="1.基本二分查找"></a>1.基本二分查找</h4><p>基本二分查找的搜索过程是从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果中间元素大于目标值，则在数组小于中间元素的那一半中查找；如果中间元素小于目标值，则在数组大于中间元素的那一半查找。如果在某一步数组为空，则代表找不到。二分查找算法每一次比较都会使搜索范围缩小一半。</p><p>基本二分查找的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">basic_binary_search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//target在左边，改右边界</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//target在右边，改左边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-各种变体"><a href="#2-各种变体" class="headerlink" title="2. 各种变体"></a>2. 各种变体</h4><p>二分查找除了基本的查找某个元素的位置之外，还有很多的变体。比如查找第一个大于target的元素位置，这经常用于寻找要插入的位置；反过来，也会查找第一个比target小的元素的位置。有时也会查找某个元素在数组中的上下界，也就是查找不大于target的最后一个元素的位置或是查找不小于target的第一个元素的位置。最后还会出现数组中有多个target元素时，需要查找第一次或最后一次出现target元素的位置。</p><p>因此，如下分成了六种变体，在编写相应的二分查找算法的代码时，需要注意的就是判断条件以及返回值的问题。不多说，先看代码：</p><h5 id="变体1：查找第一个大于target的元素位置"><a href="#变体1：查找第一个大于target的元素位置" class="headerlink" title="变体1：查找第一个大于target的元素位置"></a>变体1：查找第一个大于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_greater</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size())</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体2：查找最后一个小于target的元素位置"><a href="#变体2：查找最后一个小于target的元素位置" class="headerlink" title="变体2：查找最后一个小于target的元素位置"></a>变体2：查找最后一个小于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_less</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与标准库中 upper_bound 函数功能一致。</p></blockquote><hr><h5 id="变体3：查找第一个大于等于target的元素位置"><a href="#变体3：查找第一个大于等于target的元素位置" class="headerlink" title="变体3：查找第一个大于等于target的元素位置"></a>变体3：查找第一个大于等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_greater_equal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size())</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与标准库中 lower_bound 函数的功能是一样的。</p></blockquote><hr><h5 id="变体4：查找最后一个小于等于target的元素位置"><a href="#变体4：查找最后一个小于等于target的元素位置" class="headerlink" title="变体4：查找最后一个小于等于target的元素位置"></a>变体4：查找最后一个小于等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_less_equal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体5：查找第一个等于target的元素位置"><a href="#变体5：查找第一个等于target的元素位置" class="headerlink" title="变体5：查找第一个等于target的元素位置"></a>变体5：查找第一个等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_first</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size() &amp;&amp; nums[left] == target)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体6：查找最后一个等于target的元素位置"><a href="#变体6：查找最后一个等于target的元素位置" class="headerlink" title="变体6：查找最后一个等于target的元素位置"></a>变体6：查找最后一个等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_last</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == target)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>看以上循环部分的代码都有一种结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">    mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (target ➀ nums[mid])</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ➁;</span><br></pre></td></tr></table></figure><p>不同的地方有两个：</p><ul><li><p>循环体内部的判断条件：<code>if (target ➀ nums[mid])</code></p><p>➀所在的位置的比较符号是 &lt; 或 &lt;= 。不存在大于或大于等于的情况。</p></li><li><p>返回值：<code>return ➁;</code></p><p>➁所在位置返回值是 left 或 right。</p></li></ul><blockquote><p>循环的终止条件都是 left &gt; right。</p></blockquote><p>不同变体的情况下，➀➁处的取值如下表：</p><table><thead><tr><th align="center">变体</th><th align="center">➀</th><th align="center">➁</th></tr></thead><tbody><tr><td align="center">查找<strong>第一个大于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个小于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">right</td></tr><tr><td align="center">查找<strong>第一个大于等于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个小于等于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">right</td></tr><tr><td align="center">查找<strong>第一个等于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个等于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">right</td></tr></tbody></table><p>根据上表，再根据问题的一些特点可以得出以下一些规律：</p><ul><li>查找第一个（大于、大于等于、等于）target的元素位置，也就是找左边界，返回 left。</li><li>查找最后一个（小于、小于等于、等于）target的元素位置，也就是找右边界，返回 right。</li></ul><blockquote><p>另外，其实变体 5、6 在元素存在于数组中时，与变体3、4是一样的解法。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;二分查找或二分搜索（binary search），是一种在有序数组中查找某一特定元素的搜索算法。必须满足以下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储在数组中&lt;/li&gt;
&lt;li&gt;有序排列&lt;/li&gt;
&lt;/ul&gt;
&lt;blockquote&gt;
&lt;p&gt;如果是用链表存储的，就无法应用二分查找了，因为链表不能通过下标随机访问其元素。&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;本文介绍基本的二分查找及其各种变体。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://caohuilong.github.io/categories/algorithm/"/>
    
    
    <category term="二分查找" scheme="http://caohuilong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找数组中重复的元素</title>
    <link href="http://caohuilong.github.io/2019/03/20/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://caohuilong.github.io/2019/03/20/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2019-03-20T14:27:28.000Z</published>
    <updated>2019-03-20T14:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<p>查找数组中重复的元素：在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。</p><a id="more"></a><h2 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h2><h4 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h4><p>最简单的方法就是用一个集合 set，遍历数组的每一个元素，在 set 中查找是否存在该元素，如果存在则返回；不存在则放入集合，并继续循环。</p><p>复杂度：</p><ul><li>空间复杂度为：<code>O(N)</code></li><li>时间复杂度为：<code>O(NlogN)</code> （遍历数组为 <code>O(N)</code>，set 中查找为 <code>O(logN)</code>）</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> n, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; Set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Set.find(numbers[i]) != Set.end())&#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set.insert(numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="改进：使用hash表"><a href="#改进：使用hash表" class="headerlink" title="改进：使用hash表"></a>改进：使用hash表</h4><p>使用一个长度为 n 的数组来作为 hash 表，初始化为 0。然后遍历数组，利用数组元素作为 hash 表的索引，如果其对应的值为 1，说明是第二次访问该索引，那么该索引就是原数组中重复的元素；如果其对应的值为 0，说明是第一次访问，设置为 1。</p><p>复杂度：</p><ul><li>空间复杂度为：<code>O(N)</code></li><li>时间复杂度为：<code>O(N)</code> </li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_table[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_table[numbers[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hash_table[numbers[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="常数空间"><a href="#常数空间" class="headerlink" title="常数空间"></a>常数空间</h4><p>上面的方法都会使用 O(N) 的内存空间，如果只能使用 O(1) 的空间，那么可以考虑下面的方法。</p><p>一种类似于基数排序的方法：</p><p>索引 i 从 0 开始遍历数组，</p><ul><li>如果 i == numbers[i]，说明 numbers[i] 在正确的位置上；</li><li>如果 i != numbers[i]，<ul><li>如果 numbers[i] != numbers[numbers[i]]，交换 numbers[i] 和 numbers[numbers[i]]，那么 numbers[numbers[i]] 将会在正确的位置上。</li><li>否则 numbers[i] == numbers[numbers[i]]，那么就找到了 numbers[i]。</li></ul></li></ul><p>复杂度：</p><ul><li>空间复杂度：O(1)</li><li>时间复杂度：O(N)</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != numbers[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                swap(numbers[i], numbers[numbers[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;查找数组中重复的元素：在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://caohuilong.github.io/categories/algorithm/"/>
    
    
    <category term="数组" scheme="http://caohuilong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中 sizeof 的用法总结</title>
    <link href="http://caohuilong.github.io/2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://caohuilong.github.io/2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-12T09:42:41.000Z</published>
    <updated>2019-03-12T09:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h4><p>需要注意的是 sizeof() 是运算符，而不是一个函数，在编译时就计算好了，用于计算数据空间的字节数。因此，sizeof 不能用来返回动态分配的内存空间的大小。sizeof 常用于返回类型和静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。</p><p>本文将介绍使用 sizeof 来判定 <strong>共用体</strong>、<strong>结构体</strong>、<strong>嵌套结构体</strong>、<strong>混合结构体</strong> 以及 <strong>类对象</strong> 所占空间的大小。</p><a id="more"></a><hr><h4 id="不同数据类型所占的内存大小"><a href="#不同数据类型所占的内存大小" class="headerlink" title="不同数据类型所占的内存大小"></a>不同数据类型所占的内存大小</h4><table><thead><tr><th align="center"></th><th align="center">32 位</th><th align="center">64 位</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">long</td><td align="center">4</td><td align="center">8</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">指针</td><td align="center">4</td><td align="center">8</td></tr></tbody></table><p>long 类型与指针类型在 32 位机器上只占 4 字节，在 64 位机器上占 8 字节。其他类型在 32 位机器和 64 位机器都是占同样的大小空间。</p><hr><h4 id="共用体的大小"><a href="#共用体的大小" class="headerlink" title="共用体的大小"></a>共用体的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union A&#123;</span><br><span class="line">    int a[5];</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面求出共用体的大小为：<strong>24</strong></p><p>union 中变量共用内存，应以最长的为准，A 中最长的成员是数组 a，其长度为 20。与结果不一样，这是因为在共用体内变量的默认对齐方式，必须以最长的 double（8Byte）对齐，所以得到 sizeof(A) = 24。所以将共用体内的 int a[5] 修改成 int a[6] 后，结果仍然不变；但如果将 int a[5] 修改成 int a[7]，结果就变成 32。</p><blockquote><p><strong>对齐系数</strong>：每个平台上的编译器都有默认对齐系数 n，但是可以通过 <code>#pragma pack(n)</code> 来设定。</p><p><strong>有效对齐系数</strong>：对于一个复杂类型变量，有效对齐系数 = min(对齐系数 n，复杂类型中最长数据类型的长度)。比如设定的对齐系数为 8，而结构体中最长的是 int，4个字节，那么有效对齐值为 4。</p></blockquote><p>通过下面的例子说明有效对齐系数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出为：<strong>20</strong></p><p>这是因为通过 <code>#pragma pack(n)</code> 设置对齐系数为 4，所以实际的有效对齐系数为：min(4, sizeof(double)) = 4，所以最后共用体 A 的大小为 5*int(4) = 20。</p><hr><h4 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h4><p>首先介绍一个概念和两条原则：</p><p><strong>偏移量</strong> ：偏移量指的是 <u>结构体变量中成员的地址</u> 和 <u>结构体变量地址</u> 的差。</p><p>存储变量时地址要求对齐，编译器在编译程序时会遵循<strong>两条原则</strong>：</p><ol><li>结构体变量中成员的偏移量必须是成员大小的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</li></ol><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出为：<strong>24</strong></p><p>这是因为 char a 的偏移量为 0，占用 1Byte；double b 指的下一个可用的地址的偏移量为 1，不是 sizeof(double)=8 的整数倍，需要补足 7Byte 才能是偏移量为 8；int c 指的下一个可用的地址的偏移量为 16，是 sizeof(int)=4 的整数倍，满足 int 的对齐方式。</p><p>故所有成员的变量都分配了空间，空间总的大小为 1+7+8+4 = 20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数 sizeof(double)=8）的倍数，所以需要填充 4Byte，以满足结构的大小为 sizeof(double)=8 的倍数，即 24 。</p><hr><h4 id="嵌套结构体的大小"><a href="#嵌套结构体的大小" class="headerlink" title="嵌套结构体的大小"></a>嵌套结构体的大小</h4><p>对于嵌套的结构体，需要将其展开。对嵌套结构体求 sizeof 时，上述原则变为：</p><ol><li>展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li></ol><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">    &#125; ss;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(C) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<strong>16</strong></p><p>char a 的偏移量为 0，占用 1Byte；但是对于展开后的结构体的第一个成员 char b，下一个可用的地址的偏移量为 1，不是被展开结构体中最大成员 int c 的整数倍，需补充 3Byte 才能是偏移量变为 4；char b 占用 1Byte，下一个可用地址的偏移量是 5，又不是 int c 大小的整数倍，又需补充 3Byte 变为 8；short d 的偏移量为 12，满足 short 的对齐方式。</p><p>故所有成员变量都分配了空间，空间总的大小为 1+3+1+3+4+2 = 14，结尾还得填充 2Byte，以满足为 4 的倍数，所以总的大小为 16。</p><hr><h4 id="混合结构体的大小"><a href="#混合结构体的大小" class="headerlink" title="混合结构体的大小"></a>混合结构体的大小</h4><p>混合结构体指的是结构体中包含有共用体（或数组）等比较复杂的结构体。如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">int</span> k[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125; UDATE;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cat;</span><br><span class="line">    UDATE cow;</span><br><span class="line">    <span class="keyword">double</span> dog;</span><br><span class="line">&#125;too;</span><br><span class="line">UDATE temp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(struct data) + <span class="keyword">sizeof</span>(temp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>摘自《后台开发：核心技术与应用实践》例1.16，书中后面的解释有部分错误。</p></blockquote><p>输出：<strong>64</strong></p><p>假设测试机器是 64 位。UDATE 是一个 union，作为变量公用空间。里面占用字节数最多的变量是数组 int k[5]，有 20Byte，但是它要与 long 类型的 8Byte 对齐，所以占用 24Byte。data 是一个 struct，每个变量分开占用空间，依次为 int(4+4) + UDATE(24) + double(8) = 40，字节已对齐，故 sizeof(struct data) 是 40。所以最后的结果为 40+24 = 64。</p><hr><h4 id="类对象的大小"><a href="#类对象的大小" class="headerlink" title="类对象的大小"></a>类对象的大小</h4><p>关于类占用的内存空间，有以下几点需要注意：</p><ol><li><p>如果类中含有虚函数，则编译器需要为类构建虚函数表，类中需要存储一个指针指向这个虚函数表的首地址，注意不管有几个虚函数，都只建立一张表，所有的虚函数地址都存在这张表里，类中只需要一个指针指向虚函数表首地址即可。</p></li><li><p>类中的静态成员是被类所有实例所共享的，它不计入sizeof计算的空间。</p></li><li><p>类中的普通函数或静态普通函数都存储在栈中，不计入sizeof计算的空间。</p></li><li><p>类成员采用字节对齐的方式分配空间。</p></li></ol><p><strong>总的来说</strong>，类对象占用的内存空间为：<u>非静态成员变量总和</u> 加上 <u>编译器为了 CPU 计算做出的数据对齐处理</u> 和 <u>支持虚函数所产生的负担</u> 的总和。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual void funa();</span><br><span class="line">        virtual void funb();</span><br><span class="line">        void func();</span><br><span class="line">        static void fund();</span><br><span class="line">        static int si; </span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        char c;</span><br><span class="line">        int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上类的大小：<strong>sizeof(B) = 12（32位）</strong>；<strong>sizeof(B) = 16（64位）</strong>。</p><p>根据以上的规则，多个虚函数只建立一张虚函数表，类中只存有一个指向虚函数表首地址的指针；普通函数 <code>func()</code> 不计入；静态成员 <code>fund()</code> 与 <code>si</code> 也不计入；char c 占用 1Byte，再需补充 3Byte；int i 占用 4Byte。所以总的大小为：一个指针大小+1+3+4。32位系统指针大小为 4Byte，所以为 12Byte；64位系统指针大小为 8Byte，所以总大小为 16Byte。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;sizeof-运算符&quot;&gt;&lt;a href=&quot;#sizeof-运算符&quot; class=&quot;headerlink&quot; title=&quot;sizeof 运算符&quot;&gt;&lt;/a&gt;sizeof 运算符&lt;/h4&gt;&lt;p&gt;需要注意的是 sizeof() 是运算符，而不是一个函数，在编译时就计算好了，用于计算数据空间的字节数。因此，sizeof 不能用来返回动态分配的内存空间的大小。sizeof 常用于返回类型和静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。&lt;/p&gt;
&lt;p&gt;本文将介绍使用 sizeof 来判定 &lt;strong&gt;共用体&lt;/strong&gt;、&lt;strong&gt;结构体&lt;/strong&gt;、&lt;strong&gt;嵌套结构体&lt;/strong&gt;、&lt;strong&gt;混合结构体&lt;/strong&gt; 以及 &lt;strong&gt;类对象&lt;/strong&gt; 所占空间的大小。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://caohuilong.github.io/categories/C/"/>
    
    
    <category term="sizeof" scheme="http://caohuilong.github.io/tags/sizeof/"/>
    
  </entry>
  
  <entry>
    <title>GDB 使用简介</title>
    <link href="http://caohuilong.github.io/2019/03/03/GDB%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://caohuilong.github.io/2019/03/03/GDB%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2019-03-03T05:38:05.000Z</published>
    <updated>2019-03-03T05:38:05.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文内容是我个人觉得在使用 gdb 时经常会用到的一些东西，根据以下参考链接中的内容整理而来，如需更全面的内容请查看参考链接。</p><p>参考链接：</p><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/">Debugging with GDB</a></p><p><a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F#.E6.98.BE.E7.A4.BA.E6.BA.90.E4.BB.A3.E7.A0.81">用GDB调试程序</a></p><a id="more"></a><hr><h3 id="1-使用-GDB-调试-C-C-程序"><a href="#1-使用-GDB-调试-C-C-程序" class="headerlink" title="1.  使用 GDB 调试 C/C++ 程序"></a>1.  使用 GDB 调试 C/C++ 程序</h3><p>要调试 C/C++ 程序，在使用 gcc/g++ 编译器编译生成可执行文件时要加上 -g 选项，把调试信息加到可执行文件中。编译如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g hello.c -o hello</span><br><span class="line">$ g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure><blockquote><p>如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。</p></blockquote><p>当你用 -g 把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用 gdb 来调试他。</p><hr><h3 id="2-启动-GDB-并加载被调试程序"><a href="#2-启动-GDB-并加载被调试程序" class="headerlink" title="2.  启动 GDB 并加载被调试程序"></a>2.  启动 GDB 并加载被调试程序</h3><p>启动 gdb 并加载被调试程序的方式有以下几种：</p><ul><li><p><code>gdb &lt;program&gt;</code></p><p>program也就是你的执行文件，一般在当前目录下。</p></li><li><p><code>gdb &lt;program&gt; core</code></p><p>用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。</p></li><li><p><code>gdb &lt;program&gt; &lt;PID&gt;</code></p><p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p></li></ul><blockquote><p>以上三种都是在启动 gdb 的同时加载被调试程序。也可以先进入gdb环境，然后再加载被调试程序，方法如下：</p><ol><li>先启动 gdb：终端输入命令 gdb</li><li>加载被调试程序：在 gdb 环境中执行 <code>file &lt;program&gt;</code></li></ol><p>注：上面两步与 <code>gdb &lt;program&gt;</code> 等效。</p></blockquote><p>进入 gdb 的调试环境后，可以使用 help 命令来查看 gdb 相关的命令，这些帮助信息都是可以根据提示来操作的。</p><hr><h3 id="3-查看源代码"><a href="#3-查看源代码" class="headerlink" title="3.  查看源代码"></a>3.  查看源代码</h3><h4 id="3-1-显示源代码"><a href="#3-1-显示源代码" class="headerlink" title="3.1  显示源代码"></a>3.1  显示源代码</h4><p>GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看<strong>查看源代码的GDB命令</strong>：</p><ul><li><p><code>list &lt;n&gt;</code></p><p>显示程序第 n 行周围的源程序</p></li><li><p><code>list &lt;function&gt;</code></p><p>显示函数名为function的函数的源程序</p></li><li><p><code>list</code></p><p>显示当前行 <strong>后面</strong> 的源程序</p></li><li><p><code>list -</code></p><p>显示当前行 <strong>前面</strong> 的源程序</p></li></ul><p>一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行。当然，你也可以定制显示的范围，使用下面命令可以<strong>设置一次显示源程序的行数</strong>：</p><ul><li><p><code>set listsize &lt;count&gt;</code></p><p>设置一次显示 count 行源代码</p></li><li><p><code>show listsize</code></p><p>查看当前 listsize 的设置</p></li></ul><p><strong>list命令还有下面的用法：</strong></p><ul><li><p><code>list &lt;first&gt;, &lt;last&gt;</code></p><p>显示从 first 行到 last 行之间的源代码</p></li><li><p><code>list ,&lt;last&gt;</code></p><p>显示从当前行到last行之间的源代码</p></li><li><p><code>list +</code></p><p>往后显示源代码</p></li></ul><p><strong>总结一下，一般来说在list后面可以跟以下这些参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;linenum&gt;   行号</span><br><span class="line">&lt;+offset&gt;   当前行号的正偏移量</span><br><span class="line">&lt;-offset&gt;   当前行号的负偏移量</span><br><span class="line">&lt;filename:linenum&gt;  哪个文件的哪一行</span><br><span class="line">&lt;function&gt;  函数名</span><br><span class="line">&lt;filename:function&gt; 哪个文件中的哪个函数</span><br><span class="line">&lt;*address&gt;  程序运行时的语句在内存中的地址</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-搜索源代码"><a href="#3-2-搜索源代码" class="headerlink" title="3.2  搜索源代码"></a>3.2  搜索源代码</h4><p>GDB 提供了以下源代码搜索命令：</p><ul><li><p><code>search &lt;regexp&gt;</code> 或 <code>forward-search &lt;regexp&gt;</code></p><p><strong>往下查找</strong>第一个符合正则表达式 regexp 的行</p></li><li><p><code>reverse-search &lt;regexp&gt;</code></p><p><strong>往上查找</strong>第一个符合正则表达式 regexp 的行</p></li></ul><hr><h4 id="3-3-指定源文件的路径"><a href="#3-3-指定源文件的路径" class="headerlink" title="3.3  指定源文件的路径"></a>3.3  指定源文件的路径</h4><p>某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。</p><ul><li><p><code>directory &lt;dirname ...&gt;</code> 或 <code>dir &lt;dirname ...&gt;</code></p><p>添加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。</p></li><li><p><code>directory</code></p><p>重置源文件路径为默认值（<code>$cdir:$cwd</code> on Unix systems）。需要确认</p></li><li><p><code>show directories</code></p><p>显示定义了的源文件搜索路径</p></li></ul><hr><h3 id="4-在-GDB-中运行程序"><a href="#4-在-GDB-中运行程序" class="headerlink" title="4.  在 GDB 中运行程序"></a>4.  在 GDB 中运行程序</h3><p>当以 <code>gdb &lt;program&gt;</code> 方式启动 gdb 后，运行程序使用 <code>r</code> 或是 <code>run</code> 命令。程序的运行，你有可能需要设置下面四方面的事：</p><ol><li><p>程序运行参数</p><p><code>set args</code> ：可指定运行时参数。（如：<code>set args 10 20 30 40 50</code>）<br><code>show args</code> ：命令可以查看设置好的运行参数。</p></li><li><p>运行环境</p><p><code>path &lt;dir&gt;</code> ：可设定程序的运行路径。<br><code>show paths</code>： 查看程序的运行路径。<br><code>set environment varname [=value]</code>： 设置环境变量。如：<code>set env USER=hchen</code><br><code>show environment [varname]</code> ：查看环境变量。</p></li><li><p>工作目录</p><p><code>cd &lt;dir&gt;</code> ：相当于 shell 的 cd 命令。<br><code>pwd</code>： 显示当前的所在目录。</p></li><li><p>程序的输入输出</p><p><code>info terminal</code>：显示你程序用到的终端的模式。<br><code>run &gt; outfile</code> ：使用重定向控制程序输出。<br><code>tty /dev/ttyb</code>：tty命令可以指定输入输出的终端设备。</p></li></ol><hr><h3 id="5-暂停程序运行"><a href="#5-暂停程序运行" class="headerlink" title="5.  暂停程序运行"></a>5.  暂停程序运行</h3><p>调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变量，以及运行时的流程。</p><p>当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。</p><p>在gdb中，我们可以有以下几种暂停方式：</p><ul><li>断点（BreakPoint）；</li><li>观察点（Watch Point）；</li><li>捕捉点（Catch Point）；</li><li>信号（Signals）；</li><li>线程停止（Thread Stops）。</li></ul><p>如果要恢复程序运行，可以使用 c 或是 continue命令。</p><h4 id="5-1-断点设置"><a href="#5-1-断点设置" class="headerlink" title="5.1  断点设置"></a>5.1  断点设置</h4><p>我们用 break 命令（简写为 b）来设置断点。下面有几点<strong>设置断点的方法</strong>：</p><ul><li><p><code>break &lt;function&gt;</code></p><p>在进入指定函数时停住。C++ 中可以使用 class::function 或 function(type,type) 格式来指定函数名.</p></li><li><p><code>break &lt;linenum&gt;</code></p><p>在指定行号设置断点。</p></li><li><p><code>break +offset</code> 与 <code>break -offset</code></p><p>在当前行号的前面或后面的 offset 行停住。offiset为自然数。</p></li><li><p><code>break filename:linenum</code></p><p>在源文件 filename 的 linenum 行处停住。</p></li><li><p><code>break filename:linenum</code></p><p>在源文件 filename 的 function 函数的入口处停住。</p></li><li><p><code>break *address</code></p><p>在程序运行的内存地址处停住。</p></li><li><p><code>break</code></p><p>break命令没有参数时，表示在下一条指令处停住。</p></li><li><p><code>break ... if &lt;condition&gt;</code></p><p>…可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置break if i==100，表示当i为100时停住程序。</p></li></ul><p><strong>查看断点时，可使用info命令</strong>，如下所示：</p><ul><li><code>info breakpoints [n]</code></li><li><code>info break [n]</code></li></ul><blockquote><p>注：n表示断点号。也可以不加 n，表示显示所有断点。</p><p><strong>断点菜单：</strong></p><p>在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break <function>不能告诉GDB要停在哪个函数的入口。当然，你可以使用break &lt;function(type)&gt;也就是把函数的参数类型告诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的断点。你只要输入你菜单列表中的编号就可以了。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b String::after</span><br><span class="line">[0] cancel</span><br><span class="line">[1] all</span><br><span class="line">[2] file:String.cc; line number:867</span><br><span class="line">[3] file:String.cc; line number:860</span><br><span class="line">[4] file:String.cc; line number:875</span><br><span class="line">[5] file:String.cc; line number:853</span><br><span class="line">[6] file:String.cc; line number:846</span><br><span class="line">[7] file:String.cc; line number:735</span><br><span class="line">&gt; 2 4 6</span><br><span class="line">Breakpoint 1 at 0xb26c: file String.cc, line 867.</span><br><span class="line">Breakpoint 2 at 0xb344: file String.cc, line 875.</span><br><span class="line">Breakpoint 3 at 0xafcc: file String.cc, line 846.</span><br><span class="line">Multiple breakpoints were set.</span><br><span class="line">Use the &quot;delete&quot; command to delete unwanted</span><br><span class="line">breakpoints.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>可见，GDB 列出了所有 after 的重载函数，你可以选一下列表编号就行了。0表示放弃设置断点，1表示所有函数都设置断点。</p></blockquote><hr><h4 id="5-2-观察点设置"><a href="#5-2-观察点设置" class="headerlink" title="5.2  观察点设置"></a>5.2  观察点设置</h4><p>观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。我们有下面的几种方法来<strong>设置观察点</strong>：</p><ul><li><p><code>watch &lt;expr&gt;</code></p><p>为表达式（变量）expr 设置一个观察点。一表达式值有变化时，马上停住程序。</p></li><li><p><code>rwatch &lt;expr&gt;</code></p><p>当表达式（变量）expr被读时，停住程序。</p></li><li><p><code>awatch &lt;expr&gt;</code></p><p>当表达式（变量）的值被读或被写时，停住程序。</p></li><li><p><code>info watchpoints</code></p><p>列出当前所设置的所有观察点。</p></li></ul><hr><h4 id="5-3-捕捉点设置"><a href="#5-3-捕捉点设置" class="headerlink" title="5.3  捕捉点设置"></a>5.3  捕捉点设置</h4><p>你可设置捕捉点来捕捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。用以下格式<strong>设置捕捉点</strong>：</p><ul><li><p><code>catch &lt;event&gt;</code></p><p>当event发生时，停住程序。event可以是下面的内容：</p><ul><li>throw 一个C++抛出的异常。（throw为关键字）</li><li>catch 一个C++捕捉到的异常。（catch为关键字）</li><li>exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）</li><li>fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）</li><li>vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）</li><li>load 或 load <libname> 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX下有用）</li><li>unload 或 unload <libname> 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在HP-UX下有用）</li></ul></li><li><p><code>tcatch &lt;event&gt;</code></p><p>只设置一次捕捉点，当程序停住以後，该点被自动删除。</p></li></ul><hr><h4 id="5-4-维护停止点"><a href="#5-4-维护停止点" class="headerlink" title="5.4  维护停止点"></a>5.4  维护停止点</h4><p>上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你觉得已定义好的停止点没有用了，你可以使用delete、clear、disable、enable这几个命令来进行维护：</p><ul><li><p><code>clear</code></p><p>清除所有的已定义的停止点。</p></li><li><p><code>clear &lt;function&gt;</code> 与 <code>clear &lt;filename:function&gt;</code></p><p>清除所有设置在函数上的停止点。</p></li><li><p><code>clear &lt;linenum&gt;</code> 与 <code>clear &lt;filename:linenum&gt;</code></p><p>清除所有设置在指定行上的停止点。</p></li><li><p><code>delete [breakpoints][range...]</code></p><p>删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为 d。</p></li><li><p><code>disable [breakpoints][range...]</code></p><p>disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis。这是一种比删除更好的方法，在需要时可以通过 enable 再次启用。</p></li><li><p><code>enable [breakpoints][range...]</code></p><p>enable所指定的停止点，breakpoints为停止点号。</p></li><li><p><code>enable [breakpoints] once range...</code></p><p>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。</p></li><li><p><code>enable [breakpoints] delete range...</code></p><p>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。</p></li></ul><hr><h3 id="6-恢复程序运行和单步调试"><a href="#6-恢复程序运行和单步调试" class="headerlink" title="6.  恢复程序运行和单步调试"></a>6.  恢复程序运行和单步调试</h3><p>当程序被停住了，你可以用 continue 命令恢复程序的运行直到程序结束，或下一个断点到来。也可以使用 step或 next 命令单步跟踪程序。</p><ul><li><p><code>continue [ignore-count]</code> 或 <code>c [ignore-count]</code> 或 <code>fg [ignore-count]</code></p><p>恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。</p></li><li><p><code>step &lt;count&gt;</code></p><p>单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p></li><li><p><code>next &lt;count&gt;</code></p><p>同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p></li><li><p><code>set step-mode</code>  或 <code>set step-mode on</code></p><p>打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有 debug 信息而不停住。这个参数很有利于查看机器码。</p></li><li><p><code>set step-mode off</code></p><p>关闭step-mode模式</p></li><li><p><code>finish</code></p><p>运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。</p></li><li><p><code>until</code> 或 <code>u</code></p><p>当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</p></li><li><p><code>stepi</code> 或 <code>si</code> | <code>nexti</code> 或 <code>ni</code></p><p>单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是 “display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</p></li></ul><hr><h3 id="7-查看栈信息"><a href="#7-查看栈信息" class="headerlink" title="7.  查看栈信息"></a>7.  查看栈信息</h3><p>当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。</p><p>下面是一些<strong>查看函数调用栈信息</strong>的 GDB 命令：</p><ul><li><p><code>backtrace</code> 或 <code>bt</code></p><p>打印当前的函数调用栈的所有信息。</p></li><li><p><code>backtrace &lt;n&gt;</code> 或 <code>bt &lt;n&gt;</code></p><p>n是一个正整数，表示只打印栈顶上n层的栈信息。</p></li><li><p><code>backtrace &lt;-n&gt;</code> 或 <code>bt &lt;-n&gt;</code> </p><p>-n表一个负整数，表示只打印栈底下n层的栈信息。</p></li></ul><p>如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是<strong>切换当前栈</strong>：</p><ul><li><p><code>frame &lt;n&gt;</code> 或 <code>f &lt;n&gt;</code></p><p>n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。</p></li><li><p><code>up &lt;n&gt;</code></p><p>表示向栈的上面移动n层，可以不打n，表示向上移动一层。</p></li><li><p><code>down &lt;n&gt;</code></p><p>表示向栈的下面移动n层，可以不打n，表示向下移动一层。</p></li></ul><p><strong>查看当前栈层的信息</strong>，你可以用以下GDB命令：</p><ul><li><p><code>frame</code> 或 <code>f</code></p><p>会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。</p></li><li><p><code>info frame</code> 或 <code>info f</code></p><p>这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。</p></li><li><p><code>info args</code></p><p>打印出当前函数的参数名及其值。</p></li><li><p><code>info locals</code></p><p>打印出当前函数中所有局部变量及其值。</p></li><li><p><code>info catch</code></p><p>打印出当前的函数中的异常处理信息。</p></li></ul><hr><h3 id="8-查看运行时数据"><a href="#8-查看运行时数据" class="headerlink" title="8.  查看运行时数据"></a>8.  查看运行时数据</h3><p>在你调试程序时，当程序被停住时，你可以使用 print 命令（简写命令为p），或是同义命令 inspect 来查看当前程序的运行数据。print 命令的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print &lt;expr&gt;</span><br><span class="line">print &#x2F;&lt;f&gt; &lt;expr&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;expr&gt;</code> 是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），<code>&lt;f&gt;</code> 是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是 <code>/x</code>。</p><h4 id="8-1-程序变量"><a href="#8-1-程序变量" class="headerlink" title="8.1  程序变量"></a>8.1  程序变量</h4><p>在GDB中，你可以随时查看以下三种变量的值：</p><ol><li>全局变量（所有文件可见的）</li><li>静态全局变量（当前文件可见的）</li><li>局部变量（当前Scope可见的）</li></ol><p>如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用 print 显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用 “::” 操作符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print  file::variable</span><br><span class="line">print  function::variable</span><br></pre></td></tr></table></figure><hr><h4 id="8-2-自动显示"><a href="#8-2-自动显示" class="headerlink" title="8.2  自动显示"></a>8.2  自动显示</h4><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是 display：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display &lt;expr&gt;</span><br><span class="line">display&#x2F;&lt;fmt&gt; &lt;expr&gt;</span><br><span class="line">display&#x2F;&lt;fmt&gt; &lt;addr&gt;</span><br></pre></td></tr></table></figure><p>expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</p><p>下面是一些和display相关的GDB命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undisplay &lt;dnums...&gt;</span><br><span class="line">delete display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><p>删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable display &lt;dnums...&gt;</span><br><span class="line">enable display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><p>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info display</span><br></pre></td></tr></table></figure><p>查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当前调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。</p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文内容是我个人觉得在使用 gdb 时经常会用到的一些东西，根据以下参考链接中的内容整理而来，如需更全面的内容请查看参考链接。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sourceware.org/gdb/onlinedocs/gdb/&quot;&gt;Debugging with GDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F#.E6.98.BE.E7.A4.BA.E6.BA.90.E4.BB.A3.E7.A0.81&quot;&gt;用GDB调试程序&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://caohuilong.github.io/categories/Linux/"/>
    
    
    <category term="GDB" scheme="http://caohuilong.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>给新 Git 账户添加 ssh-key</title>
    <link href="http://caohuilong.github.io/2019/02/21/%E7%BB%99%E6%96%B0git%E8%B4%A6%E6%88%B7%E6%B7%BB%E5%8A%A0ssh-key/"/>
    <id>http://caohuilong.github.io/2019/02/21/%E7%BB%99%E6%96%B0git%E8%B4%A6%E6%88%B7%E6%B7%BB%E5%8A%A0ssh-key/</id>
    <published>2019-02-21T09:02:23.000Z</published>
    <updated>2019-02-21T09:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用 git 的时候，git 与远程服务器一般通过 https 进行传输，这种传输方式在每次 push 和 pull 时都需要输入账户和密码，比较麻烦。所以更好的方法是通过 ssh 进行传输，这需要在本机上创建 ssh-key 密钥对，并把其中的公钥添加到远程的 Git 服务器中。但有时又会使用到多个 git 账户登录不同的 git 服务器，所以就涉及到添加 ssh-key 密钥对了。</p><a id="more"></a><p>我的环境中最初是针对 GitHub 的账户设置了 ssh 的密钥对，然后我现在需要针对另一个 git 账户进行设置密钥对，比如牛客网的 git 服务器。</p><h2 id="添加操作过程"><a href="#添加操作过程" class="headerlink" title="添加操作过程"></a>添加操作过程</h2><p><strong>1. 新建 SSH key：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxx@email.com&quot;</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;chl&#x2F;.ssh&#x2F;id_rsa): id_rsa_nowcoder</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in id_rsa_nowcoder.</span><br><span class="line">Your public key has been saved in id_rsa_nowcoder.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:hjOHuHTiXqCjTPCBf81owybsdflq&#x2F;HVWcq4jBZjnCNs xxx@email.com</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|   . o           |</span><br><span class="line">|o   Oo o         |</span><br><span class="line">|&#x3D;...oBoo         |</span><br><span class="line">| &#x3D;.+*+O.S o      |</span><br><span class="line">|+.o&#x3D;EB.&#x3D;.&#x3D;       |</span><br><span class="line">|o.* +.o .o .     |</span><br><span class="line">|.o + o.o.        |</span><br><span class="line">|o.  o  ...       |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><blockquote><p>上面设置名称为 id_rsa_nowcoder</p></blockquote><p><strong>2. 新秘钥添加到 SSH agent 中</strong></p><p>因为默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将其添加到 SSH agent 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa_nowcoder</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><p>但是出现了 Could not open a connection to your authentication agent. 的错误，用一下方法解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa_nowcoder</span><br><span class="line">Identity added: ~&#x2F;.ssh&#x2F;id_rsa_nowcoder (~&#x2F;.ssh&#x2F;id_rsa_nowcoder)</span><br></pre></td></tr></table></figure><p><strong>3. 在 git 账户中添加 SSH key</strong></p><p>登录 git 账户中添加，完成之后，SSH key 就生效了。检测方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone 你的仓库ssh地址</span><br></pre></td></tr></table></figure><p>若这时不再询问密码，说明设置生效。</p><p><strong>4. 更改远程仓库地址</strong></p><ul><li><p>修改命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin 你的仓库ssh地址</span><br></pre></td></tr></table></figure></li><li><p>或者先删后加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm origin</span><br><span class="line">$ git remote add origin 你的仓库ssh地址</span><br></pre></td></tr></table></figure></li><li><p>或者修改 config 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e</span><br><span class="line">修改 url</span><br></pre></td></tr></table></figure><p>更改完成之后，再通过 git push 或 git pull 就不需要输入账号和密码了。</p></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用 git 的时候，git 与远程服务器一般通过 https 进行传输，这种传输方式在每次 push 和 pull 时都需要输入账户和密码，比较麻烦。所以更好的方法是通过 ssh 进行传输，这需要在本机上创建 ssh-key 密钥对，并把其中的公钥添加到远程的 Git 服务器中。但有时又会使用到多个 git 账户登录不同的 git 服务器，所以就涉及到添加 ssh-key 密钥对了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://caohuilong.github.io/categories/Linux/"/>
    
    
    <category term="Git" scheme="http://caohuilong.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>基于 v2ray 实现科学上网</title>
    <link href="http://caohuilong.github.io/2019/02/15/v2ray%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://caohuilong.github.io/2019/02/15/v2ray%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</id>
    <published>2019-02-15T09:21:06.000Z</published>
    <updated>2019-02-15T09:21:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本在 vultr 上面购买的 VPS 上面搭建的 VPN 不能用了，具体原因就是 GTW 经过一波加强，可以通过 TCP 阻断来封锁一些用于搭建 VPN 的 VPS。TCP 阻断的结果就是在国内无法通过 tcp 来连接访问国外的 vps，从而在国内无法 ssh 登录 vps，但是使用 ping 工具却能 ping 通被 tcp 阻断的服务器，因为 ping 是基于 ICMP 的。这样给人一种 vps 没被封的错觉。</p><a id="more"></a><p>当 vps 被 TCP 阻断时，原本基于 shadowsocks 的科学上网方式就不能使用了，本文就是针对被 TCP 阻断的 vps，通过 v2ray 来实现科学上网。当然对于没有被 TCP 阻断的 vps 使用该方法来搭梯子也不容易被封。</p><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="1-服务器安装"><a href="#1-服务器安装" class="headerlink" title="1. 服务器安装"></a>1. 服务器安装</h3><p>在 Linux 操作系统， V2Ray 的安装有脚本安装、手动安装、编译安装 3 种方式，选择其中一种即可，本指南仅提供使用使用脚本安装的方法，并仅推荐使用脚本安装，该脚本由 V2Ray 官方提供。该脚本仅可以在 Debian 系列或者支持 Systemd 的 Linux 操作系统使用。 </p><p>本文基于 CentOS 7 服务器来实现。</p><p>首先下载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># wget https:&#x2F;&#x2F;install.direct&#x2F;go.sh</span><br><span class="line">--2019-02-15 07:53:34--  https:&#x2F;&#x2F;install.direct&#x2F;go.sh</span><br><span class="line">Resolving install.direct (install.direct)... 104.27.174.71, 104.27.175.71, 2606:4700:30::681b:af47, ...</span><br><span class="line">Connecting to install.direct (install.direct)|104.27.174.71|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [text&#x2F;plain]</span><br><span class="line">Saving to: ‘go.sh’</span><br><span class="line"></span><br><span class="line">    [ &lt;&#x3D;&gt;                                                                                                               ] 13,915      --.-K&#x2F;s   in 0s      </span><br><span class="line"></span><br><span class="line">2019-02-15 07:53:34 (58.3 MB&#x2F;s) - ‘go.sh’ saved [13915]</span><br></pre></td></tr></table></figure><p>然后执行安装脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># sudo bash go.sh</span><br><span class="line">Installing V2Ray v4.16.0 on x86_64</span><br><span class="line">Downloading V2Ray: https:&#x2F;&#x2F;github.com&#x2F;v2ray&#x2F;v2ray-core&#x2F;releases&#x2F;download&#x2F;v4.16.0&#x2F;v2ray-linux-64.zip</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   608    0   608    0     0   1330      0 --:--:-- --:--:-- --:--:--  1333</span><br><span class="line">100 10.2M  100 10.2M    0     0  1723k      0  0:00:06  0:00:06 --:--:-- 2356k</span><br><span class="line">Updating software repo</span><br><span class="line">http:&#x2F;&#x2F;mirrors.syringanetworks.net&#x2F;fedora-epel&#x2F;7&#x2F;x86_64&#x2F;repodata&#x2F;5a7d69681e5cfd3ae41829a733077e717b512d3dee2d802edeeb206b7d8bda33-updateinfo.xml.bz2: [Errno 14] HTTP Error 404 - Not Found</span><br><span class="line">Trying other mirror.</span><br><span class="line">To address this issue please refer to the below wiki article </span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;wiki.centos.org&#x2F;yum-errors</span><br><span class="line"></span><br><span class="line">If above article doesn&#39;t help to resolve this issue please use https:&#x2F;&#x2F;bugs.centos.org&#x2F;.</span><br><span class="line"></span><br><span class="line">Installing unzip</span><br><span class="line">Extracting V2Ray package to &#x2F;tmp&#x2F;v2ray.</span><br><span class="line">Archive:  &#x2F;tmp&#x2F;v2ray&#x2F;v2ray.zip</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;config.json  </span><br><span class="line">   creating: &#x2F;tmp&#x2F;v2ray&#x2F;doc&#x2F;</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;doc&#x2F;readme.md  </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;geoip.dat    </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;geosite.dat  </span><br><span class="line">   creating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;v2ray.service  </span><br><span class="line">   creating: &#x2F;tmp&#x2F;v2ray&#x2F;systemv&#x2F;</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;systemv&#x2F;v2ray  </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;v2ctl        </span><br><span class="line"> extracting: &#x2F;tmp&#x2F;v2ray&#x2F;v2ctl.sig    </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;v2ray        </span><br><span class="line"> extracting: &#x2F;tmp&#x2F;v2ray&#x2F;v2ray.sig    </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;vpoint_socks_vmess.json  </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;vpoint_vmess_freedom.json  </span><br><span class="line">PORT:40827</span><br><span class="line">UUID:505f001d-4aa8-4519-9c54-6b65749ee3fb</span><br><span class="line">Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;v2ray.service to &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;v2ray.service.</span><br><span class="line">V2Ray v4.16.0 is installed.</span><br></pre></td></tr></table></figure><p>看到类似于这样的提示就算安装成功了。如果安装不成功脚本会有红色的提示语句，这个时候你应当按照提示除错，除错后再重新执行一遍脚本安装 V2Ray。 </p><p>在上面的提示中，有一行 “PORT:40827” 代表着端口号为 40827，还有一行 “UUID:505f001d-4aa8-4519-9c54-6b65749ee3fb” 代表着 id 为 505f001d-4aa8-4519-9c54-6b65749ee3fb。这两个都是随机生成的，不用担心跟别人撞上了。 </p><p>安装完之后，使用以下命令启动 V2Ray：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start v2ray</span><br></pre></td></tr></table></figure><p>在首次安装完成之后，V2Ray 不会自动启动，需要手动运行上述启动命令。 </p><hr><h3 id="2-服务端配置"><a href="#2-服务端配置" class="headerlink" title="2. 服务端配置"></a>2. 服务端配置</h3><p>v2ray 的配置文件位于 <code>/etc/v2ray/config.json</code>。v2ray 相对于 shadowsocks 更复杂的地方就在于其有众多的配置选项，针对不同的应用场景有不同的配置方案，从而实现不同的功能，而 shadowsocks 则相对傻瓜一些。要详细讲述 v2ray 的所有配置选项是需要很长的内容的，本文针对被 TCP 阻断的 VPS 来实现 vpn 的场景。下面简单介绍一些配置内容：</p><ul><li><p><strong>VMess</strong></p><p>VMess 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，如同 Shadowsocks 一样为了对抗墙的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。 </p><p>V2Ray 使用 inbound(传入) 和 outbound(传出) 的结构，这样的结构非常清晰地体现了数据包的流动方向，同时也使得 V2Ray 功能强大复杂的同时而不混乱，清晰明了。形象地说，我们可以把 V2Ray 当作一个盒子，这个盒子有入口和出口(即 inbound 和 outbound)，我们将数据包通过某个入口放进这个盒子里，然后这个盒子以某种机制（这个机制其实就是路由，后面会讲到）决定这个数据包从哪个出口吐出来。以这样的角度理解的话，V2Ray 做客户端，则 inbound 接收来自浏览器数据，由 outbound 发出去(通常是发到 V2Ray 服务器)；V2Ray 做服务器，则 inbound 接收来自 V2Ray 客户端的数据，由 outbound 发出去(通常是如 Google 等想要访问的目标网站)。 </p></li><li><p><strong>mKCP</strong></p><p>V2Ray 引入了 KCP 传输协议，并且做了一些不同的优化，称为 mKCP。 mKCP 使用 UDP 来模拟 TCP 连接，这样即使 vps 被 TCP 阻断了，还是能够通过 UDP 来连接。mKCP 牺牲带宽来降低延迟，传输同样的内容，mKCP 一般比 TCP 消耗更多的流量，但是对于我购买的 vps 流量一般都用的很少，每个月用不完 十分之一，所以采用 mKCP 对流量消耗也没有太大的问题。</p></li></ul><p>服务端采用 <code>vmess + mKCP</code> 的配置时，配置文件 <code>/etc/v2ray/config.json</code> 的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;port&quot;: 40827,</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;clients&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;id&quot;: &quot;505f001d-4aa8-4519-9c54-6b65749ee3fb&quot;,</span><br><span class="line">            &quot;alterId&quot;: 64</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;mkcp&quot;,</span><br><span class="line">        &quot;kcpSettings&quot;: &#123;</span><br><span class="line">          &quot;uplinkCapacity&quot;: 5,</span><br><span class="line">          &quot;downlinkCapacity&quot;: 100,</span><br><span class="line">          &quot;congestion&quot;: true,</span><br><span class="line">          &quot;header&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;none&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完配置文件后，需要重新启动 v2ray：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl restart v2ray</span><br></pre></td></tr></table></figure><p>最后，还需要修改 vps 的防火墙设置，将对应的 udp 端口放行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --zone&#x3D;public --add-port&#x3D;40827&#x2F;udp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>再设置 v2ray 开机自启动，修改 <code>/etc/rc.local</code> 文件，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart v2ray</span><br></pre></td></tr></table></figure><p>服务端配置完毕。</p><hr><h3 id="3-客户端安装"><a href="#3-客户端安装" class="headerlink" title="3. 客户端安装"></a>3. 客户端安装</h3><p>下载客户端，windows 系统下有两种客户端，一种是不带图形界面的，另一种是在其基础上增加了图形界面的。为了方便，使用带有图形界面的版本。下载连接：<a href="https://github.com/2dust/v2rayN/releases">v2rayN</a>，下载 Lastest release 的 <code>v2rayN.zip</code> 压缩包。</p><p>解压后运行 <code>v2rayN.exe</code> 程序，双击任务栏图标打开界面：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/v2rayN%E7%95%8C%E9%9D%A2.png?raw=true" alt="v2rayN界面"></p><p>点击上方<strong>检查更新</strong>，<strong>检查更新 v2rayCore</strong>，点击“是”。</p><p>更新完后，点击<strong>服务器</strong>，<strong>添加[VMess]服务器</strong>，如下配置：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/vmess%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE.png?raw=true" alt="vmess服务器配置"></p><p>配置完成点击确定，右键任务栏 v2rayN 图标，点击<strong>启用http代理</strong>，http 代理模式可选择 <strong>PAC模式</strong> 或者 <strong>全局模式</strong>。</p><p>这样，客户端的配置也完成，即可开始科学上网。</p><hr><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><ol><li><p><strong>非图形界面客户端配置：</strong></p><p>如果客户端没有使用带有图形界面的 v2rayN，其配置稍微复杂一点，需要自己修改客户端配置文件 <code>config.json</code>，配置内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;port&quot;: 1080,</span><br><span class="line">      &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">      &quot;sniffing&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: true,</span><br><span class="line">        &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;auth&quot;: &quot;noauth&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;vnext&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;address&quot;: &quot;xxx.xxx.xxx.xxx&quot;,</span><br><span class="line">            &quot;port&quot;: 40827,</span><br><span class="line">            &quot;users&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;id&quot;: &quot;505f001d-4aa8-4519-9c54-6b65749ee3fb&quot;,</span><br><span class="line">                &quot;alterId&quot;: 64</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;mkcp&quot;,</span><br><span class="line">        &quot;kcpSettings&quot;: &#123;</span><br><span class="line">          &quot;uplinkCapacity&quot;: 5,</span><br><span class="line">          &quot;downlinkCapacity&quot;: 100,</span><br><span class="line">          &quot;congestion&quot;: true,</span><br><span class="line">          &quot;header&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;none&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完 v2ray 并启动之后，还需要配合浏览器的一些代理插件来实现科学上网，如谷歌浏览器与火狐浏览器的 <code>SwitchyOmega</code> 插件，如何使用这里不介绍。</p></li><li><p><strong>参考链接</strong></p><p>v2ray 配置指南：<a href="https://toutyrater.github.io/">https://toutyrater.github.io</a></p><p>v2ray配置模板：<a href="https://github.com/KiriKira/vTemplate">https://github.com/KiriKira/vTemplate</a></p></li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原本在 vultr 上面购买的 VPS 上面搭建的 VPN 不能用了，具体原因就是 GTW 经过一波加强，可以通过 TCP 阻断来封锁一些用于搭建 VPN 的 VPS。TCP 阻断的结果就是在国内无法通过 tcp 来连接访问国外的 vps，从而在国内无法 ssh 登录 vps，但是使用 ping 工具却能 ping 通被 tcp 阻断的服务器，因为 ping 是基于 ICMP 的。这样给人一种 vps 没被封的错觉。&lt;/p&gt;</summary>
    
    
    
    <category term="VPN" scheme="http://caohuilong.github.io/categories/VPN/"/>
    
    
    <category term="v2ray" scheme="http://caohuilong.github.io/tags/v2ray/"/>
    
  </entry>
  
  <entry>
    <title>孤儿进程与僵尸进程</title>
    <link href="http://caohuilong.github.io/2018/12/26/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <id>http://caohuilong.github.io/2018/12/26/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</id>
    <published>2018-12-26T09:10:45.000Z</published>
    <updated>2018-12-26T09:10:45.000Z</updated>
    
    <content type="html"><![CDATA[<p>本文主要内容包括：</p><ul><li>产生孤儿进程、僵尸进程的条件；</li><li>通过程序来产生孤儿进程与僵尸进程。</li></ul><a id="more"></a><hr><h3 id="孤儿进程与僵尸进程的产生条件"><a href="#孤儿进程与僵尸进程的产生条件" class="headerlink" title="孤儿进程与僵尸进程的产生条件"></a>孤儿进程与僵尸进程的产生条件</h3><p>在 UNIX/Linux 中，正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。于是就产生了孤儿进程和僵尸进程。</p><ul><li><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么那些子进程将会成为孤儿进程。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</li><li><strong>僵尸进程</strong>：是指一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称为僵尸进程。当一个进程完成它的工作终止之后，它的父进程需要调用 wait() 或 waitpid() 系统调用取得子进程的终止状态。</li></ul><p>可以这样理解孤儿进程和僵尸进程的区别：孤儿进程是父进程已退出，而子进程未退出；僵尸进程是父进程未退出，而子进程已退出。他们的共同点：都是子进程处于这两种状态。</p><hr><h3 id="通过程序产生孤儿进程与僵尸进程"><a href="#通过程序产生孤儿进程与僵尸进程" class="headerlink" title="通过程序产生孤儿进程与僵尸进程"></a>通过程序产生孤儿进程与僵尸进程</h3><p>下面通过程序来具体展示如何产生孤儿进程与僵尸进程，并且说明如何在 Linux 系统中检测这些处于非正常状态的进程。</p><h4 id="产生一个孤儿进程："><a href="#产生一个孤儿进程：" class="headerlink" title="产生一个孤儿进程："></a>产生一个孤儿进程：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;    <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent, PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Child PID: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;  <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child,  PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Parent PID: &quot;</span> &lt;&lt; getppid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># .&#x2F;a.out</span><br><span class="line">Parent, PID: 16911 Child PID: 16912</span><br><span class="line">Child,  PID: 16912 Parent PID: 1</span><br></pre></td></tr></table></figure><p>可以看到，子进程中输出的父进程ID是 1，而不是 16911。这就是因为在子进程睡眠的时间内，父进程运行结束并退出了，子进程称为了一个孤儿进程，并且被 init 进程收养，所以子进程的父进程ID就是 init 进程的进程ID了。</p><p>或者比较快地（睡眠时间结束前）在另一个终端上面使用 ps 命令可以显示出 PID 为 16912 的进程的 PPID 是 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef |egrep &#39;(a.out|PID)&#39; |grep -v grep</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">chl      16912     1  0 16:17 pts&#x2F;18   00:00:00 &#x2F;tmp&#x2F;a.out</span><br></pre></td></tr></table></figure><blockquote><p>以上用了支持扩展正则表达式的 egrep 命令来过滤输出，以同时输出标题行。并且使用 grep -v 来反向选择了 grep，使得不输出包含 grep 的行。</p></blockquote><hr><h4 id="产生一个僵尸进程："><a href="#产生一个僵尸进程：" class="headerlink" title="产生一个僵尸进程："></a>产生一个僵尸进程：</h4><p>还是和上面类似的进程，不过是需要使父进程进入睡眠：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent, PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Child PID: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child,  PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Parent PID: &quot;</span> &lt;&lt; getppid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent, PID: 17135 Child PID: 17136</span><br><span class="line">Child,  PID: 17136 Parent PID: 17135</span><br></pre></td></tr></table></figure><p>以上程序中，子进程会比父进程先运行完并退出，但是父进程并没有采用其他的手段来获取子进程的状态消息并回收子进程的进程描述符，所以子进程变成了一个僵尸进程。</p><p>既可以通过 top 命令来检测当前系统的运行环境中存在僵尸进程，但是无法查看具体的信息。也可以通过 ps 命令来查看状态为 Z 的进程即为僵尸进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux |grep Z |grep -v grep</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">chl      17136  0.0  0.0      0     0 pts&#x2F;18   Z+   16:36   0:00 [a.out] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><p>可以看到 PID 为 17136 的进程的状态 STAT 为 Z+，由此就创建了一个僵尸进程。但是在父进程结束睡眠并退出之后，如果再次使用上述的 ps 命令查看的话，会发现该僵尸进程消失了，这是因为：父进程退出后，这个僵尸进程就成为孤儿进程，过继给了 init 进程，而 init 进程会周期性地调用 wait 系统调用来清除各个僵尸的子进程。</p><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;本文主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产生孤儿进程、僵尸进程的条件；&lt;/li&gt;
&lt;li&gt;通过程序来产生孤儿进程与僵尸进程。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://caohuilong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="孤儿进程" scheme="http://caohuilong.github.io/tags/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="僵尸进程" scheme="http://caohuilong.github.io/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>kubeadm join success but node not joined</title>
    <link href="http://caohuilong.github.io/2018/12/18/kubernetes-node-not-joined/"/>
    <id>http://caohuilong.github.io/2018/12/18/kubernetes-node-not-joined/</id>
    <published>2018-12-18T08:07:53.000Z</published>
    <updated>2018-12-18T08:07:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在搭建 Kubernetes 集群时，遇到这样一个问题，就是在 node 节点上使用 kubeadm join 时能够成功的加入节点，但是在 master 节点上却无法查看集群中的 node 节点。如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">node1$ sudo kubeadm join --token 1bc310.cb323487a828849e 10.2.7.114:6443 --discovery-token-ca-cert-hash sha256:3d39f8fe34a043ccef4821014fd6d3e0f222614d37d59a6e4944c74f257c6d4d</span><br><span class="line">[preflight] Running pre-flight checks.</span><br><span class="line">[WARNING FileExisting-crictl]: crictl not found in system path</span><br><span class="line">[discovery] Trying to connect to API Server &quot;10.2.7.114:6443&quot;</span><br><span class="line">[discovery] Created cluster-info discovery client, requesting info from &quot;https:&#x2F;&#x2F;10.2.7.114:6443&quot;</span><br><span class="line">[discovery] Requesting info from &quot;https:&#x2F;&#x2F;10.2.7.114:6443&quot; again to validate TLS against the pinned public key</span><br><span class="line">[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server &quot;10.2.7.114:6443&quot;</span><br><span class="line">[discovery] Successfully established connection with API Server &quot;10.2.7.114:6443&quot;</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to master and a response</span><br><span class="line">  was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#39;kubectl get nodes&#39; on the master to see this node join the cluster.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master$ kubectl get nodes</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">ubuntu    Ready     master    4h        v1.9.1</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>出现这个问题的原因是 node 节点的主机名与 master 节点的相同，因此需要给 所有的 node 节点取与 master 节点不同的主机名。</p><p>修改 <code>/etc/hostname</code> 以及 <code>/etc/hosts</code> 文件中的主机名，再通过命令临时设置主机名：<code>sudo hostname 主机名</code>。</p><p>配置完之后，在 node 节点上执行 <code>kubeadm reset</code>， 再重新执行 <code>kubeadm join</code> 。</p><p>最后在 master 节点上查看节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">node1     Ready     &lt;none&gt;    1h        v1.9.1</span><br><span class="line">node2     Ready     &lt;none&gt;    1h        v1.9.1</span><br><span class="line">ubuntu    Ready     master    6h        v1.9.1</span><br></pre></td></tr></table></figure><p>可以看到有两个 node 节点。</p><p>参考：<a href="https://github.com/kubernetes/kubernetes/issues/61224">issue 61224</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在搭建 Kubernetes 集群时，遇到这样一个问题，就是在 node 节点上使用 kubeadm join 时能够成功的加入节点，但是在 master 节点上却无法查看集群中的 node 节点。如下：&lt;/p&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="http://caohuilong.github.io/categories/Kubernetes/"/>
    
    
    <category term="Bugs" scheme="http://caohuilong.github.io/tags/Bugs/"/>
    
    <category term="kubeadm" scheme="http://caohuilong.github.io/tags/kubeadm/"/>
    
  </entry>
  
  <entry>
    <title>解决 VPN 无法打开谷歌学术的问题</title>
    <link href="http://caohuilong.github.io/2018/12/17/%E8%A7%A3%E5%86%B3vpn%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://caohuilong.github.io/2018/12/17/%E8%A7%A3%E5%86%B3vpn%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2018-12-17T14:14:16.000Z</published>
    <updated>2018-12-17T14:14:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>之前搭好的 VPN 用的好好的，最近两天突然不能登录谷歌学术（Google Scholar），但是还能使用谷歌搜索等其他国外的网站。登录谷歌学术网站出现：<code>We&#39;re sorry...... but your computer or network may be sending automated queries. To protect our users, we can&#39;t process your request right now.</code></p><a id="more"></a><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/google%20scholar%20error.png?raw=true"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现这个问题是因为我使用的是 Vultr 的 VPS 来搭建 shadowsocks 服务端，而且有很多人都在这些 VPS 服务商（Vultr，搬瓦工，DigitalOcean，Linode等等），然后有人使用这些公网的 IP 段来做爬虫，所以 Google 把这些公网 IP 给封了。但是一般封的都是 IPv4 的地址，IPv6 的地址一般没有被封，所以可以考虑使用 IPv6 来访问谷歌学术的网站。</p><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>首先，找到最新的 Google IPv6 地址，可以在这里查看：<a href="https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts">IPv6-hosts</a></p><p>找到 Google 学术对应的 IPv6 地址后，修改服务器的 hosts 文件，<code>vim /etc/hosts</code>，在文件的最后加入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Scholar 学术搜索</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com.hk</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com.tw</span><br><span class="line">2404:6800:4005:805::200e scholar.google.cn #www.google.cn</span><br></pre></td></tr></table></figure></li><li><p>然后，重启 shadowsocks 服务端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks restart</span><br></pre></td></tr></table></figure><blockquote><p>注：不同的搭建方式可能重启的方式不太一样。我的搭建方式请参考：<a href="https://cao0507.github.io/2018/08/21/VPS%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B6%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/">shadowsocks服务端搭建</a></p></blockquote><p>之后，就能够正常访问谷歌学术的网站了。</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/google%20scholar.png?raw=true"></p></li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>有些时候，到这里可能还是不能正常访问谷歌学术。这个可能是因为 Vultr 上 5 美元的 VPS 默认使用的是 IPv4 的地址，而没有启用 IPv6 的地址，所以需要给你的 VPS 分配一个 IPv6 的地址。</p><p><strong>Server Information</strong> -&gt; <strong>Settings</strong> -&gt; <strong>IPv6</strong>：给你的 Server 分配（assign）一个 IPv6 地址，分配一个 IPv6 地址是不要钱的。这个过程会重启你的 VPS，重启之后，能看到有一个 IPv6 的地址，如下图：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/vps%20assign%20ipv6.png?raw=true"></p><blockquote><p>我一开始就是因为没有给我的 VPS 分配 IPv6 地址，所以修改了服务器的 hosts 文件也还是没有解决这个问题。你在解决问题的时候注意要先分配 IPv6 地址哦！</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;之前搭好的 VPN 用的好好的，最近两天突然不能登录谷歌学术（Google Scholar），但是还能使用谷歌搜索等其他国外的网站。登录谷歌学术网站出现：&lt;code&gt;We&amp;#39;re sorry...... but your computer or network may be sending automated queries. To protect our users, we can&amp;#39;t process your request right now.&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="VPN" scheme="http://caohuilong.github.io/categories/VPN/"/>
    
    
    <category term="shadowsocks" scheme="http://caohuilong.github.io/tags/shadowsocks/"/>
    
    <category term="Bugs" scheme="http://caohuilong.github.io/tags/Bugs/"/>
    
  </entry>
  
  <entry>
    <title>Hyperledger Caliper Disable TLS</title>
    <link href="http://caohuilong.github.io/2018/12/15/fabric-disable-tls/"/>
    <id>http://caohuilong.github.io/2018/12/15/fabric-disable-tls/</id>
    <published>2018-12-15T04:54:14.000Z</published>
    <updated>2018-12-15T04:54:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在使用 Hyperledger Caliper 时，想通过 wireshark 抓包来分析 fabric 运行流程中各阶段的数据信息，但是发现 fabric 节点间的通信使用了传输层安全（Transport Layer Security，TLS）协议，使得通信的报文的内容在抓包后无法分析。因此考虑在测试环境中暂时关闭 TLS，从而能够直接查看报文中承载的数据内容。</p><a id="more"></a><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h4 id="1-在-docker-compose-的配置文件中修改环境变量"><a href="#1-在-docker-compose-的配置文件中修改环境变量" class="headerlink" title="1. 在 docker-compose 的配置文件中修改环境变量"></a>1. 在 docker-compose 的配置文件中修改环境变量</h4><p>本实验是在 Hyperledger Caliper 的测试环境中进行的，Caliper 测试工具在运行初始阶段会调用 docker-compose 启动 fabric 的网络，启动的 fabric 默认启用了 TLS，可以在其 docker-compose 的启动配置文件 docker-compose.yaml 中看到环境变量：</p><ul><li><code>FABRIC_CA_SERVER_TLS_ENABLED=true</code></li><li><code>ORDERER_GENERAL_TLS_ENABLED=true</code></li><li><code>CORE_PEER_TLS_ENABLED=true</code></li></ul><p>以上三个环境变量都设置为 true。如果要 disable TLS，则需在配置文件 docker-compose.yaml 中将这三个环境变量都注释掉，或者将它们设置为 false。即：</p><ul><li><code>FABRIC_CA_SERVER_TLS_ENABLED=false</code></li><li><code>ORDERER_GENERAL_TLS_ENABLED=false</code></li><li><code>CORE_PEER_TLS_ENABLED=false</code></li></ul><h4 id="2-修改-benchmark-中的-fabric-json-文件"><a href="#2-修改-benchmark-中的-fabric-json-文件" class="headerlink" title="2. 修改 benchmark 中的 fabric.json 文件"></a>2. 修改 benchmark 中的 fabric.json 文件</h4><p>在 benchmark 中的每个例子中，如 simple 的网络配置文件 fabric.json 中，client 与 peer 、orderer、ca 等节点都是通过 grpcs 或 https 来通信的，而这是在使用了 TLS 时的通信方式，因此需要将其改为 grpc 或 http 来通信。修改入下：</p><ul><li><code>orderer.url</code>：<code>grpcs://localhost:7050</code>  ==&gt;  <code>grpc://localhost:7050</code></li><li><code>ca.url</code>：<code>https://localhost:7054</code>  ==&gt;  <code>http://localhost:7054</code></li><li><code>peer1.requests</code>：<code>grpcs://localhost:7051</code>   ==&gt;  <code>grpc://localhost:7051</code></li><li><code>peer1.events</code>：<code>grpcs://localhost:7053</code>   ==&gt;   <code>grpc://localhost:7053</code></li></ul><p>其他的都是如此修改。</p><blockquote><p>如果用 vim 编辑器的话，可以快捷的使用全局替换功能，在 normal 模式下输入冒号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,$  s&#x2F;grpcs&#x2F;grpc&#x2F;g       #表示将第一行到最后一行间的所有grpcs替换成grpc</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-错误记录"><a href="#3-错误记录" class="headerlink" title="3. 错误记录"></a>3. 错误记录</h4><p>如果仅仅修改 docker-compose.yaml 文件中的环境变量，没有修改 fabric.json 中的通信方式的话，则在运行测试时会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># create mychannel......</span><br><span class="line">E1215 12:26:25.877864366    9327 ssl_transport_security.cc:989] Handshake failed with fatal error SSL_ERROR_SSL: error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number.</span><br><span class="line">E1215 12:26:25.879670836    9327 ssl_transport_security.cc:989] Handshake failed with fatal error SSL_ERROR_SSL: error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number.</span><br><span class="line">error: [Orderer.js]: sendBroadcast - on error: &quot;Error: 14 UNAVAILABLE: Connect Failed\n    at createStatusError (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:64:15)\n    at ClientDuplexStream._emitStatusIfDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:270:19)\n    at ClientDuplexStream._readsDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:236:8)\n    at readCallback (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:296:12)&quot;</span><br><span class="line">not ok 1 Failed to create channels Error: SERVICE_UNAVAILABLE at ClientDuplexStream.&lt;anonymous&gt; (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Orderer.js:136:21) at emitOne (events.js:116:13) at ClientDuplexStream.emit (events.js:211:7) at ClientDuplexStream._emitStatusIfDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:271:12) at ClientDuplexStream._readsDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:236:8) at readCallback (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:296:12)</span><br><span class="line">  ---</span><br><span class="line">    operator: fail</span><br><span class="line">    at: channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:159:19)</span><br><span class="line">    stack: |-</span><br><span class="line">      Error: Failed to create channels Error: SERVICE_UNAVAILABLE</span><br><span class="line">          at ClientDuplexStream.&lt;anonymous&gt; (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Orderer.js:136:21)</span><br><span class="line">          at emitOne (events.js:116:13)</span><br><span class="line">          at ClientDuplexStream.emit (events.js:211:7)</span><br><span class="line">          at ClientDuplexStream._emitStatusIfDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:271:12)</span><br><span class="line">          at ClientDuplexStream._readsDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:236:8)</span><br><span class="line">          at readCallback (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:296:12)</span><br><span class="line">          at Test.assert [as _assert] (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:224:54)</span><br><span class="line">          at Test.bound [as _assert] (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:76:32)</span><br><span class="line">          at Test.fail (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:317:10)</span><br><span class="line">          at Test.bound [as fail] (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:76:32)</span><br><span class="line">          at channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:159:19)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">  ...</span><br><span class="line">fabric.init() failed, Error: Fabric: Create channel failed</span><br><span class="line">    at channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:160:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">[Transaction Info] - Submitted: 0 Succ: 0 Fail:0 Unfinished:0</span><br><span class="line">unexpected error, Error: Fabric: Create channel failed</span><br><span class="line">    at channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:160:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br></pre></td></tr></table></figure><p>这个问题需要注意。</p><hr><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在 TLS 被开启或关闭两种情况下，能够发现关闭 TLS 后，系统的吞吐率略有提升，这是可想而知的，毕竟减少了一层传输层安全协议的封装。结果图如下：</p><ul><li><p><strong>Enable TLS</strong></p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/enable_tls.png?raw=true"></p></li><li><p><strong>Disable TLS</strong></p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/disable_tls.png?raw=true"></p></li></ul><p>不过以上的结果在实际中的意义并不大，因为在实际应用中肯定需要进行传输层安全协议的封装，不然这区块链的安全从和谈起。</p><p>如下图可以看到关闭 TLS 后，抓包后能够查看数据内容：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/disable-tls%20%E6%8A%93%E5%8C%85%E7%BB%93%E6%9E%9C.png?raw=true"></p><p>太不安全了！所以以上内容均只能应用于测试。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在使用 Hyperledger Caliper 时，想通过 wireshark 抓包来分析 fabric 运行流程中各阶段的数据信息，但是发现 fabric 节点间的通信使用了传输层安全（Transport Layer Security，TLS）协议，使得通信的报文的内容在抓包后无法分析。因此考虑在测试环境中暂时关闭 TLS，从而能够直接查看报文中承载的数据内容。&lt;/p&gt;</summary>
    
    
    
    <category term="区块链" scheme="http://caohuilong.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="Hyperledger fabric" scheme="http://caohuilong.github.io/tags/Hyperledger-fabric/"/>
    
    <category term="Hyperledger caliper" scheme="http://caohuilong.github.io/tags/Hyperledger-caliper/"/>
    
  </entry>
  
  <entry>
    <title>Docker 容器启动时端口映射失败</title>
    <link href="http://caohuilong.github.io/2018/12/05/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5/"/>
    <id>http://caohuilong.github.io/2018/12/05/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5/</id>
    <published>2018-12-05T03:11:44.000Z</published>
    <updated>2018-12-05T03:11:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在一台虚拟机上创建容器时因为端口映射的问题而导致容器启动失败，并提示 <code>docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated. </code></p><a id="more"></a><hr><h4 id="1-错误发现过程"><a href="#1-错误发现过程" class="headerlink" title="1. 错误发现过程"></a>1. 错误发现过程</h4><ul><li><p>通过 docker-compose 启动一个容器是提示无法启动容器，错误原因是 <code>Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f docker-compose-orderer.yaml up -d</span><br><span class="line">Creating orderer.example.com ... error</span><br><span class="line"></span><br><span class="line">ERROR: for orderer.example.com  Cannot start service orderer.example.com: b&#39;driver failed programming external connectivity on endpoint orderer.example.com (b1253c6e3542219f989fb9f6508c738066aeeb2fcdebd1e13b9b85c63c2715dd): Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</span><br><span class="line"></span><br><span class="line">ERROR: for orderer.example.com  Cannot start service orderer.example.com: b&#39;driver failed programming external connectivity on endpoint orderer.example.com (b1253c6e3542219f989fb9f6508c738066aeeb2fcdebd1e13b9b85c63c2715dd): Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</span><br><span class="line">ERROR: Encountered errors while bringing up the project.</span><br></pre></td></tr></table></figure></li><li><p>接着直接使用 docker run 命令启动容器，还是提示一样的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name orderer.example.com -d -p 7050:7050 hyperledger&#x2F;fabric-orderer:x86_64-1.1.0 </span><br><span class="line">07c97104c290f470588bf0cfe041f76771bfc8586b3ad0fe784a20f97c4e4a6f</span><br><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated.</span><br></pre></td></tr></table></figure></li><li><p>查看主机的端口是否被占用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntlp</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address        Foreign Address     State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 0.0.0.0:22           0.0.0.0:*           LISTEN      -               </span><br><span class="line">tcp6       0      0 :::22                :::*                LISTEN      -               </span><br><span class="line">tcp6       0      0 :::2375              :::*                LISTEN      -</span><br></pre></td></tr></table></figure><p>发现并没有 7050 端口并没有在使用。</p></li><li><p>启动另一个容器，绑定主机的另一个端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8050:7050 hyperledger&#x2F;fabric-orderer:x86_64-1.1.0 </span><br><span class="line">fba31d37ff4cc409740ce8cd045f4f4bc6a76f7c69c454a2d7e380327613acb0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                     COMMAND             CREATED              STATUS              PORTS                    NAMES</span><br><span class="line">fba31d37ff4c        hyperledger&#x2F;fabric-orderer:x86_64-1.1.0   &quot;orderer&quot;           8 seconds ago        Up 7 seconds        0.0.0.0:8050-&gt;7050&#x2F;tcp   confident_wescoff</span><br></pre></td></tr></table></figure><p>可以启动。</p></li><li><p>查看 docker 服务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service; enabled; vendor preset: enabled)</span><br><span class="line">  Drop-In: &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d</span><br><span class="line">           └─override.conf</span><br><span class="line">   Active: active (running) since Wed 2018-12-05 09:29:11 CST; 1h 14min ago</span><br><span class="line">     Docs: https:&#x2F;&#x2F;docs.docker.com</span><br><span class="line"> Main PID: 987 (dockerd)</span><br><span class="line">    Tasks: 35</span><br><span class="line">   Memory: 161.2M</span><br><span class="line">      CPU: 54.874s</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;docker.service</span><br><span class="line">           ├─ 987 &#x2F;usr&#x2F;bin&#x2F;dockerd</span><br><span class="line">           └─1089 docker-containerd --config &#x2F;var&#x2F;run&#x2F;docker&#x2F;containerd&#x2F;containerd.toml</span><br></pre></td></tr></table></figure><p>服务显示是正常运行的。</p></li></ul><hr><h4 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h4><p>网上查看了一些方法，可以通过重启 docker 服务来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>真的解决了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name orderer.example.com -d -p 7050:7050 hyperledger&#x2F;fabric-orderer:x86_64-1.1.0 </span><br><span class="line">2f289e5225344e4e07230a0985e9f51f2ef6584af263be28388bdb7f6c80af35</span><br><span class="line"></span><br><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE                                     COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">2f289e522534        hyperledger&#x2F;fabric-orderer:x86_64-1.1.0   &quot;orderer&quot;           7 seconds ago       Up 6 seconds        0.0.0.0:7050-&gt;7050&#x2F;tcp   orderer.example.com</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;在一台虚拟机上创建容器时因为端口映射的问题而导致容器启动失败，并提示 &lt;code&gt;docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated. &lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://caohuilong.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://caohuilong.github.io/tags/Docker/"/>
    
    <category term="Bugs" scheme="http://caohuilong.github.io/tags/Bugs/"/>
    
  </entry>
  
  <entry>
    <title>UNP练习：确定主机字节序</title>
    <link href="http://caohuilong.github.io/2018/11/08/%E7%A1%AE%E5%AE%9A%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    <id>http://caohuilong.github.io/2018/11/08/%E7%A1%AE%E5%AE%9A%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F/</id>
    <published>2018-11-08T06:46:04.000Z</published>
    <updated>2018-11-08T06:46:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="确定主机字节序的程序"><a href="#确定主机字节序的程序" class="headerlink" title="确定主机字节序的程序"></a>确定主机字节序的程序</h3><p>记录 UNP 学习第三章的确定主机字节序的程序，使用 C++ 语言编写。</p><p>程序如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_VENDOR_OS <span class="meta-string">&quot;x86_64-unknown-linux-gnu&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">short</span> s;</span><br><span class="line">        <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">    &#125; un; </span><br><span class="line">    </span><br><span class="line">    un.s = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; CPU_VENDOR_OS &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">sizeof</span>(<span class="keyword">short</span>) == <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( un.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">2</span> ) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;big-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( un.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">1</span> ) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;little-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unknown&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(short) = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的 Ubuntu 16.04 虚拟机上运行上面的程序得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x86_64-unknown-linux-gnu: little-endian</span><br></pre></td></tr></table></figure><p>这说明我的虚拟机在内存中存储数据的字节序是 <strong>小端字节序</strong>。</p><blockquote><p>上面定义的 CPU_VENDOR_OS 宏的值是可在 UNP 随书的源码得到的 config.h 头文件中查看。</p></blockquote><hr><h3 id="大端模式与小端模式理解"><a href="#大端模式与小端模式理解" class="headerlink" title="大端模式与小端模式理解"></a>大端模式与小端模式理解</h3><p>考虑一个 16 位整数，它由 2 个字节组成。内存中存储这两个字节有两种方法：</p><ul><li>一种将低序字节存储在起始地址，这称为 <strong>小端字节序</strong>；</li><li>另一种将高序字节存储在起始地址，这称为 <strong>大端字节序</strong>。</li></ul><p>在上面的程序中，定义了一个联合体变量 un，包含一个短整形变量 s 和一个包含 2 个字符的字符数组 c。首先给 un.s 赋值 0x0102，这样在字符串数组 c 中存放的字符串对应的 ASCII 值为 0x0102 。高序字节为 0x01，低序字节为 0x02 。</p><p><strong>如果系统是小端模式：</strong></p><p>低序字节存储在起始地址，也就是 0x02 存放在数组的起始地址 un.c；高序字节存储在起始地址+1，即 0x01 存放在 un.c+1 中。即有一下等式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">un.c[0] &#x3D;&#x3D; 0x02</span><br><span class="line">un.c[1] &#x3D;&#x3D; 0x01</span><br></pre></td></tr></table></figure><p><strong>如果系统是大端模式：</strong></p><p>高序字节存储在起始地址，也就是 0x01 存放在数组的起始地址 un.c；低序字节存储在起始地址+1，即 0x02 存放在 un.c+1 中。有以下等式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">un.c[0] &#x3D;&#x3D; 0x01</span><br><span class="line">un.c[1] &#x3D;&#x3D; 0x02</span><br></pre></td></tr></table></figure><blockquote><p>对于一个二进制或十六进制的值，如 0x01020304，位于左边的 0x01 字节是高序字节，位于右边 0x04 的是低序字节。</p></blockquote><hr><h3 id="或者用以下更简单的程序来确定："><a href="#或者用以下更简单的程序来确定：" class="headerlink" title="或者用以下更简单的程序来确定："></a>或者用以下更简单的程序来确定：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> val = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) &amp;val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">1</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;big-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="number">2</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;little-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将短整形变量 val 的地址强制转换成字符型指针的地址 p。p 是低地址，(p+1)是高地址。0x01是 val 的高有效字节，0x02是 val 的低有效字节。则有一下两种情况：</p><ul><li><code>*p == 0x01 &amp;&amp; *(p+1) == 0x02</code>：高有效字节存放在低地址，大端模式。</li><li><code>*p == 0x02 &amp;&amp; *(p+1) == 0x01</code>：低有效字节存放在低地址，小端模式。</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;确定主机字节序的程序&quot;&gt;&lt;a href=&quot;#确定主机字节序的程序&quot; class=&quot;headerlink&quot; title=&quot;确定主机字节序的程序&quot;&gt;&lt;/a&gt;确定主机字节序的程序&lt;/h3&gt;&lt;p&gt;记录 UNP 学习第三章的确定主机字节序的程序，使用 C++ 语言编写。&lt;/p&gt;
&lt;p&gt;程序如下：&lt;/p&gt;</summary>
    
    
    
    <category term="UNIX网络编程" scheme="http://caohuilong.github.io/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="大小端模式" scheme="http://caohuilong.github.io/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>socket编程之bind函数</title>
    <link href="http://caohuilong.github.io/2018/11/07/socket%E7%BC%96%E7%A8%8B%E4%B9%8Bbind%E5%87%BD%E6%95%B0/"/>
    <id>http://caohuilong.github.io/2018/11/07/socket%E7%BC%96%E7%A8%8B%E4%B9%8Bbind%E5%87%BD%E6%95%B0/</id>
    <published>2018-11-07T13:41:09.000Z</published>
    <updated>2018-11-07T13:41:09.000Z</updated>
    
    <content type="html"><![CDATA[<p><strong>bind 函数：关联地址和套接字</strong></p><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：若成功，返回 0；若出错，返回 -1.</p><a id="more"></a><h3 id="使用-bind-时遇到的错误"><a href="#使用-bind-时遇到的错误" class="headerlink" title="使用 bind 时遇到的错误"></a>使用 bind 时遇到的错误</h3><p>在练习 UNP 代码 daytimetcpsrv.c 时遇到两个问题：</p><ol><li><p><strong>Permission denied</strong></p><p>这是因为地址中的端口号必须不小于 1024，除非该进程具有相应的特权（即 root 用户）。</p></li><li><p><strong>Address already in use</strong></p><p>这个问题有时会让人很疑问，明明已经结束了使用对应端口的进程，端口应该不是 <code>in use</code> 的啊，但却无法再次调用 bind 函数来绑定该端口到一个套接字端点（bind 函数返回 <code>EADDRINUSE</code>）。其实这是由 TCP 套接字状态 <code>TIME_WAIT</code> 引起的，该状态在套接字关闭后约保留 2 到 4 分钟，因此无法再次绑定刚刚使用的端口。在 <code>TIME_WAIT</code> 状态退出之后，套接字被删除，该地址才能被重新绑定而不出问题。</p><p>可以通过 netstat -ant 来查看这个端口还处于 <code>TIME_WAIT</code> 状态：</p><p>等待 <code>TIME_WAIT</code> 结束可能是令人恼火的一件事，特别是如果您正在开发一个套接字服务器，就需要停止服务器来做一些改动，然后重启。幸运的是，有方法可以避开 <code>TIME_WAIT</code> 状态。可以给套接字应用 <code>SO_REUSEADDR</code> 套接字选项，以便端口可以马上重用。</p><p>对于 daytimetcpsrv.c，可以加上以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse)) &lt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  perror(<span class="string">&quot;setsockopet error\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>重新编译运行。</p></li></ol><h3 id="关于-TIME-WAIT-状态"><a href="#关于-TIME-WAIT-状态" class="headerlink" title="关于 TIME_WAIT 状态"></a>关于 TIME_WAIT 状态</h3><p>TCP 设计中之所以要让一个旧的连接处于 TIME_WAIT 状态是因为要防止旧连接的老的重复分组出现在新连接中。拿 UNP 上面的例子来说：</p><p>假设在 12.106.32.245 的端口 1500 和 206.168.112.219 的端口 21 之间有一个 TCP 连接。当我们关闭这个连接后，很快又重新建立一条相同 IP 和端口的 TCP 连接。在这种情况下，假如旧连接在网络中还存在没有被丢弃的重复分组，而且重复分组又出现在了新连接中了，TCP 将无法正确处理这个分组。为了防止这种情况的发生，TCP 将刚关闭的连接置于 TIME_WAIT 状态，不允许给处于该状态的连接启动新的化身，持续时间是 2MSL，如此将能保证该连接的老的重复分组都已在网络中消逝。</p><blockquote><p>注：是主动执行关闭 TCP 连接的那端将处于 TIME_WAIT 状态。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;p&gt;&lt;strong&gt;bind 函数：关联地址和套接字&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;定义：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sockfd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; struct sockaddr *addr, &lt;span class=&quot;keyword&quot;&gt;socklen_t&lt;/span&gt; len)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值：若成功，返回 0；若出错，返回 -1.&lt;/p&gt;</summary>
    
    
    
    <category term="UNIX网络编程" scheme="http://caohuilong.github.io/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="bind" scheme="http://caohuilong.github.io/tags/bind/"/>
    
  </entry>
  
</feed>
