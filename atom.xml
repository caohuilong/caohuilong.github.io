<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>WooOh&#39;s blog</title>
  
  <subtitle>愿所有的等待，终能遇见幸福</subtitle>
  <link href="http://caohuilong.github.io/atom.xml" rel="self"/>
  
  <link href="http://caohuilong.github.io/"/>
  <updated>2021-02-08T08:24:46.383Z</updated>
  <id>http://caohuilong.github.io/</id>
  
  <author>
    <name>WooOh</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Hello World</title>
    <link href="http://caohuilong.github.io/2021/02/08/hello-world/"/>
    <id>http://caohuilong.github.io/2021/02/08/hello-world/</id>
    <published>2021-02-08T08:24:46.383Z</published>
    <updated>2021-02-08T08:24:46.383Z</updated>
    
    <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p><a id="more"></a><h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p><h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p><h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p><h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure><p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>]]></content>
    
    
    <summary type="html">&lt;p&gt;Welcome to &lt;a href=&quot;https://hexo.io/&quot;&gt;Hexo&lt;/a&gt;! This is your very first post. Check &lt;a href=&quot;https://hexo.io/docs/&quot;&gt;documentation&lt;/a&gt; for more info. If you get any problems when using Hexo, you can find the answer in &lt;a href=&quot;https://hexo.io/docs/troubleshooting.html&quot;&gt;troubleshooting&lt;/a&gt; or you can ask me on &lt;a href=&quot;https://github.com/hexojs/hexo/issues&quot;&gt;GitHub&lt;/a&gt;.&lt;/p&gt;</summary>
    
    
    
    
  </entry>
  
  <entry>
    <title>二分查找算法总结</title>
    <link href="http://caohuilong.github.io/2019/04/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://caohuilong.github.io/2019/04/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-04-01T05:51:32.000Z</published>
    <updated>2019-04-01T05:51:32.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="1-基本二分查找"><a href="#1-基本二分查找" class="headerlink" title="1. 基本二分查找"></a>1. 基本二分查找</h4><p>二分查找或二分搜索（binary search），是一种在有序数组中查找某一特定元素的搜索算法。必须满足以下特征：</p><ul><li>存储在数组中</li><li>有序排列</li></ul><a id="more"></a><blockquote><p>如果是用链表存储的，就无法应用二分查找了，因为链表不能通过下标随机访问其元素。</p></blockquote><p>基本二分查找的搜索过程是从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果中间元素大于目标值，则在数组小于中间元素的那一半中查找；如果中间元素小于目标值，则在数组大于中间元素的那一半查找。如果在某一步数组为空，则代表找不到。二分查找算法每一次比较都会使搜索范围缩小一半。</p><p>基本二分查找的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">basic_binary_search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//target在左边，改右边界</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//target在右边，改左边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-各种变体"><a href="#2-各种变体" class="headerlink" title="2. 各种变体"></a>2. 各种变体</h4><p>二分查找除了基本的查找某个元素的位置之外，还有很多的变体。比如查找第一个大于target的元素位置，这经常用于寻找要插入的位置；反过来，也会查找第一个比target小的元素的位置。有时也会查找某个元素在数组中的上下界，也就是查找不大于target的最后一个元素的位置或是查找不小于target的第一个元素的位置。最后还会出现数组中有多个target元素时，需要查找第一次或最后一次出现target元素的位置。</p><p>因此，如下分成了六种变体，在编写相应的二分查找算法的代码时，需要注意的就是判断条件以及返回值的问题。不多说，先看代码：</p><h5 id="变体1：查找第一个大于target的元素位置"><a href="#变体1：查找第一个大于target的元素位置" class="headerlink" title="变体1：查找第一个大于target的元素位置"></a>变体1：查找第一个大于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_greater</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size())</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体2：查找最后一个小于target的元素位置"><a href="#变体2：查找最后一个小于target的元素位置" class="headerlink" title="变体2：查找最后一个小于target的元素位置"></a>变体2：查找最后一个小于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_less</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与标准库中 upper_bound 函数功能一致。</p></blockquote><hr><h5 id="变体3：查找第一个大于等于target的元素位置"><a href="#变体3：查找第一个大于等于target的元素位置" class="headerlink" title="变体3：查找第一个大于等于target的元素位置"></a>变体3：查找第一个大于等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_greater_equal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size())</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与标准库中 lower_bound 函数的功能是一样的。</p></blockquote><hr><h5 id="变体4：查找最后一个小于等于target的元素位置"><a href="#变体4：查找最后一个小于等于target的元素位置" class="headerlink" title="变体4：查找最后一个小于等于target的元素位置"></a>变体4：查找最后一个小于等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_less_equal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体5：查找第一个等于target的元素位置"><a href="#变体5：查找第一个等于target的元素位置" class="headerlink" title="变体5：查找第一个等于target的元素位置"></a>变体5：查找第一个等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_first</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size() &amp;&amp; nums[left] == target)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体6：查找最后一个等于target的元素位置"><a href="#变体6：查找最后一个等于target的元素位置" class="headerlink" title="变体6：查找最后一个等于target的元素位置"></a>变体6：查找最后一个等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_last</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == target)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>看以上循环部分的代码都有一种结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">    mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (target ➀ nums[mid])</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ➁;</span><br></pre></td></tr></table></figure><p>不同的地方有两个：</p><ul><li><p>循环体内部的判断条件：<code>if (target ➀ nums[mid])</code></p><p>➀所在的位置的比较符号是 &lt; 或 &lt;= 。不存在大于或大于等于的情况。</p></li><li><p>返回值：<code>return ➁;</code></p><p>➁所在位置返回值是 left 或 right。</p></li></ul><blockquote><p>循环的终止条件都是 left &gt; right。</p></blockquote><p>不同变体的情况下，➀➁处的取值如下表：</p><table><thead><tr><th align="center">变体</th><th align="center">➀</th><th align="center">➁</th></tr></thead><tbody><tr><td align="center">查找<strong>第一个大于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个小于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">right</td></tr><tr><td align="center">查找<strong>第一个大于等于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个小于等于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">right</td></tr><tr><td align="center">查找<strong>第一个等于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个等于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">right</td></tr></tbody></table><p>根据上表，再根据问题的一些特点可以得出以下一些规律：</p><ul><li>查找第一个（大于、大于等于、等于）target的元素位置，也就是找左边界，返回 left。</li><li>查找最后一个（小于、小于等于、等于）target的元素位置，也就是找右边界，返回 right。</li></ul><blockquote><p>另外，其实变体 5、6 在元素存在于数组中时，与变体3、4是一样的解法。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;1-基本二分查找&quot;&gt;&lt;a href=&quot;#1-基本二分查找&quot; class=&quot;headerlink&quot; title=&quot;1. 基本二分查找&quot;&gt;&lt;/a&gt;1. 基本二分查找&lt;/h4&gt;&lt;p&gt;二分查找或二分搜索（binary search），是一种在有序数组中查找某一特定元素的搜索算法。必须满足以下特征：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;存储在数组中&lt;/li&gt;
&lt;li&gt;有序排列&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://caohuilong.github.io/categories/algorithm/"/>
    
    
    <category term="二分查找" scheme="http://caohuilong.github.io/tags/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE/"/>
    
  </entry>
  
  <entry>
    <title>查找数组中重复的元素</title>
    <link href="http://caohuilong.github.io/2019/03/20/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/"/>
    <id>http://caohuilong.github.io/2019/03/20/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/</id>
    <published>2019-03-20T14:27:28.000Z</published>
    <updated>2019-03-20T14:27:28.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="题目描述"><a href="#题目描述" class="headerlink" title="题目描述"></a>题目描述</h2><p>在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。</p><a id="more"></a><hr><h2 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h2><h4 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h4><p>最简单的方法就是用一个集合 set，遍历数组的每一个元素，在 set 中查找是否存在该元素，如果存在则返回；不存在则放入集合，并继续循环。</p><p>复杂度：</p><ul><li>空间复杂度为：<code>O(N)</code></li><li>时间复杂度为：<code>O(NlogN)</code> （遍历数组为 <code>O(N)</code>，set 中查找为 <code>O(logN)</code>）</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> n, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; Set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Set.find(numbers[i]) != Set.end())&#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set.insert(numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="改进：使用hash表"><a href="#改进：使用hash表" class="headerlink" title="改进：使用hash表"></a>改进：使用hash表</h4><p>使用一个长度为 n 的数组来作为 hash 表，初始化为 0。然后遍历数组，利用数组元素作为 hash 表的索引，如果其对应的值为 1，说明是第二次访问该索引，那么该索引就是原数组中重复的元素；如果其对应的值为 0，说明是第一次访问，设置为 1。</p><p>复杂度：</p><ul><li>空间复杂度为：<code>O(N)</code></li><li>时间复杂度为：<code>O(N)</code> </li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_table[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_table[numbers[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hash_table[numbers[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="常数空间"><a href="#常数空间" class="headerlink" title="常数空间"></a>常数空间</h4><p>上面的方法都会使用 O(N) 的内存空间，如果只能使用 O(1) 的空间，那么可以考虑下面的方法。</p><p>一种类似于基数排序的方法：</p><p>索引 i 从 0 开始遍历数组，</p><ul><li>如果 i == numbers[i]，说明 numbers[i] 在正确的位置上；</li><li>如果 i != numbers[i]，<ul><li>如果 numbers[i] != numbers[numbers[i]]，交换 numbers[i] 和 numbers[numbers[i]]，那么 numbers[numbers[i]] 将会在正确的位置上。</li><li>否则 numbers[i] == numbers[numbers[i]]，那么就找到了 numbers[i]。</li></ul></li></ul><p>复杂度：</p><ul><li>空间复杂度：O(1)</li><li>时间复杂度：O(N)</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != numbers[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                swap(numbers[i], numbers[numbers[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;题目描述&quot;&gt;&lt;a href=&quot;#题目描述&quot; class=&quot;headerlink&quot; title=&quot;题目描述&quot;&gt;&lt;/a&gt;题目描述&lt;/h2&gt;&lt;p&gt;在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://caohuilong.github.io/categories/algorithm/"/>
    
    
    <category term="数组" scheme="http://caohuilong.github.io/tags/%E6%95%B0%E7%BB%84/"/>
    
  </entry>
  
  <entry>
    <title>C/C++中 sizeof 的用法总结</title>
    <link href="http://caohuilong.github.io/2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>http://caohuilong.github.io/2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2019-03-12T09:42:41.000Z</published>
    <updated>2019-03-12T09:42:41.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h4><p>需要注意的是 sizeof() 是运算符，而不是一个函数，在编译时就计算好了，用于计算数据空间的字节数。因此，sizeof 不能用来返回动态分配的内存空间的大小。sizeof 常用于返回类型和静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。</p><p>本文将介绍使用 sizeof 来判定 <strong>共用体</strong>、<strong>结构体</strong>、<strong>嵌套结构体</strong>、<strong>混合结构体</strong> 以及 <strong>类对象</strong> 所占空间的大小。</p><a id="more"></a><hr><h4 id="不同数据类型所占的内存大小"><a href="#不同数据类型所占的内存大小" class="headerlink" title="不同数据类型所占的内存大小"></a>不同数据类型所占的内存大小</h4><table><thead><tr><th align="center"></th><th align="center">32 位</th><th align="center">64 位</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">long</td><td align="center">4</td><td align="center">8</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">指针</td><td align="center">4</td><td align="center">8</td></tr></tbody></table><p>long 类型与指针类型在 32 位机器上只占 4 字节，在 64 位机器上占 8 字节。其他类型在 32 位机器和 64 位机器都是占同样的大小空间。</p><hr><h4 id="共用体的大小"><a href="#共用体的大小" class="headerlink" title="共用体的大小"></a>共用体的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union A&#123;</span><br><span class="line">    int a[5];</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面求出共用体的大小为：<strong>24</strong></p><p>union 中变量共用内存，应以最长的为准，A 中最长的成员是数组 a，其长度为 20。与结果不一样，这是因为在共用体内变量的默认对齐方式，必须以最长的 double（8Byte）对齐，所以得到 sizeof(A) = 24。所以将共用体内的 int a[5] 修改成 int a[6] 后，结果仍然不变；但如果将 int a[5] 修改成 int a[7]，结果就变成 32。</p><blockquote><p><strong>对齐系数</strong>：每个平台上的编译器都有默认对齐系数 n，但是可以通过 <code>#pragma pack(n)</code> 来设定。</p><p><strong>有效对齐系数</strong>：对于一个复杂类型变量，有效对齐系数 = min(对齐系数 n，复杂类型中最长数据类型的长度)。比如设定的对齐系数为 8，而结构体中最长的是 int，4个字节，那么有效对齐值为 4。</p></blockquote><p>通过下面的例子说明有效对齐系数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出为：<strong>20</strong></p><p>这是因为通过 <code>#pragma pack(n)</code> 设置对齐系数为 4，所以实际的有效对齐系数为：min(4, sizeof(double)) = 4，所以最后共用体 A 的大小为 5*int(4) = 20。</p><hr><h4 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h4><p>首先介绍一个概念和两条原则：</p><p><strong>偏移量</strong> ：偏移量指的是 <u>结构体变量中成员的地址</u> 和 <u>结构体变量地址</u> 的差。</p><p>存储变量时地址要求对齐，编译器在编译程序时会遵循<strong>两条原则</strong>：</p><ol><li>结构体变量中成员的偏移量必须是成员大小的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</li></ol><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出为：<strong>24</strong></p><p>这是因为 char a 的偏移量为 0，占用 1Byte；double b 指的下一个可用的地址的偏移量为 1，不是 sizeof(double)=8 的整数倍，需要补足 7Byte 才能是偏移量为 8；int c 指的下一个可用的地址的偏移量为 16，是 sizeof(int)=4 的整数倍，满足 int 的对齐方式。</p><p>故所有成员的变量都分配了空间，空间总的大小为 1+7+8+4 = 20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数 sizeof(double)=8）的倍数，所以需要填充 4Byte，以满足结构的大小为 sizeof(double)=8 的倍数，即 24 。</p><hr><h4 id="嵌套结构体的大小"><a href="#嵌套结构体的大小" class="headerlink" title="嵌套结构体的大小"></a>嵌套结构体的大小</h4><p>对于嵌套的结构体，需要将其展开。对嵌套结构体求 sizeof 时，上述原则变为：</p><ol><li>展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li></ol><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">    &#125; ss;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(C) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<strong>16</strong></p><p>char a 的偏移量为 0，占用 1Byte；但是对于展开后的结构体的第一个成员 char b，下一个可用的地址的偏移量为 1，不是被展开结构体中最大成员 int c 的整数倍，需补充 3Byte 才能是偏移量变为 4；char b 占用 1Byte，下一个可用地址的偏移量是 5，又不是 int c 大小的整数倍，又需补充 3Byte 变为 8；short d 的偏移量为 12，满足 short 的对齐方式。</p><p>故所有成员变量都分配了空间，空间总的大小为 1+3+1+3+4+2 = 14，结尾还得填充 2Byte，以满足为 4 的倍数，所以总的大小为 16。</p><hr><h4 id="混合结构体的大小"><a href="#混合结构体的大小" class="headerlink" title="混合结构体的大小"></a>混合结构体的大小</h4><p>混合结构体指的是结构体中包含有共用体（或数组）等比较复杂的结构体。如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">int</span> k[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125; UDATE;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cat;</span><br><span class="line">    UDATE cow;</span><br><span class="line">    <span class="keyword">double</span> dog;</span><br><span class="line">&#125;too;</span><br><span class="line">UDATE temp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(struct data) + <span class="keyword">sizeof</span>(temp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>摘自《后台开发：核心技术与应用实践》例1.16，书中后面的解释有部分错误。</p></blockquote><p>输出：<strong>64</strong></p><p>假设测试机器是 64 位。UDATE 是一个 union，作为变量公用空间。里面占用字节数最多的变量是数组 int k[5]，有 20Byte，但是它要与 long 类型的 8Byte 对齐，所以占用 24Byte。data 是一个 struct，每个变量分开占用空间，依次为 int(4+4) + UDATE(24) + double(8) = 40，字节已对齐，故 sizeof(struct data) 是 40。所以最后的结果为 40+24 = 64。</p><hr><h4 id="类对象的大小"><a href="#类对象的大小" class="headerlink" title="类对象的大小"></a>类对象的大小</h4><p>关于类占用的内存空间，有以下几点需要注意：</p><ol><li><p>如果类中含有虚函数，则编译器需要为类构建虚函数表，类中需要存储一个指针指向这个虚函数表的首地址，注意不管有几个虚函数，都只建立一张表，所有的虚函数地址都存在这张表里，类中只需要一个指针指向虚函数表首地址即可。</p></li><li><p>类中的静态成员是被类所有实例所共享的，它不计入sizeof计算的空间。</p></li><li><p>类中的普通函数或静态普通函数都存储在栈中，不计入sizeof计算的空间。</p></li><li><p>类成员采用字节对齐的方式分配空间。</p></li></ol><p><strong>总的来说</strong>，类对象占用的内存空间为：<u>非静态成员变量总和</u> 加上 <u>编译器为了 CPU 计算做出的数据对齐处理</u> 和 <u>支持虚函数所产生的负担</u> 的总和。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual void funa();</span><br><span class="line">        virtual void funb();</span><br><span class="line">        void func();</span><br><span class="line">        static void fund();</span><br><span class="line">        static int si; </span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        char c;</span><br><span class="line">        int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上类的大小：<strong>sizeof(B) = 12（32位）</strong>；<strong>sizeof(B) = 16（64位）</strong>。</p><p>根据以上的规则，多个虚函数只建立一张虚函数表，类中只存有一个指向虚函数表首地址的指针；普通函数 <code>func()</code> 不计入；静态成员 <code>fund()</code> 与 <code>si</code> 也不计入；char c 占用 1Byte，再需补充 3Byte；int i 占用 4Byte。所以总的大小为：一个指针大小+1+3+4。32位系统指针大小为 4Byte，所以为 12Byte；64位系统指针大小为 8Byte，所以总大小为 16Byte。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;sizeof-运算符&quot;&gt;&lt;a href=&quot;#sizeof-运算符&quot; class=&quot;headerlink&quot; title=&quot;sizeof 运算符&quot;&gt;&lt;/a&gt;sizeof 运算符&lt;/h4&gt;&lt;p&gt;需要注意的是 sizeof() 是运算符，而不是一个函数，在编译时就计算好了，用于计算数据空间的字节数。因此，sizeof 不能用来返回动态分配的内存空间的大小。sizeof 常用于返回类型和静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。&lt;/p&gt;
&lt;p&gt;本文将介绍使用 sizeof 来判定 &lt;strong&gt;共用体&lt;/strong&gt;、&lt;strong&gt;结构体&lt;/strong&gt;、&lt;strong&gt;嵌套结构体&lt;/strong&gt;、&lt;strong&gt;混合结构体&lt;/strong&gt; 以及 &lt;strong&gt;类对象&lt;/strong&gt; 所占空间的大小。&lt;/p&gt;</summary>
    
    
    
    <category term="C++" scheme="http://caohuilong.github.io/categories/C/"/>
    
    
    <category term="sizeof" scheme="http://caohuilong.github.io/tags/sizeof/"/>
    
  </entry>
  
  <entry>
    <title>GDB 使用简介</title>
    <link href="http://caohuilong.github.io/2019/03/03/GDB%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
    <id>http://caohuilong.github.io/2019/03/03/GDB%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</id>
    <published>2019-03-03T05:38:05.000Z</published>
    <updated>2019-03-03T05:38:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>以上内容是我个人觉得在使用 gdb 时经常会用到的一些东西，根据以下参考链接中的内容整理而来，如需更全面的内容请查看参考链接。</p><p>参考链接：</p><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/">Debugging with GDB</a></p><p><a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F#.E6.98.BE.E7.A4.BA.E6.BA.90.E4.BB.A3.E7.A0.81">用GDB调试程序</a></p><a id="more"></a><hr><h3 id="1-使用-GDB-调试-C-C-程序"><a href="#1-使用-GDB-调试-C-C-程序" class="headerlink" title="1.  使用 GDB 调试 C/C++ 程序"></a>1.  使用 GDB 调试 C/C++ 程序</h3><p>要调试 C/C++ 程序，在使用 gcc/g++ 编译器编译生成可执行文件时要加上 -g 选项，把调试信息加到可执行文件中。编译如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g hello.c -o hello</span><br><span class="line">$ g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure><blockquote><p>如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。</p></blockquote><p>当你用 -g 把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用 gdb 来调试他。</p><hr><h3 id="2-启动-GDB-并加载被调试程序"><a href="#2-启动-GDB-并加载被调试程序" class="headerlink" title="2.  启动 GDB 并加载被调试程序"></a>2.  启动 GDB 并加载被调试程序</h3><p>启动 gdb 并加载被调试程序的方式有以下几种：</p><ul><li><p><code>gdb &lt;program&gt;</code></p><p>program也就是你的执行文件，一般在当前目录下。</p></li><li><p><code>gdb &lt;program&gt; core</code></p><p>用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。</p></li><li><p><code>gdb &lt;program&gt; &lt;PID&gt;</code></p><p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p></li></ul><blockquote><p>以上三种都是在启动 gdb 的同时加载被调试程序。也可以先进入gdb环境，然后再加载被调试程序，方法如下：</p><ol><li>先启动 gdb：终端输入命令 gdb</li><li>加载被调试程序：在 gdb 环境中执行 <code>file &lt;program&gt;</code></li></ol><p>注：上面两步与 <code>gdb &lt;program&gt;</code> 等效。</p></blockquote><p>进入 gdb 的调试环境后，可以使用 help 命令来查看 gdb 相关的命令，这些帮助信息都是可以根据提示来操作的。</p><hr><h3 id="3-查看源代码"><a href="#3-查看源代码" class="headerlink" title="3.  查看源代码"></a>3.  查看源代码</h3><h4 id="3-1-显示源代码"><a href="#3-1-显示源代码" class="headerlink" title="3.1  显示源代码"></a>3.1  显示源代码</h4><p>GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看<strong>查看源代码的GDB命令</strong>：</p><ul><li><p><code>list &lt;n&gt;</code></p><p>显示程序第 n 行周围的源程序</p></li><li><p><code>list &lt;function&gt;</code></p><p>显示函数名为function的函数的源程序</p></li><li><p><code>list</code></p><p>显示当前行 <strong>后面</strong> 的源程序</p></li><li><p><code>list -</code></p><p>显示当前行 <strong>前面</strong> 的源程序</p></li></ul><p>一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行。当然，你也可以定制显示的范围，使用下面命令可以<strong>设置一次显示源程序的行数</strong>：</p><ul><li><p><code>set listsize &lt;count&gt;</code></p><p>设置一次显示 count 行源代码</p></li><li><p><code>show listsize</code></p><p>查看当前 listsize 的设置</p></li></ul><p><strong>list命令还有下面的用法：</strong></p><ul><li><p><code>list &lt;first&gt;, &lt;last&gt;</code></p><p>显示从 first 行到 last 行之间的源代码</p></li><li><p><code>list ,&lt;last&gt;</code></p><p>显示从当前行到last行之间的源代码</p></li><li><p><code>list +</code></p><p>往后显示源代码</p></li></ul><p><strong>总结一下，一般来说在list后面可以跟以下这些参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;linenum&gt;   行号</span><br><span class="line">&lt;+offset&gt;   当前行号的正偏移量</span><br><span class="line">&lt;-offset&gt;   当前行号的负偏移量</span><br><span class="line">&lt;filename:linenum&gt;  哪个文件的哪一行</span><br><span class="line">&lt;function&gt;  函数名</span><br><span class="line">&lt;filename:function&gt; 哪个文件中的哪个函数</span><br><span class="line">&lt;*address&gt;  程序运行时的语句在内存中的地址</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-搜索源代码"><a href="#3-2-搜索源代码" class="headerlink" title="3.2  搜索源代码"></a>3.2  搜索源代码</h4><p>GDB 提供了以下源代码搜索命令：</p><ul><li><p><code>search &lt;regexp&gt;</code> 或 <code>forward-search &lt;regexp&gt;</code></p><p><strong>往下查找</strong>第一个符合正则表达式 regexp 的行</p></li><li><p><code>reverse-search &lt;regexp&gt;</code></p><p><strong>往上查找</strong>第一个符合正则表达式 regexp 的行</p></li></ul><hr><h4 id="3-3-指定源文件的路径"><a href="#3-3-指定源文件的路径" class="headerlink" title="3.3  指定源文件的路径"></a>3.3  指定源文件的路径</h4><p>某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。</p><ul><li><p><code>directory &lt;dirname ...&gt;</code> 或 <code>dir &lt;dirname ...&gt;</code></p><p>添加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。</p></li><li><p><code>directory</code></p><p>重置源文件路径为默认值（<code>$cdir:$cwd</code> on Unix systems）。需要确认</p></li><li><p><code>show directories</code></p><p>显示定义了的源文件搜索路径</p></li></ul><hr><h3 id="4-在-GDB-中运行程序"><a href="#4-在-GDB-中运行程序" class="headerlink" title="4.  在 GDB 中运行程序"></a>4.  在 GDB 中运行程序</h3><p>当以 <code>gdb &lt;program&gt;</code> 方式启动 gdb 后，运行程序使用 <code>r</code> 或是 <code>run</code> 命令。程序的运行，你有可能需要设置下面四方面的事：</p><ol><li><p>程序运行参数</p><p><code>set args</code> ：可指定运行时参数。（如：<code>set args 10 20 30 40 50</code>）<br><code>show args</code> ：命令可以查看设置好的运行参数。</p></li><li><p>运行环境</p><p><code>path &lt;dir&gt;</code> ：可设定程序的运行路径。<br><code>show paths</code>： 查看程序的运行路径。<br><code>set environment varname [=value]</code>： 设置环境变量。如：<code>set env USER=hchen</code><br><code>show environment [varname]</code> ：查看环境变量。</p></li><li><p>工作目录</p><p><code>cd &lt;dir&gt;</code> ：相当于 shell 的 cd 命令。<br><code>pwd</code>： 显示当前的所在目录。</p></li><li><p>程序的输入输出</p><p><code>info terminal</code>：显示你程序用到的终端的模式。<br><code>run &gt; outfile</code> ：使用重定向控制程序输出。<br><code>tty /dev/ttyb</code>：tty命令可以指定输入输出的终端设备。</p></li></ol><hr><h3 id="5-暂停程序运行"><a href="#5-暂停程序运行" class="headerlink" title="5.  暂停程序运行"></a>5.  暂停程序运行</h3><p>调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变量，以及运行时的流程。</p><p>当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。</p><p>在gdb中，我们可以有以下几种暂停方式：</p><ul><li>断点（BreakPoint）；</li><li>观察点（Watch Point）；</li><li>捕捉点（Catch Point）；</li><li>信号（Signals）；</li><li>线程停止（Thread Stops）。</li></ul><p>如果要恢复程序运行，可以使用 c 或是 continue命令。</p><h4 id="5-1-断点设置"><a href="#5-1-断点设置" class="headerlink" title="5.1  断点设置"></a>5.1  断点设置</h4><p>我们用 break 命令（简写为 b）来设置断点。下面有几点<strong>设置断点的方法</strong>：</p><ul><li><p><code>break &lt;function&gt;</code></p><p>在进入指定函数时停住。C++ 中可以使用 class::function 或 function(type,type) 格式来指定函数名.</p></li><li><p><code>break &lt;linenum&gt;</code></p><p>在指定行号设置断点。</p></li><li><p><code>break +offset</code> 与 <code>break -offset</code></p><p>在当前行号的前面或后面的 offset 行停住。offiset为自然数。</p></li><li><p><code>break filename:linenum</code></p><p>在源文件 filename 的 linenum 行处停住。</p></li><li><p><code>break filename:linenum</code></p><p>在源文件 filename 的 function 函数的入口处停住。</p></li><li><p><code>break *address</code></p><p>在程序运行的内存地址处停住。</p></li><li><p><code>break</code></p><p>break命令没有参数时，表示在下一条指令处停住。</p></li><li><p><code>break ... if &lt;condition&gt;</code></p><p>…可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置break if i==100，表示当i为100时停住程序。</p></li></ul><p><strong>查看断点时，可使用info命令</strong>，如下所示：</p><ul><li><code>info breakpoints [n]</code></li><li><code>info break [n]</code></li></ul><blockquote><p>注：n表示断点号。也可以不加 n，表示显示所有断点。</p><p><strong>断点菜单：</strong></p><p>在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break <function>不能告诉GDB要停在哪个函数的入口。当然，你可以使用break &lt;function(type)&gt;也就是把函数的参数类型告诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的断点。你只要输入你菜单列表中的编号就可以了。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b String::after</span><br><span class="line">[0] cancel</span><br><span class="line">[1] all</span><br><span class="line">[2] file:String.cc; line number:867</span><br><span class="line">[3] file:String.cc; line number:860</span><br><span class="line">[4] file:String.cc; line number:875</span><br><span class="line">[5] file:String.cc; line number:853</span><br><span class="line">[6] file:String.cc; line number:846</span><br><span class="line">[7] file:String.cc; line number:735</span><br><span class="line">&gt; 2 4 6</span><br><span class="line">Breakpoint 1 at 0xb26c: file String.cc, line 867.</span><br><span class="line">Breakpoint 2 at 0xb344: file String.cc, line 875.</span><br><span class="line">Breakpoint 3 at 0xafcc: file String.cc, line 846.</span><br><span class="line">Multiple breakpoints were set.</span><br><span class="line">Use the &quot;delete&quot; command to delete unwanted</span><br><span class="line">breakpoints.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>可见，GDB 列出了所有 after 的重载函数，你可以选一下列表编号就行了。0表示放弃设置断点，1表示所有函数都设置断点。</p></blockquote><hr><h4 id="5-2-观察点设置"><a href="#5-2-观察点设置" class="headerlink" title="5.2  观察点设置"></a>5.2  观察点设置</h4><p>观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。我们有下面的几种方法来<strong>设置观察点</strong>：</p><ul><li><p><code>watch &lt;expr&gt;</code></p><p>为表达式（变量）expr 设置一个观察点。一表达式值有变化时，马上停住程序。</p></li><li><p><code>rwatch &lt;expr&gt;</code></p><p>当表达式（变量）expr被读时，停住程序。</p></li><li><p><code>awatch &lt;expr&gt;</code></p><p>当表达式（变量）的值被读或被写时，停住程序。</p></li><li><p><code>info watchpoints</code></p><p>列出当前所设置的所有观察点。</p></li></ul><hr><h4 id="5-3-捕捉点设置"><a href="#5-3-捕捉点设置" class="headerlink" title="5.3  捕捉点设置"></a>5.3  捕捉点设置</h4><p>你可设置捕捉点来捕捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。用以下格式<strong>设置捕捉点</strong>：</p><ul><li><p><code>catch &lt;event&gt;</code></p><p>当event发生时，停住程序。event可以是下面的内容：</p><ul><li>throw 一个C++抛出的异常。（throw为关键字）</li><li>catch 一个C++捕捉到的异常。（catch为关键字）</li><li>exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）</li><li>fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）</li><li>vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）</li><li>load 或 load <libname> 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX下有用）</li><li>unload 或 unload <libname> 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在HP-UX下有用）</li></ul></li><li><p><code>tcatch &lt;event&gt;</code></p><p>只设置一次捕捉点，当程序停住以後，该点被自动删除。</p></li></ul><hr><h4 id="5-4-维护停止点"><a href="#5-4-维护停止点" class="headerlink" title="5.4  维护停止点"></a>5.4  维护停止点</h4><p>上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你觉得已定义好的停止点没有用了，你可以使用delete、clear、disable、enable这几个命令来进行维护：</p><ul><li><p><code>clear</code></p><p>清除所有的已定义的停止点。</p></li><li><p><code>clear &lt;function&gt;</code> 与 <code>clear &lt;filename:function&gt;</code></p><p>清除所有设置在函数上的停止点。</p></li><li><p><code>clear &lt;linenum&gt;</code> 与 <code>clear &lt;filename:linenum&gt;</code></p><p>清除所有设置在指定行上的停止点。</p></li><li><p><code>delete [breakpoints][range...]</code></p><p>删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为 d。</p></li><li><p><code>disable [breakpoints][range...]</code></p><p>disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis。这是一种比删除更好的方法，在需要时可以通过 enable 再次启用。</p></li><li><p><code>enable [breakpoints][range...]</code></p><p>enable所指定的停止点，breakpoints为停止点号。</p></li><li><p><code>enable [breakpoints] once range...</code></p><p>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。</p></li><li><p><code>enable [breakpoints] delete range...</code></p><p>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。</p></li></ul><hr><h3 id="6-恢复程序运行和单步调试"><a href="#6-恢复程序运行和单步调试" class="headerlink" title="6.  恢复程序运行和单步调试"></a>6.  恢复程序运行和单步调试</h3><p>当程序被停住了，你可以用 continue 命令恢复程序的运行直到程序结束，或下一个断点到来。也可以使用 step或 next 命令单步跟踪程序。</p><ul><li><p><code>continue [ignore-count]</code> 或 <code>c [ignore-count]</code> 或 <code>fg [ignore-count]</code></p><p>恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。</p></li><li><p><code>step &lt;count&gt;</code></p><p>单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p></li><li><p><code>next &lt;count&gt;</code></p><p>同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p></li><li><p><code>set step-mode</code>  或 <code>set step-mode on</code></p><p>打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有 debug 信息而不停住。这个参数很有利于查看机器码。</p></li><li><p><code>set step-mode off</code></p><p>关闭step-mode模式</p></li><li><p><code>finish</code></p><p>运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。</p></li><li><p><code>until</code> 或 <code>u</code></p><p>当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</p></li><li><p><code>stepi</code> 或 <code>si</code> | <code>nexti</code> 或 <code>ni</code></p><p>单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是 “display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</p></li></ul><hr><h3 id="7-查看栈信息"><a href="#7-查看栈信息" class="headerlink" title="7.  查看栈信息"></a>7.  查看栈信息</h3><p>当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。</p><p>下面是一些<strong>查看函数调用栈信息</strong>的 GDB 命令：</p><ul><li><p><code>backtrace</code> 或 <code>bt</code></p><p>打印当前的函数调用栈的所有信息。</p></li><li><p><code>backtrace &lt;n&gt;</code> 或 <code>bt &lt;n&gt;</code></p><p>n是一个正整数，表示只打印栈顶上n层的栈信息。</p></li><li><p><code>backtrace &lt;-n&gt;</code> 或 <code>bt &lt;-n&gt;</code> </p><p>-n表一个负整数，表示只打印栈底下n层的栈信息。</p></li></ul><p>如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是<strong>切换当前栈</strong>：</p><ul><li><p><code>frame &lt;n&gt;</code> 或 <code>f &lt;n&gt;</code></p><p>n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。</p></li><li><p><code>up &lt;n&gt;</code></p><p>表示向栈的上面移动n层，可以不打n，表示向上移动一层。</p></li><li><p><code>down &lt;n&gt;</code></p><p>表示向栈的下面移动n层，可以不打n，表示向下移动一层。</p></li></ul><p><strong>查看当前栈层的信息</strong>，你可以用以下GDB命令：</p><ul><li><p><code>frame</code> 或 <code>f</code></p><p>会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。</p></li><li><p><code>info frame</code> 或 <code>info f</code></p><p>这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。</p></li><li><p><code>info args</code></p><p>打印出当前函数的参数名及其值。</p></li><li><p><code>info locals</code></p><p>打印出当前函数中所有局部变量及其值。</p></li><li><p><code>info catch</code></p><p>打印出当前的函数中的异常处理信息。</p></li></ul><hr><h3 id="8-查看运行时数据"><a href="#8-查看运行时数据" class="headerlink" title="8.  查看运行时数据"></a>8.  查看运行时数据</h3><p>在你调试程序时，当程序被停住时，你可以使用 print 命令（简写命令为p），或是同义命令 inspect 来查看当前程序的运行数据。print 命令的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print &lt;expr&gt;</span><br><span class="line">print &#x2F;&lt;f&gt; &lt;expr&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;expr&gt;</code> 是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），<code>&lt;f&gt;</code> 是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是 <code>/x</code>。</p><h4 id="8-1-程序变量"><a href="#8-1-程序变量" class="headerlink" title="8.1  程序变量"></a>8.1  程序变量</h4><p>在GDB中，你可以随时查看以下三种变量的值：</p><ol><li>全局变量（所有文件可见的）</li><li>静态全局变量（当前文件可见的）</li><li>局部变量（当前Scope可见的）</li></ol><p>如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用 print 显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用 “::” 操作符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print  file::variable</span><br><span class="line">print  function::variable</span><br></pre></td></tr></table></figure><hr><h4 id="8-2-自动显示"><a href="#8-2-自动显示" class="headerlink" title="8.2  自动显示"></a>8.2  自动显示</h4><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是 display：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display &lt;expr&gt;</span><br><span class="line">display&#x2F;&lt;fmt&gt; &lt;expr&gt;</span><br><span class="line">display&#x2F;&lt;fmt&gt; &lt;addr&gt;</span><br></pre></td></tr></table></figure><p>expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</p><p>下面是一些和display相关的GDB命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undisplay &lt;dnums...&gt;</span><br><span class="line">delete display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><p>删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable display &lt;dnums...&gt;</span><br><span class="line">enable display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><p>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info display</span><br></pre></td></tr></table></figure><p>查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当前调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。</p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h3&gt;&lt;p&gt;以上内容是我个人觉得在使用 gdb 时经常会用到的一些东西，根据以下参考链接中的内容整理而来，如需更全面的内容请查看参考链接。&lt;/p&gt;
&lt;p&gt;参考链接：&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;https://sourceware.org/gdb/onlinedocs/gdb/&quot;&gt;Debugging with GDB&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;&lt;a href=&quot;http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F#.E6.98.BE.E7.A4.BA.E6.BA.90.E4.BB.A3.E7.A0.81&quot;&gt;用GDB调试程序&lt;/a&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://caohuilong.github.io/categories/Linux/"/>
    
    
    <category term="GDB" scheme="http://caohuilong.github.io/tags/GDB/"/>
    
  </entry>
  
  <entry>
    <title>给新 Git 账户添加 ssh-key</title>
    <link href="http://caohuilong.github.io/2019/02/21/%E7%BB%99%E6%96%B0git%E8%B4%A6%E6%88%B7%E6%B7%BB%E5%8A%A0ssh-key/"/>
    <id>http://caohuilong.github.io/2019/02/21/%E7%BB%99%E6%96%B0git%E8%B4%A6%E6%88%B7%E6%B7%BB%E5%8A%A0ssh-key/</id>
    <published>2019-02-21T09:02:23.000Z</published>
    <updated>2019-02-21T09:02:23.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用 git 的时候，git 与远程服务器一般通过 https 进行传输，这种传输方式在每次 push 和 pull 时都需要输入账户和密码，比较麻烦。所以更好的方法是通过 ssh 进行传输，这需要在本机上创建 ssh-key 密钥对，并把其中的公钥添加到远程的 Git 服务器中。但有时又会使用到多个 git 账户登录不同的 git 服务器，所以就涉及到添加 ssh-key 密钥对了。</p><a id="more"></a><p>我的环境中最初是针对 GitHub 的账户设置了 ssh 的密钥对，然后我现在需要针对另一个 git 账户进行设置密钥对，比如牛客网的 git 服务器。</p><h2 id="添加操作过程"><a href="#添加操作过程" class="headerlink" title="添加操作过程"></a>添加操作过程</h2><p><strong>1. 新建 SSH key：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxx@email.com&quot;</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;chl&#x2F;.ssh&#x2F;id_rsa): id_rsa_nowcoder</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in id_rsa_nowcoder.</span><br><span class="line">Your public key has been saved in id_rsa_nowcoder.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:hjOHuHTiXqCjTPCBf81owybsdflq&#x2F;HVWcq4jBZjnCNs xxx@email.com</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|   . o           |</span><br><span class="line">|o   Oo o         |</span><br><span class="line">|&#x3D;...oBoo         |</span><br><span class="line">| &#x3D;.+*+O.S o      |</span><br><span class="line">|+.o&#x3D;EB.&#x3D;.&#x3D;       |</span><br><span class="line">|o.* +.o .o .     |</span><br><span class="line">|.o + o.o.        |</span><br><span class="line">|o.  o  ...       |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><blockquote><p>上面设置名称为 id_rsa_nowcoder</p></blockquote><p><strong>2. 新秘钥添加到 SSH agent 中</strong></p><p>因为默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将其添加到 SSH agent 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa_nowcoder</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><p>但是出现了 Could not open a connection to your authentication agent. 的错误，用一下方法解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa_nowcoder</span><br><span class="line">Identity added: ~&#x2F;.ssh&#x2F;id_rsa_nowcoder (~&#x2F;.ssh&#x2F;id_rsa_nowcoder)</span><br></pre></td></tr></table></figure><p><strong>3. 在 git 账户中添加 SSH key</strong></p><p>登录 git 账户中添加，完成之后，SSH key 就生效了。检测方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone 你的仓库ssh地址</span><br></pre></td></tr></table></figure><p>若这时不再询问密码，说明设置生效。</p><p><strong>4. 更改远程仓库地址</strong></p><ul><li><p>修改命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin 你的仓库ssh地址</span><br></pre></td></tr></table></figure></li><li><p>或者先删后加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm origin</span><br><span class="line">$ git remote add origin 你的仓库ssh地址</span><br></pre></td></tr></table></figure></li><li><p>或者修改 config 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e</span><br><span class="line">修改 url</span><br></pre></td></tr></table></figure><p>更改完成之后，再通过 git push 或 git pull 就不需要输入账号和密码了。</p></li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;背景&quot;&gt;&lt;a href=&quot;#背景&quot; class=&quot;headerlink&quot; title=&quot;背景&quot;&gt;&lt;/a&gt;背景&lt;/h2&gt;&lt;p&gt;在使用 git 的时候，git 与远程服务器一般通过 https 进行传输，这种传输方式在每次 push 和 pull 时都需要输入账户和密码，比较麻烦。所以更好的方法是通过 ssh 进行传输，这需要在本机上创建 ssh-key 密钥对，并把其中的公钥添加到远程的 Git 服务器中。但有时又会使用到多个 git 账户登录不同的 git 服务器，所以就涉及到添加 ssh-key 密钥对了。&lt;/p&gt;</summary>
    
    
    
    <category term="Linux" scheme="http://caohuilong.github.io/categories/Linux/"/>
    
    
    <category term="Git" scheme="http://caohuilong.github.io/tags/Git/"/>
    
  </entry>
  
  <entry>
    <title>基于 v2ray 实现科学上网</title>
    <link href="http://caohuilong.github.io/2019/02/15/v2ray%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
    <id>http://caohuilong.github.io/2019/02/15/v2ray%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</id>
    <published>2019-02-15T09:21:06.000Z</published>
    <updated>2019-02-15T09:21:06.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本在 vultr 上面购买的 VPS 上面搭建的 VPN 不能用了，具体原因就是 GTW 经过一波加强，可以通过 TCP 阻断来封锁一些用于搭建 VPN 的 VPS。TCP 阻断的结果就是在国内无法通过 tcp 来连接访问国外的 vps，从而在国内无法 ssh 登录 vps，但是使用 ping 工具却能 ping 通被 tcp 阻断的服务器，因为 ping 是基于 ICMP 的。这样给人一种 vps 没被封的错觉。</p><a id="more"></a><p>当 vps 被 TCP 阻断时，原本基于 shadowsocks 的科学上网方式就不能使用了，本文就是针对被 TCP 阻断的 vps，通过 v2ray 来实现科学上网。当然对于没有被 TCP 阻断的 vps 使用该方法来搭梯子也不容易被封。</p><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="1-服务器安装"><a href="#1-服务器安装" class="headerlink" title="1. 服务器安装"></a>1. 服务器安装</h3><p>在 Linux 操作系统， V2Ray 的安装有脚本安装、手动安装、编译安装 3 种方式，选择其中一种即可，本指南仅提供使用使用脚本安装的方法，并仅推荐使用脚本安装，该脚本由 V2Ray 官方提供。该脚本仅可以在 Debian 系列或者支持 Systemd 的 Linux 操作系统使用。 </p><p>本文基于 CentOS 7 服务器来实现。</p><p>首先下载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># wget https:&#x2F;&#x2F;install.direct&#x2F;go.sh</span><br><span class="line">--2019-02-15 07:53:34--  https:&#x2F;&#x2F;install.direct&#x2F;go.sh</span><br><span class="line">Resolving install.direct (install.direct)... 104.27.174.71, 104.27.175.71, 2606:4700:30::681b:af47, ...</span><br><span class="line">Connecting to install.direct (install.direct)|104.27.174.71|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [text&#x2F;plain]</span><br><span class="line">Saving to: ‘go.sh’</span><br><span class="line"></span><br><span class="line">    [ &lt;&#x3D;&gt;                                                                                                               ] 13,915      --.-K&#x2F;s   in 0s      </span><br><span class="line"></span><br><span class="line">2019-02-15 07:53:34 (58.3 MB&#x2F;s) - ‘go.sh’ saved [13915]</span><br></pre></td></tr></table></figure><p>然后执行安装脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># sudo bash go.sh</span><br><span class="line">Installing V2Ray v4.16.0 on x86_64</span><br><span class="line">Downloading V2Ray: https:&#x2F;&#x2F;github.com&#x2F;v2ray&#x2F;v2ray-core&#x2F;releases&#x2F;download&#x2F;v4.16.0&#x2F;v2ray-linux-64.zip</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   608    0   608    0     0   1330      0 --:--:-- --:--:-- --:--:--  1333</span><br><span class="line">100 10.2M  100 10.2M    0     0  1723k      0  0:00:06  0:00:06 --:--:-- 2356k</span><br><span class="line">Updating software repo</span><br><span class="line">http:&#x2F;&#x2F;mirrors.syringanetworks.net&#x2F;fedora-epel&#x2F;7&#x2F;x86_64&#x2F;repodata&#x2F;5a7d69681e5cfd3ae41829a733077e717b512d3dee2d802edeeb206b7d8bda33-updateinfo.xml.bz2: [Errno 14] HTTP Error 404 - Not Found</span><br><span class="line">Trying other mirror.</span><br><span class="line">To address this issue please refer to the below wiki article </span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;wiki.centos.org&#x2F;yum-errors</span><br><span class="line"></span><br><span class="line">If above article doesn&#39;t help to resolve this issue please use https:&#x2F;&#x2F;bugs.centos.org&#x2F;.</span><br><span class="line"></span><br><span class="line">Installing unzip</span><br><span class="line">Extracting V2Ray package to &#x2F;tmp&#x2F;v2ray.</span><br><span class="line">Archive:  &#x2F;tmp&#x2F;v2ray&#x2F;v2ray.zip</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;config.json  </span><br><span class="line">   creating: &#x2F;tmp&#x2F;v2ray&#x2F;doc&#x2F;</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;doc&#x2F;readme.md  </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;geoip.dat    </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;geosite.dat  </span><br><span class="line">   creating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;v2ray.service  </span><br><span class="line">   creating: &#x2F;tmp&#x2F;v2ray&#x2F;systemv&#x2F;</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;systemv&#x2F;v2ray  </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;v2ctl        </span><br><span class="line"> extracting: &#x2F;tmp&#x2F;v2ray&#x2F;v2ctl.sig    </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;v2ray        </span><br><span class="line"> extracting: &#x2F;tmp&#x2F;v2ray&#x2F;v2ray.sig    </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;vpoint_socks_vmess.json  </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;vpoint_vmess_freedom.json  </span><br><span class="line">PORT:40827</span><br><span class="line">UUID:505f001d-4aa8-4519-9c54-6b65749ee3fb</span><br><span class="line">Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;v2ray.service to &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;v2ray.service.</span><br><span class="line">V2Ray v4.16.0 is installed.</span><br></pre></td></tr></table></figure><p>看到类似于这样的提示就算安装成功了。如果安装不成功脚本会有红色的提示语句，这个时候你应当按照提示除错，除错后再重新执行一遍脚本安装 V2Ray。 </p><p>在上面的提示中，有一行 “PORT:40827” 代表着端口号为 40827，还有一行 “UUID:505f001d-4aa8-4519-9c54-6b65749ee3fb” 代表着 id 为 505f001d-4aa8-4519-9c54-6b65749ee3fb。这两个都是随机生成的，不用担心跟别人撞上了。 </p><p>安装完之后，使用以下命令启动 V2Ray：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start v2ray</span><br></pre></td></tr></table></figure><p>在首次安装完成之后，V2Ray 不会自动启动，需要手动运行上述启动命令。 </p><hr><h3 id="2-服务端配置"><a href="#2-服务端配置" class="headerlink" title="2. 服务端配置"></a>2. 服务端配置</h3><p>v2ray 的配置文件位于 <code>/etc/v2ray/config.json</code>。v2ray 相对于 shadowsocks 更复杂的地方就在于其有众多的配置选项，针对不同的应用场景有不同的配置方案，从而实现不同的功能，而 shadowsocks 则相对傻瓜一些。要详细讲述 v2ray 的所有配置选项是需要很长的内容的，本文针对被 TCP 阻断的 VPS 来实现 vpn 的场景。下面简单介绍一些配置内容：</p><ul><li><p><strong>VMess</strong></p><p>VMess 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，如同 Shadowsocks 一样为了对抗墙的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。 </p><p>V2Ray 使用 inbound(传入) 和 outbound(传出) 的结构，这样的结构非常清晰地体现了数据包的流动方向，同时也使得 V2Ray 功能强大复杂的同时而不混乱，清晰明了。形象地说，我们可以把 V2Ray 当作一个盒子，这个盒子有入口和出口(即 inbound 和 outbound)，我们将数据包通过某个入口放进这个盒子里，然后这个盒子以某种机制（这个机制其实就是路由，后面会讲到）决定这个数据包从哪个出口吐出来。以这样的角度理解的话，V2Ray 做客户端，则 inbound 接收来自浏览器数据，由 outbound 发出去(通常是发到 V2Ray 服务器)；V2Ray 做服务器，则 inbound 接收来自 V2Ray 客户端的数据，由 outbound 发出去(通常是如 Google 等想要访问的目标网站)。 </p></li><li><p><strong>mKCP</strong></p><p>V2Ray 引入了 KCP 传输协议，并且做了一些不同的优化，称为 mKCP。 mKCP 使用 UDP 来模拟 TCP 连接，这样即使 vps 被 TCP 阻断了，还是能够通过 UDP 来连接。mKCP 牺牲带宽来降低延迟，传输同样的内容，mKCP 一般比 TCP 消耗更多的流量，但是对于我购买的 vps 流量一般都用的很少，每个月用不完 十分之一，所以采用 mKCP 对流量消耗也没有太大的问题。</p></li></ul><p>服务端采用 <code>vmess + mKCP</code> 的配置时，配置文件 <code>/etc/v2ray/config.json</code> 的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;port&quot;: 40827,</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;clients&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;id&quot;: &quot;505f001d-4aa8-4519-9c54-6b65749ee3fb&quot;,</span><br><span class="line">            &quot;alterId&quot;: 64</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;mkcp&quot;,</span><br><span class="line">        &quot;kcpSettings&quot;: &#123;</span><br><span class="line">          &quot;uplinkCapacity&quot;: 5,</span><br><span class="line">          &quot;downlinkCapacity&quot;: 100,</span><br><span class="line">          &quot;congestion&quot;: true,</span><br><span class="line">          &quot;header&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;none&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完配置文件后，需要重新启动 v2ray：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl restart v2ray</span><br></pre></td></tr></table></figure><p>最后，还需要修改 vps 的防火墙设置，将对应的 udp 端口放行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --zone&#x3D;public --add-port&#x3D;40827&#x2F;udp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>再设置 v2ray 开机自启动，修改 <code>/etc/rc.local</code> 文件，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart v2ray</span><br></pre></td></tr></table></figure><p>服务端配置完毕。</p><hr><h3 id="3-客户端安装"><a href="#3-客户端安装" class="headerlink" title="3. 客户端安装"></a>3. 客户端安装</h3><p>下载客户端，windows 系统下有两种客户端，一种是不带图形界面的，另一种是在其基础上增加了图形界面的。为了方便，使用带有图形界面的版本。下载连接：<a href="https://github.com/2dust/v2rayN/releases">v2rayN</a>，下载 Lastest release 的 <code>v2rayN.zip</code> 压缩包。</p><p>解压后运行 <code>v2rayN.exe</code> 程序，双击任务栏图标打开界面：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/v2rayN%E7%95%8C%E9%9D%A2.png?raw=true" alt="v2rayN界面"></p><p>点击上方<strong>检查更新</strong>，<strong>检查更新 v2rayCore</strong>，点击“是”。</p><p>更新完后，点击<strong>服务器</strong>，<strong>添加[VMess]服务器</strong>，如下配置：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/vmess%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE.png?raw=true" alt="vmess服务器配置"></p><p>配置完成点击确定，右键任务栏 v2rayN 图标，点击<strong>启用http代理</strong>，http 代理模式可选择 <strong>PAC模式</strong> 或者 <strong>全局模式</strong>。</p><p>这样，客户端的配置也完成，即可开始科学上网。</p><hr><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><ol><li><p><strong>非图形界面客户端配置：</strong></p><p>如果客户端没有使用带有图形界面的 v2rayN，其配置稍微复杂一点，需要自己修改客户端配置文件 <code>config.json</code>，配置内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;port&quot;: 1080,</span><br><span class="line">      &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">      &quot;sniffing&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: true,</span><br><span class="line">        &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;auth&quot;: &quot;noauth&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;vnext&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;address&quot;: &quot;xxx.xxx.xxx.xxx&quot;,</span><br><span class="line">            &quot;port&quot;: 40827,</span><br><span class="line">            &quot;users&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;id&quot;: &quot;505f001d-4aa8-4519-9c54-6b65749ee3fb&quot;,</span><br><span class="line">                &quot;alterId&quot;: 64</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;mkcp&quot;,</span><br><span class="line">        &quot;kcpSettings&quot;: &#123;</span><br><span class="line">          &quot;uplinkCapacity&quot;: 5,</span><br><span class="line">          &quot;downlinkCapacity&quot;: 100,</span><br><span class="line">          &quot;congestion&quot;: true,</span><br><span class="line">          &quot;header&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;none&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完 v2ray 并启动之后，还需要配合浏览器的一些代理插件来实现科学上网，如谷歌浏览器与火狐浏览器的 <code>SwitchyOmega</code> 插件，如何使用这里不介绍。</p></li><li><p><strong>参考链接</strong></p><p>v2ray 配置指南：<a href="https://toutyrater.github.io/">https://toutyrater.github.io</a></p><p>v2ray配置模板：<a href="https://github.com/KiriKira/vTemplate">https://github.com/KiriKira/vTemplate</a></p></li></ol><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;原本在 vultr 上面购买的 VPS 上面搭建的 VPN 不能用了，具体原因就是 GTW 经过一波加强，可以通过 TCP 阻断来封锁一些用于搭建 VPN 的 VPS。TCP 阻断的结果就是在国内无法通过 tcp 来连接访问国外的 vps，从而在国内无法 ssh 登录 vps，但是使用 ping 工具却能 ping 通被 tcp 阻断的服务器，因为 ping 是基于 ICMP 的。这样给人一种 vps 没被封的错觉。&lt;/p&gt;</summary>
    
    
    
    <category term="VPN" scheme="http://caohuilong.github.io/categories/VPN/"/>
    
    
    <category term="v2ray" scheme="http://caohuilong.github.io/tags/v2ray/"/>
    
  </entry>
  
  <entry>
    <title>孤儿进程与僵尸进程</title>
    <link href="http://caohuilong.github.io/2018/12/26/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    <id>http://caohuilong.github.io/2018/12/26/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</id>
    <published>2018-12-26T09:10:45.000Z</published>
    <updated>2018-12-26T09:10:45.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>本文主要内容包括：</p><ul><li>产生孤儿进程、僵尸进程的条件；</li><li>通过程序来产生孤儿进程与僵尸进程。</li></ul><a id="more"></a><hr><h3 id="孤儿进程与僵尸进程的产生条件"><a href="#孤儿进程与僵尸进程的产生条件" class="headerlink" title="孤儿进程与僵尸进程的产生条件"></a>孤儿进程与僵尸进程的产生条件</h3><p>在 UNIX/Linux 中，正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。于是就产生了孤儿进程和僵尸进程。</p><ul><li><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么那些子进程将会成为孤儿进程。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</li><li><strong>僵尸进程</strong>：是指一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称为僵尸进程。当一个进程完成它的工作终止之后，它的父进程需要调用 wait() 或 waitpid() 系统调用取得子进程的终止状态。</li></ul><p>可以这样理解孤儿进程和僵尸进程的区别：孤儿进程是父进程已退出，而子进程未退出；僵尸进程是父进程未退出，而子进程已退出。他们的共同点：都是子进程处于这两种状态。</p><hr><h3 id="通过程序产生孤儿进程与僵尸进程"><a href="#通过程序产生孤儿进程与僵尸进程" class="headerlink" title="通过程序产生孤儿进程与僵尸进程"></a>通过程序产生孤儿进程与僵尸进程</h3><p>下面通过程序来具体展示如何产生孤儿进程与僵尸进程，并且说明如何在 Linux 系统中检测这些处于非正常状态的进程。</p><h4 id="产生一个孤儿进程："><a href="#产生一个孤儿进程：" class="headerlink" title="产生一个孤儿进程："></a>产生一个孤儿进程：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;    <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent, PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Child PID: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;  <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child,  PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Parent PID: &quot;</span> &lt;&lt; getppid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># .&#x2F;a.out</span><br><span class="line">Parent, PID: 16911 Child PID: 16912</span><br><span class="line">Child,  PID: 16912 Parent PID: 1</span><br></pre></td></tr></table></figure><p>可以看到，子进程中输出的父进程ID是 1，而不是 16911。这就是因为在子进程睡眠的时间内，父进程运行结束并退出了，子进程称为了一个孤儿进程，并且被 init 进程收养，所以子进程的父进程ID就是 init 进程的进程ID了。</p><p>或者比较快地（睡眠时间结束前）在另一个终端上面使用 ps 命令可以显示出 PID 为 16912 的进程的 PPID 是 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef |egrep &#39;(a.out|PID)&#39; |grep -v grep</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">chl      16912     1  0 16:17 pts&#x2F;18   00:00:00 &#x2F;tmp&#x2F;a.out</span><br></pre></td></tr></table></figure><blockquote><p>以上用了支持扩展正则表达式的 egrep 命令来过滤输出，以同时输出标题行。并且使用 grep -v 来反向选择了 grep，使得不输出包含 grep 的行。</p></blockquote><hr><h4 id="产生一个僵尸进程："><a href="#产生一个僵尸进程：" class="headerlink" title="产生一个僵尸进程："></a>产生一个僵尸进程：</h4><p>还是和上面类似的进程，不过是需要使父进程进入睡眠：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent, PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Child PID: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child,  PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Parent PID: &quot;</span> &lt;&lt; getppid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent, PID: 17135 Child PID: 17136</span><br><span class="line">Child,  PID: 17136 Parent PID: 17135</span><br></pre></td></tr></table></figure><p>以上程序中，子进程会比父进程先运行完并退出，但是父进程并没有采用其他的手段来获取子进程的状态消息并回收子进程的进程描述符，所以子进程变成了一个僵尸进程。</p><p>既可以通过 top 命令来检测当前系统的运行环境中存在僵尸进程，但是无法查看具体的信息。也可以通过 ps 命令来查看状态为 Z 的进程即为僵尸进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux |grep Z |grep -v grep</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">chl      17136  0.0  0.0      0     0 pts&#x2F;18   Z+   16:36   0:00 [a.out] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><p>可以看到 PID 为 17136 的进程的状态 STAT 为 Z+，由此就创建了一个僵尸进程。但是在父进程结束睡眠并退出之后，如果再次使用上述的 ps 命令查看的话，会发现该僵尸进程消失了，这是因为：父进程退出后，这个僵尸进程就成为孤儿进程，过继给了 init 进程，而 init 进程会周期性地调用 wait 系统调用来清除各个僵尸的子进程。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h3&gt;&lt;p&gt;本文主要内容包括：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;产生孤儿进程、僵尸进程的条件；&lt;/li&gt;
&lt;li&gt;通过程序来产生孤儿进程与僵尸进程。&lt;/li&gt;
&lt;/ul&gt;</summary>
    
    
    
    <category term="操作系统" scheme="http://caohuilong.github.io/categories/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/"/>
    
    
    <category term="孤儿进程" scheme="http://caohuilong.github.io/tags/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B/"/>
    
    <category term="僵尸进程" scheme="http://caohuilong.github.io/tags/%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
    
  </entry>
  
  <entry>
    <title>kubeadm join success but node not joined</title>
    <link href="http://caohuilong.github.io/2018/12/18/kubernetes-node-not-joined/"/>
    <id>http://caohuilong.github.io/2018/12/18/kubernetes-node-not-joined/</id>
    <published>2018-12-18T08:07:53.000Z</published>
    <updated>2018-12-18T08:07:53.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在搭建 Kubernetes 集群时，遇到这样一个问题，就是在 node 节点上使用 kubeadm join 时能够成功的加入节点，但是在 master 节点上却无法查看集群中的 node 节点。如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">node1$ sudo kubeadm join --token 1bc310.cb323487a828849e 10.2.7.114:6443 --discovery-token-ca-cert-hash sha256:3d39f8fe34a043ccef4821014fd6d3e0f222614d37d59a6e4944c74f257c6d4d</span><br><span class="line">[preflight] Running pre-flight checks.</span><br><span class="line">[WARNING FileExisting-crictl]: crictl not found in system path</span><br><span class="line">[discovery] Trying to connect to API Server &quot;10.2.7.114:6443&quot;</span><br><span class="line">[discovery] Created cluster-info discovery client, requesting info from &quot;https:&#x2F;&#x2F;10.2.7.114:6443&quot;</span><br><span class="line">[discovery] Requesting info from &quot;https:&#x2F;&#x2F;10.2.7.114:6443&quot; again to validate TLS against the pinned public key</span><br><span class="line">[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server &quot;10.2.7.114:6443&quot;</span><br><span class="line">[discovery] Successfully established connection with API Server &quot;10.2.7.114:6443&quot;</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to master and a response</span><br><span class="line">  was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#39;kubectl get nodes&#39; on the master to see this node join the cluster.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master$ kubectl get nodes</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">ubuntu    Ready     master    4h        v1.9.1</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>出现这个问题的原因是 node 节点的主机名与 master 节点的相同，因此需要给 所有的 node 节点取与 master 节点不同的主机名。</p><p>修改 <code>/etc/hostname</code> 以及 <code>/etc/hosts</code> 文件中的主机名，再通过命令临时设置主机名：<code>sudo hostname 主机名</code>。</p><p>配置完之后，在 node 节点上执行 <code>kubeadm reset</code>， 再重新执行 <code>kubeadm join</code> 。</p><p>最后在 master 节点上查看节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">node1     Ready     &lt;none&gt;    1h        v1.9.1</span><br><span class="line">node2     Ready     &lt;none&gt;    1h        v1.9.1</span><br><span class="line">ubuntu    Ready     master    6h        v1.9.1</span><br></pre></td></tr></table></figure><p>可以看到有两个 node 节点。</p><p>参考：<a href="https://github.com/kubernetes/kubernetes/issues/61224">issue 61224</a></p><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;在搭建 Kubernetes 集群时，遇到这样一个问题，就是在 node 节点上使用 kubeadm join 时能够成功的加入节点，但是在 master 节点上却无法查看集群中的 node 节点。如下：&lt;/p&gt;</summary>
    
    
    
    <category term="Kubernetes" scheme="http://caohuilong.github.io/categories/Kubernetes/"/>
    
    
    <category term="Bugs" scheme="http://caohuilong.github.io/tags/Bugs/"/>
    
    <category term="kubeadm" scheme="http://caohuilong.github.io/tags/kubeadm/"/>
    
  </entry>
  
  <entry>
    <title>解决 VPN 无法打开谷歌学术的问题</title>
    <link href="http://caohuilong.github.io/2018/12/17/%E8%A7%A3%E5%86%B3vpn%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
    <id>http://caohuilong.github.io/2018/12/17/%E8%A7%A3%E5%86%B3vpn%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98/</id>
    <published>2018-12-17T14:14:16.000Z</published>
    <updated>2018-12-17T14:14:16.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>之前搭好的 VPN 用的好好的，最近两天突然不能登录谷歌学术（Google Scholar），但是还能使用谷歌搜索等其他国外的网站。登录谷歌学术网站出现：<code>We&#39;re sorry...... but your computer or network may be sending automated queries. To protect our users, we can&#39;t process your request right now.</code></p><a id="more"></a><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/google%20scholar%20error.png?raw=true"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现这个问题是因为我使用的是 Vultr 的 VPS 来搭建 shadowsocks 服务端，而且有很多人都在这些 VPS 服务商（Vultr，搬瓦工，DigitalOcean，Linode等等），然后有人使用这些公网的 IP 段来做爬虫，所以 Google 把这些公网 IP 给封了。但是一般封的都是 IPv4 的地址，IPv6 的地址一般没有被封，所以可以考虑使用 IPv6 来访问谷歌学术的网站。</p><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>首先，找到最新的 Google IPv6 地址，可以在这里查看：<a href="https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts">IPv6-hosts</a></p><p>找到 Google 学术对应的 IPv6 地址后，修改服务器的 hosts 文件，<code>vim /etc/hosts</code>，在文件的最后加入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Scholar 学术搜索</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com.hk</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com.tw</span><br><span class="line">2404:6800:4005:805::200e scholar.google.cn #www.google.cn</span><br></pre></td></tr></table></figure></li><li><p>然后，重启 shadowsocks 服务端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks restart</span><br></pre></td></tr></table></figure><blockquote><p>注：不同的搭建方式可能重启的方式不太一样。我的搭建方式请参考：<a href="https://cao0507.github.io/2018/08/21/VPS%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B6%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/">shadowsocks服务端搭建</a></p></blockquote><p>之后，就能够正常访问谷歌学术的网站了。</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/google%20scholar.png?raw=true"></p></li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>有些时候，到这里可能还是不能正常访问谷歌学术。这个可能是因为 Vultr 上 5 美元的 VPS 默认使用的是 IPv4 的地址，而没有启用 IPv6 的地址，所以需要给你的 VPS 分配一个 IPv6 的地址。</p><p><strong>Server Information</strong> -&gt; <strong>Settings</strong> -&gt; <strong>IPv6</strong>：给你的 Server 分配（assign）一个 IPv6 地址，分配一个 IPv6 地址是不要钱的。这个过程会重启你的 VPS，重启之后，能看到有一个 IPv6 的地址，如下图：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/vps%20assign%20ipv6.png?raw=true"></p><blockquote><p>我一开始就是因为没有给我的 VPS 分配 IPv6 地址，所以修改了服务器的 hosts 文件也还是没有解决这个问题。你在解决问题的时候注意要先分配 IPv6 地址哦！</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;问题&quot;&gt;&lt;a href=&quot;#问题&quot; class=&quot;headerlink&quot; title=&quot;问题&quot;&gt;&lt;/a&gt;问题&lt;/h2&gt;&lt;p&gt;之前搭好的 VPN 用的好好的，最近两天突然不能登录谷歌学术（Google Scholar），但是还能使用谷歌搜索等其他国外的网站。登录谷歌学术网站出现：&lt;code&gt;We&amp;#39;re sorry...... but your computer or network may be sending automated queries. To protect our users, we can&amp;#39;t process your request right now.&lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="VPN" scheme="http://caohuilong.github.io/categories/VPN/"/>
    
    
    <category term="shadowsocks" scheme="http://caohuilong.github.io/tags/shadowsocks/"/>
    
    <category term="Bugs" scheme="http://caohuilong.github.io/tags/Bugs/"/>
    
  </entry>
  
  <entry>
    <title>Hyperledger Caliper Disable TLS</title>
    <link href="http://caohuilong.github.io/2018/12/15/fabric-disable-tls/"/>
    <id>http://caohuilong.github.io/2018/12/15/fabric-disable-tls/</id>
    <published>2018-12-15T04:54:14.000Z</published>
    <updated>2018-12-15T04:54:14.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在使用 Hyperledger Caliper 时，想通过 wireshark 抓包来分析 fabric 运行流程中各阶段的数据信息，但是发现 fabric 节点间的通信使用了传输层安全（Transport Layer Security，TLS）协议，使得通信的报文的内容在抓包后无法分析。因此考虑在测试环境中暂时关闭 TLS，从而能够直接查看报文中承载的数据内容。</p><a id="more"></a><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h4 id="1-在-docker-compose-的配置文件中修改环境变量"><a href="#1-在-docker-compose-的配置文件中修改环境变量" class="headerlink" title="1. 在 docker-compose 的配置文件中修改环境变量"></a>1. 在 docker-compose 的配置文件中修改环境变量</h4><p>本实验是在 Hyperledger Caliper 的测试环境中进行的，Caliper 测试工具在运行初始阶段会调用 docker-compose 启动 fabric 的网络，启动的 fabric 默认启用了 TLS，可以在其 docker-compose 的启动配置文件 docker-compose.yaml 中看到环境变量：</p><ul><li><code>FABRIC_CA_SERVER_TLS_ENABLED=true</code></li><li><code>ORDERER_GENERAL_TLS_ENABLED=true</code></li><li><code>CORE_PEER_TLS_ENABLED=true</code></li></ul><p>以上三个环境变量都设置为 true。如果要 disable TLS，则需在配置文件 docker-compose.yaml 中将这三个环境变量都注释掉，或者将它们设置为 false。即：</p><ul><li><code>FABRIC_CA_SERVER_TLS_ENABLED=false</code></li><li><code>ORDERER_GENERAL_TLS_ENABLED=false</code></li><li><code>CORE_PEER_TLS_ENABLED=false</code></li></ul><h4 id="2-修改-benchmark-中的-fabric-json-文件"><a href="#2-修改-benchmark-中的-fabric-json-文件" class="headerlink" title="2. 修改 benchmark 中的 fabric.json 文件"></a>2. 修改 benchmark 中的 fabric.json 文件</h4><p>在 benchmark 中的每个例子中，如 simple 的网络配置文件 fabric.json 中，client 与 peer 、orderer、ca 等节点都是通过 grpcs 或 https 来通信的，而这是在使用了 TLS 时的通信方式，因此需要将其改为 grpc 或 http 来通信。修改入下：</p><ul><li><code>orderer.url</code>：<code>grpcs://localhost:7050</code>  ==&gt;  <code>grpc://localhost:7050</code></li><li><code>ca.url</code>：<code>https://localhost:7054</code>  ==&gt;  <code>http://localhost:7054</code></li><li><code>peer1.requests</code>：<code>grpcs://localhost:7051</code>   ==&gt;  <code>grpc://localhost:7051</code></li><li><code>peer1.events</code>：<code>grpcs://localhost:7053</code>   ==&gt;   <code>grpc://localhost:7053</code></li></ul><p>其他的都是如此修改。</p><blockquote><p>如果用 vim 编辑器的话，可以快捷的使用全局替换功能，在 normal 模式下输入冒号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,$  s&#x2F;grpcs&#x2F;grpc&#x2F;g       #表示将第一行到最后一行间的所有grpcs替换成grpc</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-错误记录"><a href="#3-错误记录" class="headerlink" title="3. 错误记录"></a>3. 错误记录</h4><p>如果仅仅修改 docker-compose.yaml 文件中的环境变量，没有修改 fabric.json 中的通信方式的话，则在运行测试时会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># create mychannel......</span><br><span class="line">E1215 12:26:25.877864366    9327 ssl_transport_security.cc:989] Handshake failed with fatal error SSL_ERROR_SSL: error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number.</span><br><span class="line">E1215 12:26:25.879670836    9327 ssl_transport_security.cc:989] Handshake failed with fatal error SSL_ERROR_SSL: error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number.</span><br><span class="line">error: [Orderer.js]: sendBroadcast - on error: &quot;Error: 14 UNAVAILABLE: Connect Failed\n    at createStatusError (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:64:15)\n    at ClientDuplexStream._emitStatusIfDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:270:19)\n    at ClientDuplexStream._readsDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:236:8)\n    at readCallback (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:296:12)&quot;</span><br><span class="line">not ok 1 Failed to create channels Error: SERVICE_UNAVAILABLE at ClientDuplexStream.&lt;anonymous&gt; (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Orderer.js:136:21) at emitOne (events.js:116:13) at ClientDuplexStream.emit (events.js:211:7) at ClientDuplexStream._emitStatusIfDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:271:12) at ClientDuplexStream._readsDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:236:8) at readCallback (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:296:12)</span><br><span class="line">  ---</span><br><span class="line">    operator: fail</span><br><span class="line">    at: channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:159:19)</span><br><span class="line">    stack: |-</span><br><span class="line">      Error: Failed to create channels Error: SERVICE_UNAVAILABLE</span><br><span class="line">          at ClientDuplexStream.&lt;anonymous&gt; (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Orderer.js:136:21)</span><br><span class="line">          at emitOne (events.js:116:13)</span><br><span class="line">          at ClientDuplexStream.emit (events.js:211:7)</span><br><span class="line">          at ClientDuplexStream._emitStatusIfDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:271:12)</span><br><span class="line">          at ClientDuplexStream._readsDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:236:8)</span><br><span class="line">          at readCallback (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:296:12)</span><br><span class="line">          at Test.assert [as _assert] (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:224:54)</span><br><span class="line">          at Test.bound [as _assert] (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:76:32)</span><br><span class="line">          at Test.fail (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:317:10)</span><br><span class="line">          at Test.bound [as fail] (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:76:32)</span><br><span class="line">          at channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:159:19)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">  ...</span><br><span class="line">fabric.init() failed, Error: Fabric: Create channel failed</span><br><span class="line">    at channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:160:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">[Transaction Info] - Submitted: 0 Succ: 0 Fail:0 Unfinished:0</span><br><span class="line">unexpected error, Error: Fabric: Create channel failed</span><br><span class="line">    at channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:160:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br></pre></td></tr></table></figure><p>这个问题需要注意。</p><hr><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在 TLS 被开启或关闭两种情况下，能够发现关闭 TLS 后，系统的吞吐率略有提升，这是可想而知的，毕竟减少了一层传输层安全协议的封装。结果图如下：</p><ul><li><p><strong>Enable TLS</strong></p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/enable_tls.png?raw=true"></p></li><li><p><strong>Disable TLS</strong></p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/disable_tls.png?raw=true"></p></li></ul><p>不过以上的结果在实际中的意义并不大，因为在实际应用中肯定需要进行传输层安全协议的封装，不然这区块链的安全从和谈起。</p><p>如下图可以看到关闭 TLS 后，抓包后能够查看数据内容：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/disable-tls%20%E6%8A%93%E5%8C%85%E7%BB%93%E6%9E%9C.png?raw=true"></p><p>太不安全了！所以以上内容均只能应用于测试。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;最近在使用 Hyperledger Caliper 时，想通过 wireshark 抓包来分析 fabric 运行流程中各阶段的数据信息，但是发现 fabric 节点间的通信使用了传输层安全（Transport Layer Security，TLS）协议，使得通信的报文的内容在抓包后无法分析。因此考虑在测试环境中暂时关闭 TLS，从而能够直接查看报文中承载的数据内容。&lt;/p&gt;</summary>
    
    
    
    <category term="区块链" scheme="http://caohuilong.github.io/categories/%E5%8C%BA%E5%9D%97%E9%93%BE/"/>
    
    
    <category term="Hyperledger fabric" scheme="http://caohuilong.github.io/tags/Hyperledger-fabric/"/>
    
    <category term="Hyperledger caliper" scheme="http://caohuilong.github.io/tags/Hyperledger-caliper/"/>
    
  </entry>
  
  <entry>
    <title>Docker 容器启动时端口映射失败</title>
    <link href="http://caohuilong.github.io/2018/12/05/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5/"/>
    <id>http://caohuilong.github.io/2018/12/05/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5/</id>
    <published>2018-12-05T03:11:44.000Z</published>
    <updated>2018-12-05T03:11:44.000Z</updated>
    
    <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在一台虚拟机上创建容器时因为端口映射的问题而导致容器启动失败，并提示 <code>docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated. </code></p><a id="more"></a><hr><h4 id="1-错误发现过程"><a href="#1-错误发现过程" class="headerlink" title="1. 错误发现过程"></a>1. 错误发现过程</h4><ul><li><p>通过 docker-compose 启动一个容器是提示无法启动容器，错误原因是 <code>Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f docker-compose-orderer.yaml up -d</span><br><span class="line">Creating orderer.example.com ... error</span><br><span class="line"></span><br><span class="line">ERROR: for orderer.example.com  Cannot start service orderer.example.com: b&#39;driver failed programming external connectivity on endpoint orderer.example.com (b1253c6e3542219f989fb9f6508c738066aeeb2fcdebd1e13b9b85c63c2715dd): Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</span><br><span class="line"></span><br><span class="line">ERROR: for orderer.example.com  Cannot start service orderer.example.com: b&#39;driver failed programming external connectivity on endpoint orderer.example.com (b1253c6e3542219f989fb9f6508c738066aeeb2fcdebd1e13b9b85c63c2715dd): Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</span><br><span class="line">ERROR: Encountered errors while bringing up the project.</span><br></pre></td></tr></table></figure></li><li><p>接着直接使用 docker run 命令启动容器，还是提示一样的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name orderer.example.com -d -p 7050:7050 hyperledger&#x2F;fabric-orderer:x86_64-1.1.0 </span><br><span class="line">07c97104c290f470588bf0cfe041f76771bfc8586b3ad0fe784a20f97c4e4a6f</span><br><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated.</span><br></pre></td></tr></table></figure></li><li><p>查看主机的端口是否被占用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntlp</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address        Foreign Address     State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 0.0.0.0:22           0.0.0.0:*           LISTEN      -               </span><br><span class="line">tcp6       0      0 :::22                :::*                LISTEN      -               </span><br><span class="line">tcp6       0      0 :::2375              :::*                LISTEN      -</span><br></pre></td></tr></table></figure><p>发现并没有 7050 端口并没有在使用。</p></li><li><p>启动另一个容器，绑定主机的另一个端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8050:7050 hyperledger&#x2F;fabric-orderer:x86_64-1.1.0 </span><br><span class="line">fba31d37ff4cc409740ce8cd045f4f4bc6a76f7c69c454a2d7e380327613acb0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                     COMMAND             CREATED              STATUS              PORTS                    NAMES</span><br><span class="line">fba31d37ff4c        hyperledger&#x2F;fabric-orderer:x86_64-1.1.0   &quot;orderer&quot;           8 seconds ago        Up 7 seconds        0.0.0.0:8050-&gt;7050&#x2F;tcp   confident_wescoff</span><br></pre></td></tr></table></figure><p>可以启动。</p></li><li><p>查看 docker 服务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service; enabled; vendor preset: enabled)</span><br><span class="line">  Drop-In: &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d</span><br><span class="line">           └─override.conf</span><br><span class="line">   Active: active (running) since Wed 2018-12-05 09:29:11 CST; 1h 14min ago</span><br><span class="line">     Docs: https:&#x2F;&#x2F;docs.docker.com</span><br><span class="line"> Main PID: 987 (dockerd)</span><br><span class="line">    Tasks: 35</span><br><span class="line">   Memory: 161.2M</span><br><span class="line">      CPU: 54.874s</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;docker.service</span><br><span class="line">           ├─ 987 &#x2F;usr&#x2F;bin&#x2F;dockerd</span><br><span class="line">           └─1089 docker-containerd --config &#x2F;var&#x2F;run&#x2F;docker&#x2F;containerd&#x2F;containerd.toml</span><br></pre></td></tr></table></figure><p>服务显示是正常运行的。</p></li></ul><hr><h4 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h4><p>网上查看了一些方法，可以通过重启 docker 服务来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>真的解决了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name orderer.example.com -d -p 7050:7050 hyperledger&#x2F;fabric-orderer:x86_64-1.1.0 </span><br><span class="line">2f289e5225344e4e07230a0985e9f51f2ef6584af263be28388bdb7f6c80af35</span><br><span class="line"></span><br><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE                                     COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">2f289e522534        hyperledger&#x2F;fabric-orderer:x86_64-1.1.0   &quot;orderer&quot;           7 seconds ago       Up 6 seconds        0.0.0.0:7050-&gt;7050&#x2F;tcp   orderer.example.com</span><br></pre></td></tr></table></figure><hr>]]></content>
    
    
    <summary type="html">&lt;h4 id=&quot;介绍&quot;&gt;&lt;a href=&quot;#介绍&quot; class=&quot;headerlink&quot; title=&quot;介绍&quot;&gt;&lt;/a&gt;介绍&lt;/h4&gt;&lt;p&gt;在一台虚拟机上创建容器时因为端口映射的问题而导致容器启动失败，并提示 &lt;code&gt;docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated. &lt;/code&gt;&lt;/p&gt;</summary>
    
    
    
    <category term="Docker" scheme="http://caohuilong.github.io/categories/Docker/"/>
    
    
    <category term="Docker" scheme="http://caohuilong.github.io/tags/Docker/"/>
    
    <category term="Bugs" scheme="http://caohuilong.github.io/tags/Bugs/"/>
    
  </entry>
  
  <entry>
    <title>UNP练习：确定主机字节序</title>
    <link href="http://caohuilong.github.io/2018/11/08/%E7%A1%AE%E5%AE%9A%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
    <id>http://caohuilong.github.io/2018/11/08/%E7%A1%AE%E5%AE%9A%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F/</id>
    <published>2018-11-08T06:46:04.000Z</published>
    <updated>2018-11-08T06:46:04.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="确定主机字节序的程序"><a href="#确定主机字节序的程序" class="headerlink" title="确定主机字节序的程序"></a>确定主机字节序的程序</h3><p>记录 UNP 学习第三章的确定主机字节序的程序，使用 C++ 语言编写。</p><p>程序如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_VENDOR_OS <span class="meta-string">&quot;x86_64-unknown-linux-gnu&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">short</span> s;</span><br><span class="line">        <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">    &#125; un; </span><br><span class="line">    </span><br><span class="line">    un.s = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; CPU_VENDOR_OS &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">sizeof</span>(<span class="keyword">short</span>) == <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( un.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">2</span> ) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;big-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( un.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">1</span> ) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;little-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unknown&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(short) = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的 Ubuntu 16.04 虚拟机上运行上面的程序得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x86_64-unknown-linux-gnu: little-endian</span><br></pre></td></tr></table></figure><p>这说明我的虚拟机在内存中存储数据的字节序是 <strong>小端字节序</strong>。</p><blockquote><p>上面定义的 CPU_VENDOR_OS 宏的值是可在 UNP 随书的源码得到的 config.h 头文件中查看。</p></blockquote><hr><h3 id="大端模式与小端模式理解"><a href="#大端模式与小端模式理解" class="headerlink" title="大端模式与小端模式理解"></a>大端模式与小端模式理解</h3><p>考虑一个 16 位整数，它由 2 个字节组成。内存中存储这两个字节有两种方法：</p><ul><li>一种将低序字节存储在起始地址，这称为 <strong>小端字节序</strong>；</li><li>另一种将高序字节存储在起始地址，这称为 <strong>大端字节序</strong>。</li></ul><p>在上面的程序中，定义了一个联合体变量 un，包含一个短整形变量 s 和一个包含 2 个字符的字符数组 c。首先给 un.s 赋值 0x0102，这样在字符串数组 c 中存放的字符串对应的 ASCII 值为 0x0102 。高序字节为 0x01，低序字节为 0x02 。</p><p><strong>如果系统是小端模式：</strong></p><p>低序字节存储在起始地址，也就是 0x02 存放在数组的起始地址 un.c；高序字节存储在起始地址+1，即 0x01 存放在 un.c+1 中。即有一下等式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">un.c[0] &#x3D;&#x3D; 0x02</span><br><span class="line">un.c[1] &#x3D;&#x3D; 0x01</span><br></pre></td></tr></table></figure><p><strong>如果系统是大端模式：</strong></p><p>高序字节存储在起始地址，也就是 0x01 存放在数组的起始地址 un.c；低序字节存储在起始地址+1，即 0x02 存放在 un.c+1 中。有以下等式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">un.c[0] &#x3D;&#x3D; 0x01</span><br><span class="line">un.c[1] &#x3D;&#x3D; 0x02</span><br></pre></td></tr></table></figure><blockquote><p>对于一个二进制或十六进制的值，如 0x01020304，位于左边的 0x01 字节是高序字节，位于右边 0x04 的是低序字节。</p></blockquote><hr><h3 id="或者用以下更简单的程序来确定："><a href="#或者用以下更简单的程序来确定：" class="headerlink" title="或者用以下更简单的程序来确定："></a>或者用以下更简单的程序来确定：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> val = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) &amp;val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">1</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;big-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="number">2</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;little-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将短整形变量 val 的地址强制转换成字符型指针的地址 p。p 是低地址，(p+1)是高地址。0x01是 val 的高有效字节，0x02是 val 的低有效字节。则有一下两种情况：</p><ul><li><code>*p == 0x01 &amp;&amp; *(p+1) == 0x02</code>：高有效字节存放在低地址，大端模式。</li><li><code>*p == 0x02 &amp;&amp; *(p+1) == 0x01</code>：低有效字节存放在低地址，小端模式。</li></ul><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;确定主机字节序的程序&quot;&gt;&lt;a href=&quot;#确定主机字节序的程序&quot; class=&quot;headerlink&quot; title=&quot;确定主机字节序的程序&quot;&gt;&lt;/a&gt;确定主机字节序的程序&lt;/h3&gt;&lt;p&gt;记录 UNP 学习第三章的确定主机字节序的程序，使用 C++ 语言编写。&lt;/p&gt;
&lt;p&gt;程序如下：&lt;/p&gt;</summary>
    
    
    
    <category term="UNIX网络编程" scheme="http://caohuilong.github.io/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="大小端模式" scheme="http://caohuilong.github.io/tags/%E5%A4%A7%E5%B0%8F%E7%AB%AF%E6%A8%A1%E5%BC%8F/"/>
    
  </entry>
  
  <entry>
    <title>socket编程之bind函数</title>
    <link href="http://caohuilong.github.io/2018/11/07/socket%E7%BC%96%E7%A8%8B%E4%B9%8Bbind%E5%87%BD%E6%95%B0/"/>
    <id>http://caohuilong.github.io/2018/11/07/socket%E7%BC%96%E7%A8%8B%E4%B9%8Bbind%E5%87%BD%E6%95%B0/</id>
    <published>2018-11-07T13:41:09.000Z</published>
    <updated>2018-11-07T13:41:09.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="bind-函数：关联地址和套接字"><a href="#bind-函数：关联地址和套接字" class="headerlink" title="bind 函数：关联地址和套接字"></a>bind 函数：关联地址和套接字</h3><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：若成功，返回 0；若出错，返回 -1.</p><a id="more"></a><h3 id="使用-bind-时遇到的错误"><a href="#使用-bind-时遇到的错误" class="headerlink" title="使用 bind 时遇到的错误"></a>使用 bind 时遇到的错误</h3><p>在练习 UNP 代码 daytimetcpsrv.c 时遇到两个问题：</p><ol><li><p><strong>Permission denied</strong></p><p>这是因为地址中的端口号必须不小于 1024，除非该进程具有相应的特权（即 root 用户）。</p></li><li><p><strong>Address already in use</strong></p><p>这个问题有时会让人很疑问，明明已经结束了使用对应端口的进程，端口应该不是 <code>in use</code> 的啊，但却无法再次调用 bind 函数来绑定该端口到一个套接字端点（bind 函数返回 <code>EADDRINUSE</code>）。其实这是由 TCP 套接字状态 <code>TIME_WAIT</code> 引起的，该状态在套接字关闭后约保留 2 到 4 分钟，因此无法再次绑定刚刚使用的端口。在 <code>TIME_WAIT</code> 状态退出之后，套接字被删除，该地址才能被重新绑定而不出问题。</p><p>可以通过 netstat -ant 来查看这个端口还处于 <code>TIME_WAIT</code> 状态：</p><p>等待 <code>TIME_WAIT</code> 结束可能是令人恼火的一件事，特别是如果您正在开发一个套接字服务器，就需要停止服务器来做一些改动，然后重启。幸运的是，有方法可以避开 <code>TIME_WAIT</code> 状态。可以给套接字应用 <code>SO_REUSEADDR</code> 套接字选项，以便端口可以马上重用。</p><p>对于 daytimetcpsrv.c，可以加上以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse)) &lt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  perror(<span class="string">&quot;setsockopet error\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>重新编译运行。</p></li></ol><h3 id="关于-TIME-WAIT-状态"><a href="#关于-TIME-WAIT-状态" class="headerlink" title="关于 TIME_WAIT 状态"></a>关于 TIME_WAIT 状态</h3><p>TCP 设计中之所以要让一个旧的连接处于 TIME_WAIT 状态是因为要防止旧连接的老的重复分组出现在新连接中。拿 UNP 上面的例子来说：</p><p>假设在 12.106.32.245 的端口 1500 和 206.168.112.219 的端口 21 之间有一个 TCP 连接。当我们关闭这个连接后，很快又重新建立一条相同 IP 和端口的 TCP 连接。在这种情况下，假如旧连接在网络中还存在没有被丢弃的重复分组，而且重复分组又出现在了新连接中了，TCP 将无法正确处理这个分组。为了防止这种情况的发生，TCP 将刚关闭的连接置于 TIME_WAIT 状态，不允许给处于该状态的连接启动新的化身，持续时间是 2MSL，如此将能保证该连接的老的重复分组都已在网络中消逝。</p><blockquote><p>注：是主动执行关闭 TCP 连接的那端将处于 TIME_WAIT 状态。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;bind-函数：关联地址和套接字&quot;&gt;&lt;a href=&quot;#bind-函数：关联地址和套接字&quot; class=&quot;headerlink&quot; title=&quot;bind 函数：关联地址和套接字&quot;&gt;&lt;/a&gt;bind 函数：关联地址和套接字&lt;/h3&gt;&lt;p&gt;定义：&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;meta&quot;&gt;#&lt;span class=&quot;meta-keyword&quot;&gt;include&lt;/span&gt; &lt;span class=&quot;meta-string&quot;&gt;&amp;lt;sys/socket.h&amp;gt;&lt;/span&gt;&lt;/span&gt;&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;&lt;span class=&quot;function&quot;&gt;&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;title&quot;&gt;bind&lt;/span&gt;&lt;span class=&quot;params&quot;&gt;(&lt;span class=&quot;keyword&quot;&gt;int&lt;/span&gt; sockfd, &lt;span class=&quot;keyword&quot;&gt;const&lt;/span&gt; struct sockaddr *addr, &lt;span class=&quot;keyword&quot;&gt;socklen_t&lt;/span&gt; len)&lt;/span&gt;&lt;/span&gt;;&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;
&lt;p&gt;返回值：若成功，返回 0；若出错，返回 -1.&lt;/p&gt;</summary>
    
    
    
    <category term="UNIX网络编程" scheme="http://caohuilong.github.io/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="bind" scheme="http://caohuilong.github.io/tags/bind/"/>
    
  </entry>
  
  <entry>
    <title>UNP练习：TCP时间获取程序</title>
    <link href="http://caohuilong.github.io/2018/11/07/TCP%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F/"/>
    <id>http://caohuilong.github.io/2018/11/07/TCP%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F/</id>
    <published>2018-11-07T13:03:45.000Z</published>
    <updated>2018-11-07T13:03:45.000Z</updated>
    
    <content type="html"><![CDATA[<h5 id="《UNIX-网络编程：卷1》学习记录1："><a href="#《UNIX-网络编程：卷1》学习记录1：" class="headerlink" title="《UNIX 网络编程：卷1》学习记录1："></a>《UNIX 网络编程：卷1》学习记录1：</h5><p>书本上有两个程序：</p><ul><li>1.2节：简单的 TCP 时间获取客户程序</li><li>1.5节：简单的 TCP 时间获取服务器程序</li></ul><p>本文记录的是我在学习过程编写的 C++ 版本的程序（但其实还是 C 程序，hahaha…），为了熟悉 UNIX 函数库，这里并没有基于书中的 &lt;unp.h&gt; 头文件来编写，而是全部自己添加 C 函数库中的头文件。程序如下：</p><a id="more"></a><h5 id="简单的-TCP-时间获取客户程序"><a href="#简单的-TCP-时间获取客户程序" class="headerlink" title="简单的 TCP 时间获取客户程序"></a>简单的 TCP 时间获取客户程序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE     4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>         sockfd, n;</span><br><span class="line">    <span class="keyword">char</span>        recevline[MAXLINE + <span class="number">1</span>]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sockaddr_in结构定义在&lt;netinet/in.h&gt;头文件中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)&#123; </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;IPaddress&gt; &lt;port&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//socket()在&lt;sys/socket.h&gt;</span></span><br><span class="line">    <span class="keyword">if</span> ( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> )&#123;      </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));     <span class="comment">//定义在&lt;string.h&gt;头文件中</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));       <span class="comment">//头文件&lt;arpa/inet.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//inet_pton()在头文件&lt;arpa/inet.h&gt;</span></span><br><span class="line">    <span class="keyword">if</span> ( inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span> )&#123;    </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;inet_pton error for &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;connect error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( (n = read(sockfd, recevline, MAXLINE)) &gt; <span class="number">0</span> )&#123;   <span class="comment">//头文件&lt;unisted.h&gt;</span></span><br><span class="line">        recevline[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">fputs</span>(recevline, <span class="built_in">stdout</span>) == EOF )&#123;     <span class="comment">//头文件&lt;stdio.h&gt;</span></span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fputs error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( n &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单的-TCP-时间获取服务器程序"><a href="#简单的-TCP-时间获取服务器程序" class="headerlink" title="简单的 TCP 时间获取服务器程序"></a>简单的 TCP 时间获取服务器程序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE     4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>                 listenfd, connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span>   <span class="comment">// sockaddr_in结构定义在&lt;netinet/in.h&gt;头文件中</span></span><br><span class="line">    <span class="keyword">char</span>                buff[MAXLINE];</span><br><span class="line">    <span class="keyword">time_t</span>              ticks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123; </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;listen_port&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( (listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));<span class="comment">//定义在&lt;string.h&gt;头文件中</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//头文件&lt;arpa/inet.h&gt;</span></span><br><span class="line">    servaddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));<span class="comment">//头文件&lt;arpa/inet.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bind()在头文件&lt;sys/socket.h&gt;中</span></span><br><span class="line">    <span class="keyword">if</span> ( bind(listenfd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;bind error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>)&#123;<span class="comment">//头文件&lt;sys/socket.h&gt;</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;listen error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((connfd = accept(listenfd, (struct sockaddr *) <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;accept error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">&quot;%.24s\r\n&quot;</span>, ctime(&amp;ticks));<span class="comment">//c头文件&lt;stdio.h&gt; 或c++头文件&lt;cstdlib&gt;</span></span><br><span class="line">        <span class="keyword">if</span> ( write(connfd, buff, <span class="built_in">strlen</span>(buff)) &lt; <span class="number">0</span> )&#123;<span class="comment">//头文件&lt;unisted&gt;</span></span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close(connfd) &lt; <span class="number">0</span>)&#123;<span class="comment">//头文件&lt;unisted&gt;</span></span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;close error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
    <summary type="html">&lt;h5 id=&quot;《UNIX-网络编程：卷1》学习记录1：&quot;&gt;&lt;a href=&quot;#《UNIX-网络编程：卷1》学习记录1：&quot; class=&quot;headerlink&quot; title=&quot;《UNIX 网络编程：卷1》学习记录1：&quot;&gt;&lt;/a&gt;《UNIX 网络编程：卷1》学习记录1：&lt;/h5&gt;&lt;p&gt;书本上有两个程序：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;1.2节：简单的 TCP 时间获取客户程序&lt;/li&gt;
&lt;li&gt;1.5节：简单的 TCP 时间获取服务器程序&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文记录的是我在学习过程编写的 C++ 版本的程序（但其实还是 C 程序，hahaha…），为了熟悉 UNIX 函数库，这里并没有基于书中的 &amp;lt;unp.h&amp;gt; 头文件来编写，而是全部自己添加 C 函数库中的头文件。程序如下：&lt;/p&gt;</summary>
    
    
    
    <category term="UNIX网络编程" scheme="http://caohuilong.github.io/categories/UNIX%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/"/>
    
    
    <category term="socket" scheme="http://caohuilong.github.io/tags/socket/"/>
    
  </entry>
  
  <entry>
    <title>基本排序算法实现</title>
    <link href="http://caohuilong.github.io/2018/10/25/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
    <id>http://caohuilong.github.io/2018/10/25/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</id>
    <published>2018-10-25T09:11:48.000Z</published>
    <updated>2018-10-25T09:11:48.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="基本的排序算法实现"><a href="#基本的排序算法实现" class="headerlink" title="基本的排序算法实现"></a>基本的排序算法实现</h3><p>本文介绍一些常见的基本排序算法的实现，以及相应的时间空间负责度分析。包括冒泡排序、插入排序、选择排序、归并排序、快速排序、堆排序这六种比较排序算法，以及计数排序这种线性时间排序算法。算法基于 C++ 语言实现。</p><a id="more"></a><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>学的第一个算法估计就是冒泡排序算法了。原理很简单，每次从左到右两两比较，把大的交换到后面，每次都会把当前未排序数组的最大元素放到最右边。</p><p><strong>步骤：</strong></p><ol><li>从左开始比较相邻的两个元素 nums[j] 和 nums[j+1]，如果 nums[j] &gt; nums[j+1] 就交换两者；</li><li>执行比较和交换，直到到达当前未排序数组的最后一个元素；</li><li>重复执行 1 和 2，直到当前未排序数组只有一个元素。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j+<span class="number">1</span> &lt; nums.size()-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>由于我们需要执行 n 次冒泡，每次冒泡要执行 n 次比较（实际是 1 到 n 的等差数列，也就是 <code>(1+n)n/2</code> ），所以总的时间复杂度是 <code>O(n^2)</code> ；只需要常数个额外的元素空间存储临时数据，空间复杂度为 <code>O(1)</code>。</p><hr><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><p>插入排序的原理是从左向右，把当前位置的数与它前面的数进行比较，找到最适合它的位置放入，使前面部分有序。</p><p><strong>步骤：</strong></p><ol><li>选出当前位置的数 nums[i]，从左向右，将 nums[i] 与它前面的每一个元素相比较，如果 nums[i] &lt; nums[j]，则将 nums[i] 与 nums[j] 交换；</li><li>再选择 nums[i+1] 与其前面的数进行比较。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>总共要插入 n 次，每次插入的复杂度是 O(n)，所以总的时间复杂度为 O(n^2)，空间复杂度为 O(1)。</p><hr><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><p>选择排序的原理是，每次都从乱序数组中找到最小值，放到当前乱序数组头部，最终使数组有序。</p><p><strong>步骤：</strong></p><ol><li>从左开始，选择后面元素中最小值，和当前元素交换；</li><li>直到未排序数组只有一个元素。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                             </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-1</span>; i++)&#123;                               </span><br><span class="line">        <span class="keyword">size_t</span> min_index = i;                                                 </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = i+<span class="number">1</span>; j &lt; nums.size(); j++)&#123;                           </span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min_index])&#123;                                   </span><br><span class="line">                min_index = j;                                                </span><br><span class="line">            &#125;                                                                 </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[min_index];</span><br><span class="line">        nums[mid_index] = temp;                                       </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>需要选择 n 次最小值，且每次选择最小值的复杂度又是 O(n)，所以总共的时间复杂度为 O(n^2)；空间复杂度为 O(1)。</p><hr><h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h3><p>归并排序是采用分治法的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。</p><p><strong>步骤：</strong></p><ol><li>把当前数组分化成 n 个单位为 1 的子数组，然后两两比较合并单位为 2 的 n/2 个子数组；</li><li>继续进行这个过程，按照 2 的倍数进行子数组的比较合并，直到最终数组有序；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                               </span><br><span class="line">    _merge_sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);                                      </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="keyword">void</span> _merge_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)&#123;          </span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end)&#123;                                                         </span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end)/<span class="number">2</span>;                                            </span><br><span class="line">        _merge_sort(nums, begin, mid);                                        </span><br><span class="line">        _merge_sort(nums, mid+<span class="number">1</span>, end);                                        </span><br><span class="line">        _merge(nums, begin, mid, end);                                        </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="keyword">void</span> _merge(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)&#123;      </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; <span class="comment">/* 非空间原址排序 */</span>                                     </span><br><span class="line">    <span class="keyword">int</span> i = begin, j = mid+<span class="number">1</span>;                                                 </span><br><span class="line">    <span class="keyword">while</span> ( (i != mid+<span class="number">1</span>) &amp;&amp; (j != end+<span class="number">1</span>) )&#123;                                   </span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j])                                               </span><br><span class="line">            tmp.push_back(nums[i++]);                                         </span><br><span class="line">        <span class="keyword">else</span>                                                                  </span><br><span class="line">            tmp.push_back(nums[j++]);                                         </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">while</span> ( i != mid+<span class="number">1</span> )                                                      </span><br><span class="line">        tmp.push_back(nums[i++]);                                             </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">while</span> ( j != end+<span class="number">1</span> )                                                      </span><br><span class="line">        tmp.push_back(nums[j++]);                                             </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++)                                   </span><br><span class="line">        nums[begin+i] = tmp[i];                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>采用分治法，可以将循环的次数减少为 logn，所以总共的时间复杂度为 O(nlogn)；</p><p>因为在合并数组时需要申请一个临时数组，所以算法的空间复杂度为 O(n)。</p><hr><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h3><p>快速排序算法也是利用分治法实现的一个排序算法。快速排序与归并排序不同，它不是一半一半的分子数组，而是选择一个主元，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同的步骤，直到整个数组有序。</p><p><strong>步骤：</strong></p><ol><li>选择一个主元，一般选择最后一个元素（或者随机选取，保证平均性能）；</li><li>将小于主元的移到左边，大于主元的移到右边；</li><li>递归的对子数组重复执行1,2，直到整个数组有序。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                               </span><br><span class="line">    _quick_sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);                                      </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="keyword">void</span> _quick_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> p, <span class="keyword">int</span> r)&#123;                </span><br><span class="line">    <span class="keyword">if</span> (p &lt; r)&#123;                                                               </span><br><span class="line">        <span class="keyword">int</span> q = _partition(nums, p, r);                                       </span><br><span class="line">        _quick_sort(nums, p, q<span class="number">-1</span>);                                            </span><br><span class="line">        _quick_sort(nums, q+<span class="number">1</span>, r);                                            </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="keyword">int</span> _partition(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> p, <span class="keyword">int</span> r)&#123;                  </span><br><span class="line">    <span class="keyword">int</span> x = nums[r];                                                          </span><br><span class="line">    <span class="keyword">int</span> i = p<span class="number">-1</span>;                                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt; r; j++)&#123;                                              </span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= x)&#123;                                                    </span><br><span class="line">            i = i+<span class="number">1</span>;                                                          </span><br><span class="line">            swap(nums[i], nums[j]);                                           </span><br><span class="line">        &#125;                                                                     </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">    swap(nums[i+<span class="number">1</span>], nums[r]);                                                 </span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>快速排序算法的平均时间复杂度为 O(nlogn)，但存在一些情况使得其时间复杂度为 O(n^2)，如数组是已排序的情况；</p><p>时间复杂度为 O(1)。</p><hr><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><p>堆排序常用于求一个数组中最大 k 个元素。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为单签堆中的最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前 k 大元素，或者使堆有序。（最小堆的概念与最大堆对应）</p><p><strong>步骤：</strong></p><ol><li>构造最大堆：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到比较到根节点。重复执行到最后一个元素。</li><li>调整最大堆：即将根节点移除后重新整理堆。整理方法为将根节点和最后一个节点交换，然后把堆看做n-1长度，将当前根节点逐步移动到其应该在的位置。</li><li>堆排序：重复执行2，直到所有根节点都已移除。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                                 </span><br><span class="line">    build_heap(nums);                                                         </span><br><span class="line">    <span class="keyword">int</span> heap_size = nums.size();                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size()<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)&#123;                                  </span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[i]);                                               </span><br><span class="line">        heap_size--;                                                          </span><br><span class="line">        heapify(nums, <span class="number">0</span>, heap_size);                                          </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size()/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)                              </span><br><span class="line">        heapify(nums, i, nums.size()<span class="number">-1</span>);                                      </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> root, <span class="keyword">int</span> heap_size)</span></span>&#123;          </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span>*root, right = <span class="number">2</span>*root+<span class="number">1</span>;                                      </span><br><span class="line">    <span class="keyword">int</span> max_index = root;                                                     </span><br><span class="line">    <span class="keyword">if</span> ( left &lt; heap_size &amp;&amp; nums[left] &gt; nums[root] )                        </span><br><span class="line">        max_index = left;                                                     </span><br><span class="line">    <span class="keyword">if</span> ( right &lt; heap_size &amp;&amp; nums[right] &gt; nums[max_index] )                 </span><br><span class="line">        max_index = right;                                                    </span><br><span class="line">    <span class="keyword">if</span> ( max_index != root )&#123;                                                 </span><br><span class="line">        swap(nums[max_index], nums[root]);                                    </span><br><span class="line">        heapify(nums, max_index, heap_size);                                  </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>堆执行一次调整需要 O(logn) 的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度为 O(nlogn)；空间复杂度为 O(1)。</p><h3 id="7-计数排序"><a href="#7-计数排序" class="headerlink" title="7. 计数排序"></a>7. 计数排序</h3><p>计数排序假设 n 个输入元素中的每一个都是在 0 到 k 区间内的一个整数，其中 k 为某个整数。当 k = O(n) 时，排序的运行时间为 O(n)。</p><p>计数排序的基本思想是：对每一个输入元素 x，确定小于 x 的元素个数。利用这一信息，就可以直接把 x 放到它在输出数组中的位置上了。</p><p>在计数排序算法的代码中，假设输入是一个数组 nums[0..n-1]，nums.size() = n。我们还需要两个数组： ans[0..n-1] 存放排序的输出，C[0..k] 提供临时存储空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans, <span class="keyword">int</span> k)</span></span>&#123;                  </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">C</span><span class="params">(k+<span class="number">1</span>, <span class="number">0</span>)</span></span>;                                                    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)                                  </span><br><span class="line">        C[nums[i]] = C[nums[i]] + <span class="number">1</span>;                                          </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)                                              </span><br><span class="line">        C[j] += C[j<span class="number">-1</span>];                                                       </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;                                 </span><br><span class="line">        ans[C[nums[i]]<span class="number">-1</span>] = nums[i];                                          </span><br><span class="line">        C[nums[i]] -= <span class="number">1</span>;                                                      </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度为 O(n)，空间复杂度也为 O(n)。</p><hr><h3 id="8-希尔排序"><a href="#8-希尔排序" class="headerlink" title="8. 希尔排序"></a>8. 希尔排序</h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破 O(n^2) 的第一批算法之一。</p><p>直接插入排序算法的算法时间复杂度为 O(n^2) ，但是，若待排记录序列为 “正序” 时，其时间复杂度可提高至 O(n)。另外一方面，当 n 值较小时，直接插入排序算法的效率也比较高。希尔排序算法正是从这两点分析出发对直接插入排序算法进行改进的。</p><p><strong>它的基本思想：先将整个待排序序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对整体序列进行一次直接插入排序。</strong></p><p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p><p><strong>基本步骤：</strong></p><p>在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png"></p><blockquote><p>以上希尔排序部分的内容摘自 <a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法（二）之希尔排序</a></p></blockquote><p><strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对有序序列在插入时采用交换法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = nums.size()/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)&#123;   </span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; nums.size(); i++)&#123;  </span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j-gap &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j-gap])&#123;</span><br><span class="line">                swap(nums[j], nums[j-gap]);   <span class="comment">//插入排序采用交换法</span></span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对有序序列在插入时采用移动法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = nums.size()/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[j];   <span class="comment">//记录nums[j]的值</span></span><br><span class="line">            <span class="keyword">while</span> (j-gap &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j-gap])&#123;</span><br><span class="line">                nums[j] = nums[j-gap];   <span class="comment">//把前一个值直接往后移</span></span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = tmp;   <span class="comment">//将记录的值放到该放的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列{n/2, (n/2)/2 , …,1}(希尔增量)，其最坏时间复杂度依然为O(n^2^)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n^3/2^)。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;基本的排序算法实现&quot;&gt;&lt;a href=&quot;#基本的排序算法实现&quot; class=&quot;headerlink&quot; title=&quot;基本的排序算法实现&quot;&gt;&lt;/a&gt;基本的排序算法实现&lt;/h3&gt;&lt;p&gt;本文介绍一些常见的基本排序算法的实现，以及相应的时间空间负责度分析。包括冒泡排序、插入排序、选择排序、归并排序、快速排序、堆排序这六种比较排序算法，以及计数排序这种线性时间排序算法。算法基于 C++ 语言实现。&lt;/p&gt;</summary>
    
    
    
    <category term="algorithm" scheme="http://caohuilong.github.io/categories/algorithm/"/>
    
    
    <category term="排序算法" scheme="http://caohuilong.github.io/tags/%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95/"/>
    
  </entry>
  
  <entry>
    <title>leetcode-141-142</title>
    <link href="http://caohuilong.github.io/2018/10/21/leetcode-141-142/"/>
    <id>http://caohuilong.github.io/2018/10/21/leetcode-141-142/</id>
    <published>2018-10-21T13:36:57.000Z</published>
    <updated>2018-10-21T13:36:57.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. <a href="https://leetcode.com/problems/linked-list-cycle/description/">Linked List Cycle</a></h3><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p><a id="more"></a><hr><h4 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h4><p>给定一个链表，判断链表中是否有环。不要有额外的空间消耗。</p><hr><h4 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h4><p><strong>双指针法：</strong></p><p>最常用的方法，快慢指针，慢指针每次移动一步，快指针一次移动两步。如果链表中没有环，那么快指针将先到达链表结尾，并且指向 NULL；如果链表中有环，则快指针会在环中循环，直到慢指针进入环中，快指针将会追上慢指针，两者相等。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)。如果链表中无环，则在快指针到达链表结尾时经过 N/2 步左右，所以复杂度为 O(N)；如果链表中有环，则最坏情况下，当慢指针几乎绕环一圈时快指针才追上它，所以是 N 步左右，所以复杂度为 O(N)。综上，时间复杂度为 O(N)。</li><li>空间复杂度：O(1)。只使用了两个指针。</li></ul><hr><h3 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. <a href="https://leetcode.com/problems/linked-list-cycle-ii/description/">Linked List Cycle II</a></h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Follow up</strong>:<br>Can you solve it without using extra space?</p><hr><h4 id="题意理解-1"><a href="#题意理解-1" class="headerlink" title="题意理解"></a>题意理解</h4><p>给定一个链表，如果链表中有环，返回环开始的节点；如果没有环，则返回 null。并且不能修改这个链表。</p><hr><h4 id="解法思路-1"><a href="#解法思路-1" class="headerlink" title="解法思路"></a>解法思路</h4><p>和上面那题一样，都是使用<strong>双指针法</strong>，但是要输出环开始的节点需要一些其他的计算。</p><p>假设经过 <strong>k</strong> 步，快慢指针相遇；假设<strong>环的长度</strong>是 <strong>r</strong>；所以有：<code>2k - k = nr</code>，即 <code>k = nr</code> （其中n表示快指针在环中循环的次数）。</p><p>假设<strong>链表表头</strong>到<strong>环的起点</strong>的距离为 s；假设<strong>环的起点</strong>到<strong>快慢指针相遇的节点</strong>的距离为 m；所以有：<code>s = k - m</code>。</p><p><code>s = nr - m = (n - 1) + (r - m)，n = 1,2,3,... </code></p><p>所以，可以再使用两个指针，慢指针从链表表头开始，每次移动一步；快指针从<strong>快慢指针相遇的节点</strong>开始，每次也移动一步，那么经过 s 步之后，快慢指针将会在<strong>环的起点</strong>相遇。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp;fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (slow == fast)&#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                fast = fast;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度和上一题一样，都为 O(N).</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;141-Linked-List-Cycle&quot;&gt;&lt;a href=&quot;#141-Linked-List-Cycle&quot; class=&quot;headerlink&quot; title=&quot;141. Linked List Cycle&quot;&gt;&lt;/a&gt;141. &lt;a href=&quot;https://leetcode.com/problems/linked-list-cycle/description/&quot;&gt;Linked List Cycle&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Given a linked list, determine if it has a cycle in it.&lt;/p&gt;
&lt;p&gt;Follow up:&lt;br&gt;Can you solve it without using extra space?&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://caohuilong.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://caohuilong.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>KVM 从虚拟机磁盘镜像创建虚拟机</title>
    <link href="http://caohuilong.github.io/2018/10/19/%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
    <id>http://caohuilong.github.io/2018/10/19/%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/</id>
    <published>2018-10-19T13:39:54.000Z</published>
    <updated>2018-10-19T13:39:54.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为教研室的网管，干了很多运维的工作，而一个高效的运维是必须少做重复性工作。教研室的网管做的最多的事就是在很多服务器上给很多同学分配很多虚拟机，由于同学们没法直接操作服务器，所以有时系统也是需要网管帮忙安装的，而安装系统的过程费时费力且没啥技术含量。所以最好的办法给各种系统保存一份模板镜像，如果同学需要一个虚拟机就给他复制一份，然后从镜像启动虚拟机，无需重复系统安装的过程，一人一个文件夹，方便管理。本文就将介绍如何在 KVM 环境下从磁盘镜像创建虚拟机。</p><a id="more"></a><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>这里假设保存的磁盘镜像格式为 qcow2 格式的，操作系统为 Linux ，并且后面的操作的磁盘名称为：ubuntu.qcow2。</p><h4 id="命令行实现："><a href="#命令行实现：" class="headerlink" title="命令行实现："></a>命令行实现：</h4><p>在命令行下，使用 virt-install 命令来安装虚拟机，这命令有很多选项，这里不详细介绍，可以通过 <code>man virt-install</code> 仔细查看。我们通常安装虚拟机都是通过系统 ISO 文件来安装系统，使用的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm --name ubuntu --ram 4096 --vcpus&#x3D;4 \</span><br><span class="line">    --cdrom&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu-16.04.4-desktop-amd64.iso \</span><br><span class="line">    --disk path&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,format&#x3D;qcow2 \</span><br><span class="line">    --network network&#x3D;br0,model&#x3D;virtio \</span><br><span class="line">    --graphics vnc,listen&#x3D;0.0.0.0, --noautoconsole \</span><br><span class="line">    --os-type&#x3D;linux</span><br></pre></td></tr></table></figure><p>但是以上方法每次都是重新安装系统，太麻烦。</p><p><strong>下面介绍从虚拟机磁盘文件创建虚拟机的命令</strong>，但是这和 virt-instal 工具的版本有关系（可能和KVM的版本也有关系），不同版本的选项略微有差别，使用如下命令查看版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ virt-install --version</span><br><span class="line">1.3.2  或  0.600.4 （我只接触过这两个版本）</span><br><span class="line"></span><br><span class="line">$ kvm -version</span><br><span class="line">QEMU emulator version 2.5.0 (Debian 1:2.5+dfsg-5ubuntu10.30), Copyright (c) 2003-2008 Fabrice Bellard</span><br><span class="line">或</span><br><span class="line"># kvm -version</span><br><span class="line">QEMU emulator version 2.0.0 (Debian 2.0.0+dfsg-2ubuntu1.33), Copyright (c) 2003-2008 Fabrice Bellard</span><br></pre></td></tr></table></figure><p><strong>一种兼容前后版本的命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm --name ubuntu --ram 4096 --vcpus&#x3D;4 \</span><br><span class="line">--import \</span><br><span class="line">--disk path&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,format&#x3D;qcow2 \</span><br><span class="line">--network bridge&#x3D;br0,model&#x3D;virtio \</span><br><span class="line">--graphics vnc,listen&#x3D;0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type&#x3D;linux</span><br></pre></td></tr></table></figure><p><strong>只适用于新版本的命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm --name docker-$1 --ram 4096 --vcpus&#x3D;4 \</span><br><span class="line">--cdrom&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2 \</span><br><span class="line">--disk path&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,format&#x3D;qcow2 \</span><br><span class="line">--network bridge&#x3D;br0,model&#x3D;virtio \</span><br><span class="line">--graphics vnc,listen&#x3D;0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type&#x3D;linux</span><br></pre></td></tr></table></figure><p>主要的区别就在于 –import 选项是兼容的，而使用 –cdrom 只适用于新版本。</p><hr><h4 id="图形界面实现："><a href="#图形界面实现：" class="headerlink" title="图形界面实现："></a>图形界面实现：</h4><p>对于图形界面就是通过 virt-manager 来实现，但是这种方法貌似只适用于较新版本KVM环境，步骤如下：</p><ol><li><p>打开 virtual machine mananger，-&gt; 点击右上角新建虚拟机</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%201.png?raw=true"></p></li><li><p>选择 Import existing disk image，-&gt; Forward</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%202.png?raw=true"></p></li><li><p>点击 Browse</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%203.png?raw=true"></p></li><li><p>点击 Browse Local，找到虚拟机磁盘镜像文件，-&gt;Choose Volume</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%204.png?raw=true"></p></li><li><p>点击 Forward</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%205.png?raw=true"></p></li><li><p>配置合适的内存和 CPU 个数，-&gt; Forward</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%206.png?raw=true"></p></li><li><p>给虚拟机命名（但注意这不是虚拟机里面的 hostname），-&gt; Finish</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%207.png?raw=true"></p></li><li><p>最后就会进入虚拟机的系统启动过程</p></li></ol><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>由于教研室有一些服务器的使用年限较长，有一些服务器的系统和软件版本较低，在使用 KVM 时碰到一些很烦人的问题，所以才写下这篇博客记录一下。如果在旧版本的环境下使用新环境才支持的命令选项，就可能会出现一些问题，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ virt-install --virt-type kvm --name docker-$1 --ram 4096 --vcpus&#x3D;4 \</span><br><span class="line">--cdrom&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2 \</span><br><span class="line">--disk path&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,format&#x3D;qcow2 \</span><br><span class="line">--network bridge&#x3D;br0,model&#x3D;virtio \</span><br><span class="line">--graphics vnc,listen&#x3D;0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type&#x3D;linux</span><br><span class="line"></span><br><span class="line">Starting install...</span><br><span class="line">ERROR    internal error: process exited while connecting to monitor: qemu-system-x86_64: -drive file&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,if&#x3D;none,id&#x3D;drive-ide0-0-0,format&#x3D;qcow2: could not open disk image &#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2: Could not open &#39;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2&#39;: Permission denied</span><br><span class="line"></span><br><span class="line">Domain installation does not appear to have been successful.</span><br><span class="line">If it was, you can restart your domain by running:</span><br><span class="line">  virsh --connect qemu:&#x2F;&#x2F;&#x2F;system start hgh</span><br><span class="line">otherwise, please restart your installation.</span><br></pre></td></tr></table></figure><p>上面出现的错误就是由于软件版本的不同导致的，所以最好使用兼容的命令选项。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h2 id=&quot;概述&quot;&gt;&lt;a href=&quot;#概述&quot; class=&quot;headerlink&quot; title=&quot;概述&quot;&gt;&lt;/a&gt;概述&lt;/h2&gt;&lt;p&gt;作为教研室的网管，干了很多运维的工作，而一个高效的运维是必须少做重复性工作。教研室的网管做的最多的事就是在很多服务器上给很多同学分配很多虚拟机，由于同学们没法直接操作服务器，所以有时系统也是需要网管帮忙安装的，而安装系统的过程费时费力且没啥技术含量。所以最好的办法给各种系统保存一份模板镜像，如果同学需要一个虚拟机就给他复制一份，然后从镜像启动虚拟机，无需重复系统安装的过程，一人一个文件夹，方便管理。本文就将介绍如何在 KVM 环境下从磁盘镜像创建虚拟机。&lt;/p&gt;</summary>
    
    
    
    <category term="KVM" scheme="http://caohuilong.github.io/categories/KVM/"/>
    
    
    <category term="KVM" scheme="http://caohuilong.github.io/tags/KVM/"/>
    
    <category term="virt-install" scheme="http://caohuilong.github.io/tags/virt-install/"/>
    
  </entry>
  
  <entry>
    <title>110. Balanced Binary Tree</title>
    <link href="http://caohuilong.github.io/2018/10/18/leetcode-110/"/>
    <id>http://caohuilong.github.io/2018/10/18/leetcode-110/</id>
    <published>2018-10-18T07:18:24.000Z</published>
    <updated>2018-10-18T07:18:24.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. <a href="https://leetcode.com/problems/balanced-binary-tree/description/">Balanced Binary Tree</a></h3><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><blockquote><p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p></blockquote><a id="more"></a><p><strong>Example 1:</strong></p><p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>Return true.<br><strong>Example 2:</strong></p><p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>Return false.</p><hr><h3 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h3><hr><p>给定一个二叉树（是任意二叉树，而不是二叉搜索树），判断其是否是高度平衡的。高度平衡二叉树的定义就是：</p><blockquote><p>对于二叉树的每一个节点，其左右子树的高度相差最大不超过 1 。</p></blockquote><p>根据上面的定义，简单地认为只需要根节点的左右子树的高度相差不超过 1 是错误的，必须保证每一个节点都满足该条件。</p><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h3><hr><p><strong>初始思路：</strong></p><p>按照高度平衡二叉树的定义，可以想到通过遍历每一个节点，然后求每个节点的左右子树的高度，最后比较左右子树的高度差是否大于 1，当高度差大于时则返回 false，否则返回 true。实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + max(getHeight(root-&gt;left), getHeight(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = getHeight(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析：求个节点的高度调用 getHeight() 花费的时间复杂度是 O(N)，遍历所有节点又需要 O(N)，因此总的时间复杂度是 O(N^2)。</p></blockquote><p><strong>改进思路：</strong></p><p>对于上面的方法，是从根往下，在求每一个节点的高度时都会遍历其子节点，这些操作有很多时重复的。如果可以每个节点的高度都保存下来就好了。对于这个题目，节点的值是没有用的，因此可以用节点的值来存放其高度，这样就没有额外的空间消耗。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">storeHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        storeHeight(root-&gt;left);</span><br><span class="line">        storeHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;val = <span class="number">1</span> + max(root-&gt;left-&gt;val, root-&gt;right-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;val = <span class="number">1</span> + root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;val =<span class="number">1</span>+root-&gt;right-&gt;val;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root-&gt;val = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = root-&gt;left == <span class="literal">NULL</span>? <span class="number">0</span> : root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> right = root-&gt;right == <span class="literal">NULL</span>? <span class="number">0</span> : root-&gt;right-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; helper(root-&gt;left) &amp;&amp; helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        storeHeight(root);</span><br><span class="line">        <span class="keyword">return</span> helper(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析：算法首先求出二叉树各节点的高度，时间复杂度为 O(N)；然后再递归的计算每个节点左右子树的高度差是否小于等于 1，时间复杂度也为 O(N)。所以总的时间复杂度为 O(N) + O(N) = O(N)。</p></blockquote><p><strong>最终解法：</strong></p><p>在递归的计算二叉树中每个节点的高度时，如果两个子树的高度相差小于等于 1，则记录该节点真实的高度值，否则记录为 -1；并且在递归求某节点的高度时判断其左右孩子的高度值是否记录的是 -1，如果是，说明其左右子树中有非平衡树，则将该节点的高度值记为 -1。最后判断根节点的高度值是否为 -1，若为 -1，说明该二叉树不是高度平衡的；若不为 -1，说明该二叉树是高度平衡的。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfsHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = dfsHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right = dfsHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(left, right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dfsHeight(root) == <span class="number">-1</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析：只需要遍历一遍所有节点即可，时间复杂度为 O(N)。</p></blockquote><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;110-Balanced-Binary-Tree&quot;&gt;&lt;a href=&quot;#110-Balanced-Binary-Tree&quot; class=&quot;headerlink&quot; title=&quot;110. Balanced Binary Tree&quot;&gt;&lt;/a&gt;110. &lt;a href=&quot;https://leetcode.com/problems/balanced-binary-tree/description/&quot;&gt;Balanced Binary Tree&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Given a binary tree, determine if it is height-balanced.&lt;/p&gt;
&lt;p&gt;For this problem, a height-balanced binary tree is defined as:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;a binary tree in which the depth of the two subtrees of &lt;em&gt;every&lt;/em&gt; node never differ by more than 1.&lt;/p&gt;
&lt;/blockquote&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://caohuilong.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://caohuilong.github.io/tags/LeetCode/"/>
    
  </entry>
  
  <entry>
    <title>107. Binary Tree Level Order Traversal II</title>
    <link href="http://caohuilong.github.io/2018/10/17/leetcode-107/"/>
    <id>http://caohuilong.github.io/2018/10/17/leetcode-107/</id>
    <published>2018-10-17T04:35:17.000Z</published>
    <updated>2018-10-17T04:35:17.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a>107. <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/">Binary Tree Level Order Traversal II</a></h3><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its bottom-up level order traversal as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h3 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h3><p>给定一个二叉树，要求自底向上，自左向右的按层输出二叉树各节点的值。输出保存在一个二维数组中，也就是一个数组的数组，外层数组的元素是二叉树每一层节点的值的集合。</p><hr><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h3><h5 id="解法一：DFS（Depth-First-Search）"><a href="#解法一：DFS（Depth-First-Search）" class="headerlink" title="解法一：DFS（Depth-First-Search）"></a>解法一：DFS（Depth-First-Search）</h5><p>可以知道的是，输出的二维数组中用一个数组来保存二叉树中的每一层的节点的值，且该内层数组在外层数组中的下标索引刚好与这些节点在树中的高度相反。所以可以利用 DFS 来遍历二叉树，根据节点在树中的高度，找到数组中保存该层元素的内层数组，将节点的值插入，最后只需将整个数组反转即可。对于二叉树的深度优先搜索，可以考虑用递归或者栈来实现。</p><p><strong>DFS with recursive：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        levelRecursive(res, root, <span class="number">0</span>);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelRecursive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, TreeNode* root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; level+<span class="number">1</span>)&#123;  <span class="comment">//判断是否已经有内层数组来存放该层节点的值</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        res[level].push_back(root-&gt;val);</span><br><span class="line">        levelRecursive(res, root-&gt;left, level+<span class="number">1</span>);</span><br><span class="line">        levelRecursive(res, root-&gt;right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DFS with stack：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; <span class="built_in">stack</span>;  <span class="comment">//用一个pair来存放节点和节点在书中的深度</span></span><br><span class="line">        <span class="built_in">stack</span>.push_back(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; p = <span class="built_in">stack</span>.back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            <span class="keyword">if</span> (res.size() &lt; p.second + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            &#125;</span><br><span class="line">            res[p.second].push_back(p.first-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push_back(&#123;p.first-&gt;right, p.second+<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push_back(&#123;p.first-&gt;left, p.second+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解法二：BFS（Breadth-First-Search）"><a href="#解法二：BFS（Breadth-First-Search）" class="headerlink" title="解法二：BFS（Breadth-First-Search）"></a>解法二：BFS（Breadth-First-Search）</h5><p>使用队列来存放每一层的节点，在 while 循环中又有一个 for 循环来遍历每一层的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode* &gt; q;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                level.push_back(q.front()-&gt;val);</span><br><span class="line">                TreeNode* p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong>以上解法的时间复杂度及空间复杂度都为 O(N)。</p><hr>]]></content>
    
    
    <summary type="html">&lt;h3 id=&quot;107-Binary-Tree-Level-Order-Traversal-II&quot;&gt;&lt;a href=&quot;#107-Binary-Tree-Level-Order-Traversal-II&quot; class=&quot;headerlink&quot; title=&quot;107. Binary Tree Level Order Traversal II&quot;&gt;&lt;/a&gt;107. &lt;a href=&quot;https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/&quot;&gt;Binary Tree Level Order Traversal II&lt;/a&gt;&lt;/h3&gt;&lt;p&gt;Given a binary tree, return the &lt;em&gt;bottom-up level order&lt;/em&gt; traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).&lt;/p&gt;
&lt;p&gt;For example:&lt;br&gt;Given binary tree &lt;code&gt;[3,9,20,null,null,15,7]&lt;/code&gt;,&lt;/p&gt;</summary>
    
    
    
    <category term="LeetCode" scheme="http://caohuilong.github.io/categories/LeetCode/"/>
    
    
    <category term="LeetCode" scheme="http://caohuilong.github.io/tags/LeetCode/"/>
    
  </entry>
  
</feed>
