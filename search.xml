<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>cgroups如何工作？</title>
      <link href="2021/10/11/cgroups%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F/"/>
      <url>2021/10/11/cgroups%E5%A6%82%E4%BD%95%E5%B7%A5%E4%BD%9C%EF%BC%9F/</url>
      
        <content type="html"><![CDATA[<p>cgroups是docker容器的三大关键技术之一，它是Linux内核中用来给进程设置资源限制的一个重要功能，可以被限制的资源包括CPU、内存、磁盘、网络带宽等等。</p><h4 id="基本原理"><a href="#基本原理" class="headerlink" title="基本原理"></a>基本原理</h4><p>在 Linux 中，Cgroups 给用户暴露出来的操作接口是文件系统，即它以文件和目录的方式组织在操作系统的 /sys/fs/cgroup 路径下。使用mount命令把它们展示出来，结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"># mount -t cgroup</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;systemd type cgroup (rw,nosuid,nodev,noexec,relatime,xattr,name&#x3D;systemd)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;blkio type cgroup (rw,nosuid,nodev,noexec,relatime,blkio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;net_cls,net_prio type cgroup (rw,nosuid,nodev,noexec,relatime,net_cls,net_prio)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;hugetlb type cgroup (rw,nosuid,nodev,noexec,relatime,hugetlb)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu,cpuacct type cgroup (rw,nosuid,nodev,noexec,relatime,cpu,cpuacct)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;pids type cgroup (rw,nosuid,nodev,noexec,relatime,pids)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpuset type cgroup (rw,nosuid,nodev,noexec,relatime,cpuset)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;devices type cgroup (rw,nosuid,nodev,noexec,relatime,devices)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;perf_event type cgroup (rw,nosuid,nodev,noexec,relatime,perf_event)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;rdma type cgroup (rw,nosuid,nodev,noexec,relatime,rdma)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;memory type cgroup (rw,nosuid,nodev,noexec,relatime,memory)</span><br><span class="line">cgroup on &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;freezer type cgroup (rw,nosuid,nodev,noexec,relatime,freezer)</span><br></pre></td></tr></table></figure><p>这条命令的输出结果，是一系列的文件系统目录，可以看到很多诸如cpuset、cpu、memory这样的子目录，也叫子系统。这些都是我这台机器当前可以被 Cgroups 进行限制的资源种类。而在子系统对应的资源种类下，你就可以看到该类资源具体可以被限制的方法。比如，对 CPU 子系统来说，我们就可以看到如下几个配置文件，这个指令是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">p# ls &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu</span><br><span class="line">cgroup.clone_children  cpuacct.stat       cpuacct.usage_percpu       cpuacct.usage_sys   cpu.cfs_quota_us  notify_on_release  tasks</span><br><span class="line">cgroup.procs           cpuacct.usage      cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares        release_agent      user.slice</span><br><span class="line">cgroup.sane_behavior   cpuacct.usage_all  cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat          system.slice</span><br></pre></td></tr></table></figure><p>以上配置文件的名称代表了对应参数的作用，比如 cpu.cfs_period_us 和 cpu.cfs_quota_us 组合起来使用，表示限制进程在长度为 cfs_period_us 的一段时间内，只能被分配到总量为 cfs_quota_us 的 CPU 时间。</p><h4 id="cgroup使用案例"><a href="#cgroup使用案例" class="headerlink" title="cgroup使用案例"></a>cgroup使用案例</h4><p>你需要在对应的子系统下面创建一个目录，比如，我们现在进入 /sys/fs/cgroup/cpu 目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">root@Virtual-Machine:&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu# mkdir container</span><br><span class="line">root@Virtual-Machine:&#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu# ls container&#x2F;</span><br><span class="line">cgroup.clone_children  cpuacct.usage         cpuacct.usage_percpu_sys   cpuacct.usage_user  cpu.shares      cpu.uclamp.min</span><br><span class="line">cgroup.procs           cpuacct.usage_all     cpuacct.usage_percpu_user  cpu.cfs_period_us   cpu.stat        notify_on_release</span><br><span class="line">cpuacct.stat           cpuacct.usage_percpu  cpuacct.usage_sys          cpu.cfs_quota_us    cpu.uclamp.max  tasks</span><br></pre></td></tr></table></figure><p>这个目录就称为一个“控制组”。你会发现，操作系统会在你新创建的 container 目录下，自动生成该子系统对应的资源限制文件。</p><p>现在，我们在后台执行这样一条脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># while : ; do : ; done &amp;</span><br><span class="line">[1] 16622</span><br></pre></td></tr></table></figure><p>显然，它执行了一个死循环，可以把计算机的 CPU 吃到 100%，根据它的输出，我们可以看到这个脚本在后台运行的进程号（PID）是 16622。</p><p>这样，我们可以用 top 指令来确认一下 CPU 有没有被打满：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># top</span><br><span class="line">%Cpu(s): 98.9.0 us,  2.0 sy,  0.0 ni,  0.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure><p>在输出里可以看到，CPU 的使用率已经接近 100% 了（%Cpu0 :98.9.0 us）。</p><p>而此时，我们可以通过查看 container 目录下的文件，看到 container 控制组里的 CPU quota还没有任何限制（即：-1），CPU period 则是默认的 100 ms（100000 us）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_quota_us</span><br><span class="line">-1</span><br><span class="line"></span><br><span class="line"># cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_period_us</span><br><span class="line">100000</span><br></pre></td></tr></table></figure><p>接下来，我们可以通过修改这些文件的内容来设置限制。<br>比如，向 container 组里的 cfs_quota 文件写入 20 ms（20000 us）：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo 20000 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;cpu.cfs_quota_us</span><br></pre></td></tr></table></figure><p>结合前面的介绍，你应该能明白这个操作的含义，它意味着在每 100 ms 的时间里，被该控制组限制的进程只能使用 20 ms 的 CPU 时间，也就是说这个进程只能使用到 20% 的 CPU 带宽。接下来，我们把被限制的进程的 PID 写入 container 组里的 tasks 文件，上面的设置就会对该进程生效了：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># echo 16622 &gt; &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;container&#x2F;tasks</span><br></pre></td></tr></table></figure><p>我们可以用 top 指令查看一下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># top</span><br><span class="line">%Cpu(s): 20.3 us,  2.6 sy,  0.0 ni, 73.2 id,  1.0 wa,  0.0 hi,  0.0 si,  0.0 st</span><br></pre></td></tr></table></figure><p>可以看到，计算机的 CPU 使用率立刻降到了 20%（%Cpu0 : 20.3 us）。除 CPU 子系统外，Cgroups 的每一项子系统都有其独有的资源限制能力，比如：</p><ul><li>blkio，为 块 设 备 设 定 I/O 限 制，一般用于磁盘等设备；</li><li>cpuset，为进程分配单独的 CPU 核和对应的内存节点；</li><li>memory，为进程设定内存使用的限制。</li></ul><p>Linux Cgroups 的设计还是比较易用的，简单粗暴地理解呢，它就是一个子系统目录加上一组资源限制文件的组合。而对于 Docker 等 Linux 容器项目来说，它们只需要在每个子系统下面，为每个容器创建一个控制组（即创建一个新目录），然后在启动容器进程之后，把这个进程的 PID 填写到对应控制组的 tasks 文件中就可以了。</p><p>而至于在这些控制组下面的资源文件里填上什么值，就靠用户执行 docker run 时的参数指定了，比如这样一条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># docker run -it --cpu-period&#x3D;100000 --cpu-quota&#x3D;20000 ubuntu &#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><p>在启动这个容器后，我们可以通过查看 Cgroups 文件系统下，CPU 子系统中，“docker”这个控制组里的资源限制文件的内容来确认：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;5d5c9f67d&#x2F;cpu.cfs_period_us</span><br><span class="line">100000</span><br><span class="line"></span><br><span class="line"># cat &#x2F;sys&#x2F;fs&#x2F;cgroup&#x2F;cpu&#x2F;docker&#x2F;5d5c9f67d&#x2F;cpu.cfs_quota_us</span><br><span class="line">20000</span><br></pre></td></tr></table></figure><p>这就意味着这个 Docker 容器，只能使用到 20% 的 CPU 带宽。</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> cgroups </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>反转链表及其变体</title>
      <link href="2021/08/17/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/"/>
      <url>2021/08/17/%E5%8F%8D%E8%BD%AC%E9%93%BE%E8%A1%A8%E5%8F%8A%E5%85%B6%E5%8F%98%E4%BD%93/</url>
      
        <content type="html"><![CDATA[<p>本文记录反转链表的几个典型例题，从迭代和递归的两种方法解决以下几个问题：</p><ul><li><a href="https://leetcode-cn.com/problems/reverse-linked-list/">反转链表</a></li><li>反转链表前N个节点</li><li><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">反转链表 II</a></li><li><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">K 个一组翻转链表</a></li></ul><a id="more"></a><h5 id="206-反转链表"><a href="#206-反转链表" class="headerlink" title="206. 反转链表"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list/">206. 反转链表</a></h5><p><strong>题目：</strong>给你单链表的头节点 <code>head</code> ，请你反转链表，并返回反转后的链表。</p><p><strong>1、迭代解法：</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">tmp := cur.Next<span class="comment">// 暂存 cur 的 next 节点</span></span><br><span class="line">cur.Next = pre<span class="comment">// 将 pre 节点赋值给 cur.Next</span></span><br><span class="line">pre = cur<span class="comment">// pre向后移动一步</span></span><br><span class="line">cur = tmp<span class="comment">// cur向后移动一步</span></span><br></pre></td></tr></table></figure><p>可以把上面的步骤合并成一句，完整代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> cur != <span class="literal">nil</span> &#123;</span><br><span class="line">        pre, cur, cur.Next = cur, cur.Next, pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>定义 pre 节点的时候，用 <code>var</code> 关键字声明并初始化为零值，即 nil。如果用短变量声明操作符 <code>:=</code> 做不到将 pre 设置为 nil。</p></blockquote><p><strong>2、递归解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseList</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> || head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    last := reverseList(head.Next)</span><br><span class="line">    head.Next.Next = head</span><br><span class="line">    head.Next = <span class="literal">nil</span></span><br><span class="line">    <span class="keyword">return</span> last</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>递归解法的时间复杂度与迭代解法一样都是O(N)，但是递归使用的栈空间大小是 O(N)，而迭代解法是 O(1)。但是递归解法思路很清晰，就是将一个大的问题化解为一个更小一点的问题，直到临界情况下直接返回结果即可，这对后续题目的解决提供了一种思路。</p><hr><h5 id="反转链表前N个节点"><a href="#反转链表前N个节点" class="headerlink" title="反转链表前N个节点"></a>反转链表前N个节点</h5><p><strong>题目：</strong>将链表的前 n 个节点反转（n &lt;= 链表长度）</p><p><strong>1、迭代解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    cur := head</span><br><span class="line">    i := <span class="number">0</span></span><br><span class="line">    <span class="keyword">for</span> i &lt; n &#123;</span><br><span class="line">        pre, cur, cur.Next = cur, cur.Next, pre</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line">    preHead.Next.Next = cur</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、递归解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> successor  *ListNode<span class="comment">// 用于记录第n个节点的next节点 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> helper <span class="function"><span class="keyword">func</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span></span><br><span class="line">    helper = <span class="function"><span class="keyword">func</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">            successor = head.Next</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        last := helper(head.Next, n<span class="number">-1</span>)</span><br><span class="line">        head.Next.Next = head</span><br><span class="line">        head.Next = successor</span><br><span class="line">        <span class="keyword">return</span> last</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(head, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="92-反转链表-II"><a href="#92-反转链表-II" class="headerlink" title="92. 反转链表 II"></a><a href="https://leetcode-cn.com/problems/reverse-linked-list-ii/">92. 反转链表 II</a></h5><p><strong>题目：</strong>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;= right 。请你反转从位置 left 到位置 right 的链表节点，返回反转后的链表。</p><p><strong>1、迭代解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    pre, cur, next := preHead, head, head.Next</span><br><span class="line">    i := <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> i &lt; left &#123;</span><br><span class="line">            pre, cur, next = cur, next, next.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> i &gt;= left &amp;&amp; i &lt; right &#123;</span><br><span class="line">            cur, next, next.Next = next, next.Next, cur</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            pre.Next.Next = next<span class="comment">// 当超过范围之后，将pre.Next节点next节点指向next</span></span><br><span class="line">            pre.Next = cur<span class="comment">// pre节点的next指向指向cur</span></span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">        i++</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、递归解法</strong></p><p>当left = 1时，利用reverseN的思路求解。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseBetween</span><span class="params">(head *ListNode, left <span class="keyword">int</span>, right <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> left == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> reverseN(head, right)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    head.Next = reverseBetween(head.Next, left<span class="number">-1</span>, right<span class="number">-1</span>)</span><br><span class="line">    <span class="keyword">return</span> head</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseN</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> successor  *ListNode<span class="comment">// 用于记录第n个节点的next节点 </span></span><br><span class="line">    </span><br><span class="line">    <span class="keyword">var</span> helper <span class="function"><span class="keyword">func</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span></span><br><span class="line">    helper = <span class="function"><span class="keyword">func</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">        <span class="keyword">if</span> n == <span class="number">1</span> &#123;</span><br><span class="line">            successor = head.Next</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        last := helper(head.Next, n<span class="number">-1</span>)</span><br><span class="line">        head.Next.Next = head</span><br><span class="line">        head.Next = successor</span><br><span class="line">        <span class="keyword">return</span> last</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> helper(head, n)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="25-K-个一组翻转链表"><a href="#25-K-个一组翻转链表" class="headerlink" title="25. K 个一组翻转链表"></a><a href="https://leetcode-cn.com/problems/reverse-nodes-in-k-group/">25. K 个一组翻转链表</a></h5><p><strong>题目：</strong>给你一个链表，每 k 个节点一组进行翻转，请你返回翻转后的链表。</p><p>k 是一个正整数，它的值小于或等于链表的长度。</p><p>如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p><p><strong>1、迭代解法</strong></p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;Next: head&#125;</span><br><span class="line">    pre := preHead</span><br><span class="line">    <span class="keyword">for</span> head != <span class="literal">nil</span> &#123;</span><br><span class="line">        tail := pre</span><br><span class="line">        <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">            tail = tail.Next</span><br><span class="line">            <span class="keyword">if</span> tail == <span class="literal">nil</span> &#123;</span><br><span class="line">                <span class="keyword">return</span> preHead.Next</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        next := tail.Next</span><br><span class="line">        head, tail = reverse(head, tail)</span><br><span class="line">        pre.Next = head</span><br><span class="line">        tail.Next = next</span><br><span class="line">        pre = tail</span><br><span class="line">        head = tail.Next</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(head, tail *ListNode)</span> <span class="params">(*ListNode, *ListNode)</span></span> &#123;</span><br><span class="line">    pre := tail.Next</span><br><span class="line">    cur := head</span><br><span class="line">    <span class="keyword">for</span> pre != tail &#123;</span><br><span class="line">        next := cur.Next</span><br><span class="line">        cur.Next = pre</span><br><span class="line">        pre = cur</span><br><span class="line">        cur = next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> tail, head</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>2、递归解法</strong></p><p>每k个节点递归，对k个节点反转利用反转链表的思路：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverseKGroup</span><span class="params">(head *ListNode, k <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> k == <span class="number">1</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    a, b := head, head</span><br><span class="line">    <span class="keyword">for</span> i := <span class="number">0</span>; i &lt; k; i++ &#123;</span><br><span class="line">        <span class="keyword">if</span> b == <span class="literal">nil</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> head</span><br><span class="line">        &#125;</span><br><span class="line">        b = b.Next</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    newHead := reverse(a, b)</span><br><span class="line">    a.Next = reverseKGroup(b, k)</span><br><span class="line">    <span class="keyword">return</span> newHead</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 反转[a, b)的节点，当b=nil时，即反转整个链表</span></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">reverse</span><span class="params">(a, b *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">var</span> pre *ListNode</span><br><span class="line">    cur := a</span><br><span class="line">    <span class="keyword">for</span> cur != b &#123;</span><br><span class="line">        pre, cur, cur.Next = cur, cur.Next, pre</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> pre</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 反转链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>单链表解题技巧</title>
      <link href="2021/08/11/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/"/>
      <url>2021/08/11/%E5%8D%95%E9%93%BE%E8%A1%A8%E8%A7%A3%E9%A2%98%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<p>单链表是经典题型，本文列出了单链表最常出现的部分题型，并给出了每道题最合适最高效的解决方法，主要的解题方法技巧包含以下三种：</p><ul><li>双指针</li><li>快慢指针</li><li>最小堆</li></ul><a id="more"></a><h5 id="1、合并两个有序链表"><a href="#1、合并两个有序链表" class="headerlink" title="1、合并两个有序链表"></a>1、合并两个有序链表</h5><p><strong>依次迭代</strong>：设置一个伪头节点 preHead 用于指向返回结果的头节点，并将当前节点 cur 指向 preHead。然后对比两个链表的头节点，将 cur 的next指向更小的节点，并将该链表的头节点指向下一个节点。直到有一个链表为空，将另一个链表的剩余部分拼接到 cur 的next节点即可。最后返回伪头节点的 next 节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeTwoLists</span><span class="params">(l1 *ListNode, l2 *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;&#125;<span class="comment">// dummy节点，用于返回结果</span></span><br><span class="line">    cur := preHead</span><br><span class="line">    <span class="keyword">for</span> l1 != <span class="literal">nil</span> &amp;&amp; l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">if</span> l1.Val &lt; l2.Val &#123;</span><br><span class="line">            cur.Next = l1</span><br><span class="line">            l1 = l1.Next</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            cur.Next = l2</span><br><span class="line">            l2 = l2.Next</span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l1 != <span class="literal">nil</span> &#123;</span><br><span class="line">        cur.Next = l1</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> l2 != <span class="literal">nil</span> &#123;</span><br><span class="line">        cur.Next = l2</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>时间复杂度：O(N)</p></li><li><p>空间复杂度：O(1)</p></li></ul><hr><h5 id="2、合并-k-个有序链表"><a href="#2、合并-k-个有序链表" class="headerlink" title="2、合并 k 个有序链表"></a>2、合并 <code>k</code> 个有序链表</h5><p><strong>最小堆</strong>：利用 go 语言的提供的 heap 堆，自己实现 heap.Interface 接口定义的五个方法，从而实现一个最小堆。将所有的链表的头节点放入堆中，然后取出堆顶节点放入结果链表中，判断该节点的next节点是否为 nil，如果是 nil 表示该节点所在链表已遍历完毕；如果不是 nil，则将该节点的next节点放入堆中。继续遍历，直到堆的长度为0，表示所有的链表都已遍历完毕。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">mergeKLists</span><span class="params">(lists []*ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    h := &amp;minHeap&#123;&#125;</span><br><span class="line">    <span class="keyword">for</span> _, list := <span class="keyword">range</span> lists &#123;</span><br><span class="line">        <span class="keyword">if</span> list != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, list)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    preHead := &amp;ListNode&#123;&#125;</span><br><span class="line">    cur := preHead</span><br><span class="line">    <span class="keyword">for</span> h.Len() &gt; <span class="number">0</span> &#123;</span><br><span class="line">        tmp := heap.Pop(h).(*ListNode)<span class="comment">// 从堆中找出最小的节点，插入到结果链表</span></span><br><span class="line">        cur.Next = tmp</span><br><span class="line">        <span class="keyword">if</span> tmp.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">            heap.Push(h, tmp.Next)<span class="comment">// 将最小节点的next节点放入堆中</span></span><br><span class="line">        &#125;</span><br><span class="line">        cur = cur.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">type</span> minHeap []*ListNode</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span> <span class="title">Len</span><span class="params">()</span> <span class="title">int</span></span>           &#123; <span class="keyword">return</span> <span class="built_in">len</span>(h) &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span> <span class="title">Less</span><span class="params">(i, j <span class="keyword">int</span>)</span> <span class="title">bool</span></span> &#123; <span class="keyword">return</span> h[i].Val &lt; h[j].Val &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h minHeap)</span> <span class="title">Swap</span><span class="params">(i, j <span class="keyword">int</span>)</span></span>      &#123; h[i], h[j] = h[j], h[i] &#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span> <span class="title">Push</span><span class="params">(x <span class="keyword">interface</span>&#123;&#125;)</span></span> &#123;</span><br><span class="line">*h = <span class="built_in">append</span>(*h, x.(*ListNode))</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="params">(h *minHeap)</span> <span class="title">Pop</span><span class="params">()</span> <span class="title">interface</span></span>&#123;&#125; &#123;</span><br><span class="line">old := *h</span><br><span class="line">n := <span class="built_in">len</span>(old)</span><br><span class="line">x := old[n<span class="number">-1</span>]</span><br><span class="line">*h = old[<span class="number">0</span> : n<span class="number">-1</span>]</span><br><span class="line"><span class="keyword">return</span> x</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>假设链表数量是 k，链表长度是 N：</p><ul><li>时间复杂度：O(Nlogk)</li><li>空间复杂度：O(k)</li></ul><hr><h5 id="3、寻找-删除单链表的倒数第-k-个节点"><a href="#3、寻找-删除单链表的倒数第-k-个节点" class="headerlink" title="3、寻找/删除单链表的倒数第 k 个节点"></a>3、寻找/删除单链表的倒数第 <code>k</code> 个节点</h5><p><strong>双指针</strong>：first 指针先从链表头节点移动 k 步，然后 second 与 first 指针同时移动，当 first 指针指向链表尾部的时候，second 指针指向的就是链表的倒数第 k 个节点。</p><p>寻找和删除倒数第 k 个节点都是相同的思路，下面的代码展示的是删除，不同点在于用了一个 pre 指针指向 second 节点，用于删除要删除的节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">removeNthFromEnd</span><span class="params">(head *ListNode, n <span class="keyword">int</span>)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    preHead := &amp;ListNode&#123;</span><br><span class="line">        Next: head,</span><br><span class="line">    &#125;</span><br><span class="line">    first := head</span><br><span class="line">    <span class="keyword">for</span> n &gt; <span class="number">0</span> &#123;<span class="comment">// 第一个节点先移动n步</span></span><br><span class="line">        first = first.Next</span><br><span class="line">        n--</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    pre, second := preHead, head</span><br><span class="line">    <span class="keyword">for</span> first != <span class="literal">nil</span> &#123;<span class="comment">// 两个节点一起移动，直到first到达链表尾部</span></span><br><span class="line">        pre, second = second, second.Next</span><br><span class="line">        first = first.Next</span><br><span class="line">    &#125;</span><br><span class="line">    pre.Next = second.Next</span><br><span class="line">    <span class="keyword">return</span> preHead.Next</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><hr><h5 id="4、寻找单链表的中点"><a href="#4、寻找单链表的中点" class="headerlink" title="4、寻找单链表的中点"></a>4、寻找单链表的中点</h5><p><strong>快慢指针</strong>：slow 每次移动一步，fast 每次移动两步，当 fast 或者 fast.Next 为空时，slow指针移到了链表的中间节点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">middleNode</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head.Next == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> head</span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> slow</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><hr><h5 id="5、判断单链表是否包含环并找出环起点"><a href="#5、判断单链表是否包含环并找出环起点" class="headerlink" title="5、判断单链表是否包含环并找出环起点"></a>5、判断单链表是否包含环并找出环起点</h5><p><strong>快慢指针</strong>：首先，快慢指针都从表头开始移动，慢指针每次移动一步，快指针每次移动两步，直到两者相遇；然后将快指针指向链表表头，快慢指针再以相同的速度向后移动，当两者再次相遇时，相遇的位置就是环的起点。</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">detectCycle</span><span class="params">(head *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    <span class="keyword">if</span> head == <span class="literal">nil</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">nil</span></span><br><span class="line">    &#125;</span><br><span class="line">    slow, fast := head, head</span><br><span class="line">    <span class="keyword">for</span> fast != <span class="literal">nil</span> &amp;&amp; fast.Next != <span class="literal">nil</span> &#123;</span><br><span class="line">        slow = slow.Next</span><br><span class="line">        fast = fast.Next.Next</span><br><span class="line">        <span class="keyword">if</span> slow == fast &#123;</span><br><span class="line">            slow := head<span class="comment">// fast指向头节点，然后fast与slow以相同的速度相后移动</span></span><br><span class="line">            <span class="keyword">for</span> slow != fast &#123;<span class="comment">// 当slow与fast再次相遇时，代表找到了环的头节点</span></span><br><span class="line">                slow = slow.Next</span><br><span class="line">                fast = fast.Next</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> fast</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">nil</span><span class="comment">// 如果链表没有环，会在fast到达结尾时跳出循环，因此在这里返回nil即可</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul><hr><h5 id="6、判断两个单链表是否相交并找出交点"><a href="#6、判断两个单链表是否相交并找出交点" class="headerlink" title="6、判断两个单链表是否相交并找出交点"></a>6、判断两个单链表是否相交并找出交点</h5><p><strong>双指针</strong>：首先用两个指针分别从两个链表的头节点逐步移动，当指针指向链表结尾时，将该指针指向另一个链表的头节点，直到这两个指针相等时，就代表找到了两个链表相交的节点。</p><blockquote><p>如果两个链表没有相交，最后两个指针都会移到链表结尾，都是 nil，最后返回 nil。</p></blockquote><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">getIntersectionNode</span><span class="params">(headA, headB *ListNode)</span> *<span class="title">ListNode</span></span> &#123;</span><br><span class="line">    curA, curB := headA, headB</span><br><span class="line">    <span class="keyword">for</span> curA != curB &#123;</span><br><span class="line">        <span class="keyword">if</span> curA == <span class="literal">nil</span> &#123;</span><br><span class="line">            curA = headB</span><br><span class="line">            </span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curA = curA.Next</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> curB == <span class="literal">nil</span> &#123;</span><br><span class="line">            curB = headA</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            curB = curB.Next</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> curA</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>时间复杂度：O(N)</li><li>空间复杂度：O(1)</li></ul>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
            <tag> 单链表 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Golang互斥锁与读写锁</title>
      <link href="2021/03/14/Golang%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/"/>
      <url>2021/03/14/Golang%E4%BA%92%E6%96%A5%E9%94%81%E4%B8%8E%E8%AF%BB%E5%86%99%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>Go语言通过 go 关键字可以很方便的创建 goroutine 实现并发编程，但是不同的 goroutine 同时访问或者修改公共资源时会带来一些意想不到的结果。在并发编程时，可以借助 Golang 的锁机制来保证数据安全，本文将介绍 Golang 的两种锁：<strong>互斥锁</strong>与<strong>读写锁</strong>，首先对这两种锁进行概念上的对比，然后通过实验对比不加锁与加锁的区别，最后介绍读写锁的读锁与写锁的互斥原则。</p><a id="more"></a><h5 id="互斥锁与读写锁的区别"><a href="#互斥锁与读写锁的区别" class="headerlink" title="互斥锁与读写锁的区别"></a>互斥锁与读写锁的区别</h5><p>Go 语言标准库 <code>sync</code> 提供了 2 种锁，互斥锁 <code>sync.Mutex</code> 和读写锁 <code>sync.RWMutex</code> 。他们的区别如下：</p><ul><li>互斥锁：互斥即不可同时运行。即使用了互斥锁的两个代码片段互相排斥，只有其中一个代码片段执行完成后，另一个才能执行。Go 标准库中提供了 sync.Mutex 互斥锁类型及其两个方法：<ul><li>Lock 加锁</li><li>Unlock 释放锁</li></ul></li><li>读写锁：读写锁分为读锁和写锁，读锁是允许同时执行的，但写锁是互斥的。Go 标准库中提供了 sync.RWMutex 互斥锁类型及其四个方法：<ul><li>Lock 加写锁</li><li>Unlock 释放写锁</li><li>RLock 加读锁</li><li>RUnlock 释放读锁</li></ul></li></ul><h5 id="不加锁与加互斥锁的区别"><a href="#不加锁与加互斥锁的区别" class="headerlink" title="不加锁与加互斥锁的区别"></a>不加锁与加互斥锁的区别</h5><p>下面的代码，开启了三个协程，每个协程让一个公共变量 count 加 10000 次 1，初看下来，最终的 count 值应该是 30000</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++ &#123;</span><br><span class="line">count = count + <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;count=%d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是实际上运行的结果可能并不等于 30000，而且每次运行的结果各不相同</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 第一次</span></span><br><span class="line">count=<span class="number">19623</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二次</span></span><br><span class="line">count=<span class="number">15833</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三次</span></span><br><span class="line">count=<span class="number">20865</span></span><br></pre></td></tr></table></figure><p>原因就在于这三个协程在执行时，先读取 count 再更新 count 的值，而这个过程并不具备原子性，所以导致了数据的不准确。</p><p>解决这个问题的方法，就是给修改 count 的代码加上 Mutex 互斥锁，要求同一时刻，仅能有一个协程能对 count 操作。修改上面的代码如下：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">count := <span class="number">0</span></span><br><span class="line">lock := sync.Mutex&#123;&#125;<span class="comment">// 定义一个互斥锁</span></span><br><span class="line">wg := sync.WaitGroup&#123;&#125;</span><br><span class="line">wg.Add(<span class="number">3</span>)</span><br><span class="line"><span class="keyword">for</span> i := <span class="number">0</span>; i &lt; <span class="number">3</span>; i++ &#123;</span><br><span class="line"><span class="keyword">go</span> <span class="function"><span class="keyword">func</span><span class="params">()</span></span> &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line"><span class="keyword">for</span> j := <span class="number">0</span>; j &lt; <span class="number">10000</span>; j++ &#123;</span><br><span class="line">lock.Lock()<span class="comment">// 操作count之前加锁</span></span><br><span class="line">count = count + <span class="number">1</span></span><br><span class="line">lock.Unlock()<span class="comment">// 操作完之后释放锁</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;()</span><br><span class="line">&#125;</span><br><span class="line">wg.Wait()</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;count=%d\n&quot;</span>, count)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样，不管执行多少次上面的程序，输出都只有一个结果：</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">count=<span class="number">30000</span></span><br></pre></td></tr></table></figure><p>使用 Mutext 锁虽然很简单，但仍然有几点需要注意：</p><ul><li>同一协程里，不要在尚未解锁时再次使加锁</li><li>同一协程里，不要对已解锁的锁再次解锁</li><li>加了锁后，别忘了解锁，必要时使用 defer 语句</li></ul><h5 id="读锁与写锁的互斥原则"><a href="#读锁与写锁的互斥原则" class="headerlink" title="读锁与写锁的互斥原则"></a>读锁与写锁的互斥原则</h5><p>主要的互斥原则如下：</p><ol><li>读锁之间不互斥，没有写锁的情况下，读锁是无阻塞的，多个协程可以同时获得读锁。</li><li>写锁之间是互斥的，存在写锁，其他写锁阻塞。</li><li>写锁与读锁是互斥的，如果存在读锁，写锁阻塞，如果存在写锁，读锁阻塞。</li></ol><p>先来看一下下面的程序，有四个协程，有两个加写锁，还有两个加读锁，加锁之后分别休眠 1s，表示处理逻辑</p><figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line"><span class="string">&quot;fmt&quot;</span></span><br><span class="line"><span class="string">&quot;sync&quot;</span></span><br><span class="line"><span class="string">&quot;time&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> (</span><br><span class="line">lock = sync.RWMutex&#123;&#125;</span><br><span class="line">wg = sync.WaitGroup&#123;&#125;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">writeLock</span><span class="params">(s <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">lock.Lock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine %s get write lock\n&quot;</span>, s)</span><br><span class="line">time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine %s release write lock\n&quot;</span>, s)</span><br><span class="line">lock.Unlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">readLock</span><span class="params">(s <span class="keyword">string</span>)</span></span>  &#123;</span><br><span class="line"><span class="keyword">defer</span> wg.Done()</span><br><span class="line">lock.RLock()</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine %s get read lock\n&quot;</span>, s)</span><br><span class="line">time.Sleep(<span class="number">1</span>*time.Second)</span><br><span class="line">fmt.Printf(<span class="string">&quot;goroutine %s release read lock\n&quot;</span>, s)</span><br><span class="line">lock.RUnlock()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span>  &#123;</span><br><span class="line">wg.Add(<span class="number">4</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> writeLock(<span class="string">&quot;A&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> writeLock(<span class="string">&quot;B&quot;</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">go</span> readLock(<span class="string">&quot;C&quot;</span>)</span><br><span class="line"><span class="keyword">go</span> readLock(<span class="string">&quot;D&quot;</span>)</span><br><span class="line"></span><br><span class="line">wg.Wait()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>程序的运行结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">goroutine A get write lock&#x2F;&#x2F; 协程A获得写锁之后，其他协程必须等它释放写锁之后才能加锁 ——验证了写锁与其他的锁互斥</span><br><span class="line">goroutine A release write lock</span><br><span class="line">goroutine D get read lock&#x2F;&#x2F; 协程C与D在A释放写锁之后，同时获得了读锁，处理逻辑可以并行执行 ——验证了读锁之间不互斥</span><br><span class="line">goroutine C get read lock</span><br><span class="line">goroutine D release read lock</span><br><span class="line">goroutine C release read lock</span><br><span class="line">goroutine B get write lock&#x2F;&#x2F; 协程B必须要等C和D都释放读锁之后，才能加写锁 ——验证了读锁与写锁互斥，存在读锁，写锁阻塞</span><br><span class="line">goroutine B release write lock</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Golang </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 互斥锁 </tag>
            
            <tag> 读写锁 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kms</title>
      <link href="2021/03/08/kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
      <url>2021/03/08/kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<p><a href="https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys">https://docs.microsoft.com/zh-cn/windows-server/get-started/kms-client-activation-keys</a></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/windows%E6%9C%AA%E6%BF%80%E6%B4%BB.png" alt="image-20211117142459997"></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85%E4%BA%A7%E5%93%81%E5%AF%86%E9%92%A5.png" alt="image-20211117143106411"></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%88%90%E5%8A%9F%E8%AE%BE%E7%BD%AEkms%E6%9C%8D%E5%8A%A1%E5%9C%B0%E5%9D%80.png" alt="image-20211117143548790"></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/%E6%88%90%E5%8A%9F%E6%BF%80%E6%B4%BBwindows.png" alt="image-20211117143803951"></p><p><img src="./2021-03-08-kms%E6%BF%80%E6%B4%BB%E6%9C%8D%E5%8A%A1%E5%99%A8/windows%E5%B7%B2%E6%BF%80%E6%B4%BB.png" alt="image-20211117143928887"></p>]]></content>
      
      
      <categories>
          
          <category> Winodows </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kms激活 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Windows镜像制作</title>
      <link href="2021/01/17/Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/"/>
      <url>2021/01/17/Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<p>本文以 windows server 2016 系统为例，介绍在 KVM 环境制作 windows 虚机镜像的过程，该镜像主要用于 Kubernetes kubevirt 项目创建虚机，能供通过 cloudBase-init 完成虚机的初始化。</p><a id="more"></a><h4 id="一、创建windows"><a href="#一、创建windows" class="headerlink" title="一、创建windows"></a>一、创建windows</h4><h5 id="1、下载镜像"><a href="#1、下载镜像" class="headerlink" title="1、下载镜像"></a>1、下载镜像</h5><p>可以在 <a href="http://www.itellyou.cn/">www.itellyou.cn</a> 网站上面下载官方系统镜像文件 ，这里下载windows server 2016的镜像，下载好之后放到 KVM 主机中，在 /var/lib/libvirt/images/ 中新建一个 windows 文件夹，用户存放 iso 和后面创建的虚机安装磁盘 qcow2 文件：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">cd /var/lib/libvirt/images/</span><br><span class="line">mkdir windows</span><br><span class="line">cd windows</span><br></pre></td></tr></table></figure><h5 id="2、创建系统安装磁盘文件"><a href="#2、创建系统安装磁盘文件" class="headerlink" title="2、创建系统安装磁盘文件"></a>2、创建系统安装磁盘文件</h5><p>用 qemu-img 命令创建一个 qcow2 格式的磁盘文件，大小设置 20G：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create -f qcow2 cn_windows_server_2016_x64_dvd_9718765.qcow2 20G</span><br></pre></td></tr></table></figure><h5 id="3、创建虚机"><a href="#3、创建虚机" class="headerlink" title="3、创建虚机"></a>3、创建虚机</h5><p>通过virt-install命令创建虚机，指定虚机系统文件是 iso 文件，安装磁盘是 qcow2 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virt-install --name cn_windows_server_2016_x64_dvd_9718765 --memory 8192 --vcpus 4  --cdrom&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;windows&#x2F;cn_windows_server_2016_x64_dvd_9718765.iso  --disk path&#x3D;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;windows&#x2F;cn_windows_server_2016_x64_dvd_9718765.qcow2,format&#x3D;qcow2 --network default --graphics vnc,port&#x3D;5945,listen&#x3D;0.0.0.0 --channel unix,target_type&#x3D;virtio,name&#x3D;org.qemu.guest_agent.0  --virt-type kvm --os-variant windows --noautoconsole</span><br></pre></td></tr></table></figure><p>通过 vnc 登录虚机，进入 windows 系统安装程序</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/windows%E5%AE%89%E8%A3%85%E7%95%8C%E9%9D%A2.png" alt="windows安装界面"></p><p>没有产品密钥，点击 <u>我没有产品密钥</u>：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E6%BF%80%E6%B4%BBwindows.png" alt="激活windows"></p><p>选择要安装的操作系统，选择第二个有桌面的，点击下一步：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E9%80%89%E6%8B%A9%E8%A6%81%E5%AE%89%E8%A3%85%E7%9A%84%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F.png" alt="选择要安装的操作系统"></p><p>接受许可条款之后，点击下一步。进入下面的界面，选择 <u>自定义：仅安装 Windows（高级）</u>：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E9%80%89%E6%8B%A9%E5%AE%89%E8%A3%85%E7%B1%BB%E5%9E%8B.png" alt="选择安装类型"></p><p>选择唯一的一个驱动器，点击下一步：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E5%AE%89%E8%A3%85%E8%B7%AF%E5%BE%84.png" alt="安装路径"></p><p>进入 windows 系统安装过程，这个过程自动完成：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E6%AD%A3%E5%9C%A8%E5%AE%89%E8%A3%85windows.png" alt="正在安装windows"></p><p>完成上面的系统安装过程之后，虚机会自动关机。</p><p>先不要开机，先按照后面的步骤进行操作。</p><h5 id="4、卸载系统iso文件"><a href="#4、卸载系统iso文件" class="headerlink" title="4、卸载系统iso文件"></a>4、卸载系统iso文件</h5><p>通过下面的命令直接修改虚机 xml 模板，如果不卸载，下次重启还会进入安装系统的过程。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh edit cn_windows_server_2016_x64_dvd_9718765</span><br></pre></td></tr></table></figure><p>删除下面几行的配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;cdrom&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/var/lib/libvirt/images/windows/cn_windows_server_2016_x64_dvd_9718765.iso&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hdb&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ide&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;drive&#x27;</span> <span class="attr">controller</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">target</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><p>继续后续的操作。</p><hr><h4 id="二、安装windows镜像需要的驱动"><a href="#二、安装windows镜像需要的驱动" class="headerlink" title="二、安装windows镜像需要的驱动"></a>二、安装windows镜像需要的驱动</h4><p>主要需要的驱动有：pci scsi驱动、ballon驱动、virtio serial驱动</p><p>这些驱动在 virtio 的驱动文件中都能找到，<a href="https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso">https://fedorapeople.org/groups/virt/virtio-win/direct-downloads/stable-virtio/virtio-win.iso</a> 通过这个链接可以下载最新的稳定版本，也是一个 iso 文件。</p><p>下载之后，放到上面创建的 windows 目录下，并通过修改虚机 xml 文件模板将驱动文件挂载到虚机中</p><h5 id="1、将-virtio-win-iso-挂载到虚机上："><a href="#1、将-virtio-win-iso-挂载到虚机上：" class="headerlink" title="1、将 virtio-win.iso 挂载到虚机上："></a>1、将 virtio-win.iso 挂载到虚机上：</h5><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;cdrom&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/var/lib/libvirt/images/windows/virtio-win-0.1.204.iso&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hdb&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ide&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="2、添加SCSI控制器驱动——磁盘"><a href="#2、添加SCSI控制器驱动——磁盘" class="headerlink" title="2、添加SCSI控制器驱动——磁盘"></a>2、添加SCSI控制器驱动——磁盘</h5><p>给虚机挂载一个任意一个磁盘，设置其通道为 virtio 型，这样虚机启动之后就会提示需要安装相应的驱动</p><p>用以下命令随便创建一个磁盘文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">qemu-img create test.iso 10k</span><br></pre></td></tr></table></figure><p>修改虚机 xml 模板文件，添加下面的磁盘配置：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;disk&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/var/lib/libvirt/images/windows/test.iso&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hdd&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="3、添加以太网控制器驱动——网卡"><a href="#3、添加以太网控制器驱动——网卡" class="headerlink" title="3、添加以太网控制器驱动——网卡"></a>3、添加以太网控制器驱动——网卡</h5><p>在虚机 xml 模板中找到网络接口配置，将网卡设备类型设置为 virtio：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">interface</span> <span class="attr">type</span>=<span class="string">&#x27;network&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">mac</span> <span class="attr">address</span>=<span class="string">&#x27;52:54:00:10:a2:f4&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">network</span>=<span class="string">&#x27;default&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">model</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;pci&#x27;</span> <span class="attr">domain</span>=<span class="string">&#x27;0x0000&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0x00&#x27;</span> <span class="attr">slot</span>=<span class="string">&#x27;0x03&#x27;</span> <span class="attr">function</span>=<span class="string">&#x27;0x0&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">interface</span>&gt;</span></span><br></pre></td></tr></table></figure><h5 id="4、添加PCI简易设备驱动——qemu-guest-agent与宿主机连接"><a href="#4、添加PCI简易设备驱动——qemu-guest-agent与宿主机连接" class="headerlink" title="4、添加PCI简易设备驱动——qemu-guest-agent与宿主机连接"></a>4、添加PCI简易设备驱动——qemu-guest-agent与宿主机连接</h5><p>虚机xml中添加以下设备：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">channel</span> <span class="attr">type</span>=<span class="string">&#x27;unix&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">mode</span>=<span class="string">&#x27;bind&#x27;</span> <span class="attr">path</span>=<span class="string">&#x27;/var/lib/libvirt/qemu/org.qemu.guest_agent.0&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">type</span>=<span class="string">&#x27;virtio&#x27;</span> <span class="attr">name</span>=<span class="string">&#x27;org.qemu.guest_agent.0&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;virtio-serial&#x27;</span> <span class="attr">controller</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">port</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">channel</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>如果有就不需要重复添加。qemu-guest-agent 相关参考链接：<a href="https://pve.proxmox.com/wiki/Qemu-guest-agent">https://pve.proxmox.com/wiki/Qemu-guest-agent</a></p></blockquote><h5 id="5、启动虚机，安装驱动"><a href="#5、启动虚机，安装驱动" class="headerlink" title="5、启动虚机，安装驱动"></a>5、启动虚机，安装驱动</h5><p>使用命令启动虚机，并通过 vnc 界面登录虚机</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virsh start cn_windows_server_2016_x64_dvd_9718765</span><br></pre></td></tr></table></figure><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E8%AE%BE%E7%BD%AE%E5%88%9D%E5%A7%8B%E5%AF%86%E7%A0%81.png" alt="设置初始密码"></p><p>输入 CTRL-ALT-DELETE之后，输入 Administrator 的密码，进入系统</p><p>打开设备管理器，看到有几个设备都提示感叹号，这是因为这些设备的驱动还未安装：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E8%AE%BE%E5%A4%87%E7%AE%A1%E7%90%86%E5%99%A8.png" alt="设备管理器"></p><p>依次安装下列驱动：</p><ul><li>PCI简单通讯控制器驱动</li><li>PCI设备驱动</li><li>SCSI控制器驱动</li><li>以太网控制器驱动</li></ul><p>从计算机上面查找驱动程序</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E6%B5%8F%E8%A7%88%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%BB%A5%E6%9F%A5%E6%89%BE%E9%A9%B1%E5%8A%A8%E7%A8%8B%E5%BA%8F.png" alt="浏览计算机以查找驱动程序"></p><p>选择 CD 驱动器(D:) virtio-win-0.1.204</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E9%80%89%E6%8B%A9CD%E9%A9%B1%E5%8A%A8%E5%99%A8.png" alt="选择CD驱动器"></p><p>选择后点击下一步：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/D%E7%9B%98.png" alt="D盘"></p><p>完成驱动程序安装：</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E6%88%90%E5%8A%9F%E5%AE%89%E8%A3%85%E9%A9%B1%E5%8A%A8.png" alt="成功安装驱动"></p><h5 id="6、安装qumu-guest-agent"><a href="#6、安装qumu-guest-agent" class="headerlink" title="6、安装qumu-guest-agent"></a>6、安装qumu-guest-agent</h5><p>也从 CD 驱动器(D:) virtio-win-0.1.204 中找到下面路径的安装程序，点击安装</p><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/%E5%AE%89%E8%A3%85qemu-guest-agent.png" alt="安装qemu-guest-agent"></p><p>安装完成之后，进入最后一步安装 cloudBase-init</p><hr><h4 id="三、windows虚机CloudBaseInit配置"><a href="#三、windows虚机CloudBaseInit配置" class="headerlink" title="三、windows虚机CloudBaseInit配置"></a>三、windows虚机CloudBaseInit配置</h4><p>首先需要在虚机里面安装 cloudBase-init，可以在虚机里面访问 cloudBase-init 网站，或者在宿主机中下载后，通过磁盘挂载到虚机中进行安装，参考我之前的博客：<u>windows虚机挂载磁盘共享宿主机文件</u>。</p><p>安装好 cloudBase-init之后，需要配置 cloudBase-init</p><h5 id="1、cloudBaseInit-conf文件配置"><a href="#1、cloudBaseInit-conf文件配置" class="headerlink" title="1、cloudBaseInit conf文件配置"></a>1、cloudBaseInit conf文件配置</h5><p><img src="./2021-01-17-Windows%E9%95%9C%E5%83%8F%E5%88%B6%E4%BD%9C/cloudbase-init.png" alt="cloudbase-init"></p><p>配置的元数据服务是 noCloudService，并设置需要用到的插件。</p><h5 id="2、windows镜像执行sysprep"><a href="#2、windows镜像执行sysprep" class="headerlink" title="2、windows镜像执行sysprep"></a>2、windows镜像执行sysprep</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; cd C:\Program Files\CloudBase Solution\Cloudbase-Init\Conf</span><br><span class="line">&gt; C:\Windows\System32\Sysprep\sysprep.exe &#x2F;generalize &#x2F;oobe &#x2F;unattend:Unattend.xml</span><br></pre></td></tr></table></figure><blockquote><p>注意：需要在administrator用户下执行才行，要不然会报找不到Unattend.xml文件的错误</p></blockquote><h5 id="3、用户数据注入"><a href="#3、用户数据注入" class="headerlink" title="3、用户数据注入"></a>3、用户数据注入</h5><p>下面测试通过元数据注入的方式，给windows虚机设置初始密码</p><p>==必须要设置一个新的instan-id，虚机启动的时候才会重新根据用户数据初始话==</p><ul><li><p>meta_data</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">instance-id: cn_windows_server_2016_x64_dvd_9718765</span><br><span class="line">local-hostname: windows2016</span><br></pre></td></tr></table></figure></li><li><p>user_data</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">#cloud-config</span><br><span class="line">users:</span><br><span class="line"> -</span><br><span class="line">  name: Administrator</span><br><span class="line">  groups: Administrators</span><br><span class="line">  passwd: windows2016</span><br><span class="line">  inactive: False</span><br></pre></td></tr></table></figure><h5 id="4、kvm创建虚机注入用户数据"><a href="#4、kvm创建虚机注入用户数据" class="headerlink" title="4、kvm创建虚机注入用户数据"></a>4、kvm创建虚机注入用户数据</h5></li><li><p>将用户数据打包成磁盘</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">## create a disk to attach with some user-data and meta-data</span><br><span class="line">$ genisoimage  -output seed.iso -volid cidata -joliet -rock user-data meta-data</span><br></pre></td></tr></table></figure></li><li><p>挂载到虚机，虚机xml模板添加以下磁盘：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;disk type&#x3D;&#39;file&#39; device&#x3D;&#39;cdrom&#39;&gt;</span><br><span class="line">     &lt;driver name&#x3D;&#39;qemu&#39; type&#x3D;&#39;raw&#39;&#x2F;&gt;</span><br><span class="line">     &lt;source file&#x3D;&#39;&#x2F;var&#x2F;lib&#x2F;libvirt&#x2F;images&#x2F;data&#x2F;seed.iso&#39;&#x2F;&gt;</span><br><span class="line">     &lt;target dev&#x3D;&#39;hdb&#39; bus&#x3D;&#39;ide&#39;&#x2F;&gt;</span><br><span class="line">     &lt;readonly&#x2F;&gt;</span><br><span class="line">     &lt;address type&#x3D;&#39;drive&#39; controller&#x3D;&#39;0&#39; bus&#x3D;&#39;0&#39; target&#x3D;&#39;0&#39; unit&#x3D;&#39;1&#39;&#x2F;&gt;</span><br><span class="line">   &lt;&#x2F;disk&gt;</span><br></pre></td></tr></table></figure><p>虚机重启之后，就能完成 windows 虚机的初始化。</p></li></ul><hr><p>。。。。终于写完了，这个写的好麻烦，过程步骤太多，细节也很多，写的有点晕 T_T 。</p>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 镜像 </tag>
            
            <tag> Winodws </tag>
            
            <tag> CloudBase-init </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>windows虚机挂载磁盘共享宿主机文件</title>
      <link href="2021/01/15/%E5%88%9B%E5%BB%BA%E5%8F%AF%E6%8C%82%E8%BD%BD%E5%88%B0windows%E8%99%9A%E6%9C%BA%E7%9A%84%E7%A3%81%E7%9B%98/"/>
      <url>2021/01/15/%E5%88%9B%E5%BB%BA%E5%8F%AF%E6%8C%82%E8%BD%BD%E5%88%B0windows%E8%99%9A%E6%9C%BA%E7%9A%84%E7%A3%81%E7%9B%98/</url>
      
        <content type="html"><![CDATA[<p>在 KVM 环境创建具有图形化界面的 windows 虚机之后，虚机可能在某些情况下无法连接外网，比如网卡驱动未安装的情况下。这时需要在虚机里面安装软件就显得特别麻烦，比如需要安装 windows 虚机镜像初始化软件 cloudBase-init。本文介绍一种通过给 windows 虚机挂载磁盘的方式共享宿主机文件的方法。</p><a id="more"></a><h5 id="准备文件"><a href="#准备文件" class="headerlink" title="准备文件"></a>准备文件</h5><p>先将需要放到 iso 中的文件准备好，我这里准备了 cloudBase-init 的安装程序，放到 cloudbase 目录中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> ls cloudbase/</span></span><br><span class="line">CloudbaseInitSetup_Stable_x64.msi</span><br></pre></td></tr></table></figure><h5 id="创建iso镜像文件"><a href="#创建iso镜像文件" class="headerlink" title="创建iso镜像文件"></a>创建iso镜像文件</h5><p>然后用 mkisofs 命令将 cloudbase/ 目录打包到一个名叫 cloudbase.iso 的镜像文件中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> mkisofs -r -v -o cloudbase.iso cloudbase/</span></span><br><span class="line">I: -input-charset not specified, using utf-8 (detected in locale settings)</span><br><span class="line">genisoimage 1.1.11 (Linux)</span><br><span class="line">Scanning cloudbase/</span><br><span class="line">Writing:   Initial Padblock                        Start Block 0</span><br><span class="line">Done with: Initial Padblock                        Block(s)    16</span><br><span class="line">Writing:   Primary Volume Descriptor               Start Block 16</span><br><span class="line">Done with: Primary Volume Descriptor               Block(s)    1</span><br><span class="line">Writing:   End Volume Descriptor                   Start Block 17</span><br><span class="line">Done with: End Volume Descriptor                   Block(s)    1</span><br><span class="line">Writing:   Version block                           Start Block 18</span><br><span class="line">Done with: Version block                           Block(s)    1</span><br><span class="line">Writing:   Path table                              Start Block 19</span><br><span class="line">Done with: Path table                              Block(s)    4</span><br><span class="line">Writing:   Directory tree                          Start Block 23</span><br><span class="line">Done with: Directory tree                          Block(s)    1</span><br><span class="line">Writing:   Directory tree cleanup                  Start Block 24</span><br><span class="line">Done with: Directory tree cleanup                  Block(s)    0</span><br><span class="line">Writing:   Extension record                        Start Block 24</span><br><span class="line">Done with: Extension record                        Block(s)    1</span><br><span class="line">Writing:   The File(s)                             Start Block 25</span><br><span class="line"> 18.61% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line"> 37.25% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line"> 55.83% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line"> 74.46% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line"> 93.04% done, estimate finish Fri Jan 15 19:50:59 2021</span><br><span class="line">Total translation table size: 0</span><br><span class="line">Total rockridge attributes bytes: 365</span><br><span class="line">Total directory bytes: 0</span><br><span class="line">Path table size(bytes): 10</span><br><span class="line">Done with: The File(s)                             Block(s)    26697</span><br><span class="line">Writing:   Ending Padblock                         Start Block 26722</span><br><span class="line">Done with: Ending Padblock                         Block(s)    150</span><br><span class="line">Max brk space used 0</span><br><span class="line">26872 extents written (52 MB)</span><br></pre></td></tr></table></figure><h5 id="挂载到虚机中使用"><a href="#挂载到虚机中使用" class="headerlink" title="挂载到虚机中使用"></a>挂载到虚机中使用</h5><p>修改虚机 xml 模板文件，添加上述的 iso 镜像文件作为一块磁盘：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">disk</span> <span class="attr">type</span>=<span class="string">&#x27;file&#x27;</span> <span class="attr">device</span>=<span class="string">&#x27;cdrom&#x27;</span>&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">driver</span> <span class="attr">name</span>=<span class="string">&#x27;qemu&#x27;</span> <span class="attr">type</span>=<span class="string">&#x27;raw&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">source</span> <span class="attr">file</span>=<span class="string">&#x27;/var/lib/libvirt/images/windows/cloudbase.iso&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">target</span> <span class="attr">dev</span>=<span class="string">&#x27;hdd&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;ide&#x27;</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">readonly</span>/&gt;</span></span><br><span class="line">  <span class="tag">&lt;<span class="name">address</span> <span class="attr">type</span>=<span class="string">&#x27;drive&#x27;</span> <span class="attr">controller</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">bus</span>=<span class="string">&#x27;1&#x27;</span> <span class="attr">target</span>=<span class="string">&#x27;0&#x27;</span> <span class="attr">unit</span>=<span class="string">&#x27;1&#x27;</span>/&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">disk</span>&gt;</span></span><br></pre></td></tr></table></figure><p>启动虚机之后，即打开磁盘即可访问到磁盘中的文件，如图</p><img src="./2021-01-15-创建可挂载到windows虚机的磁盘/可见磁盘.png" style="zoom:50%;" />]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Windows </tag>
            
            <tag> 磁盘 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CentOS6.5安装cloudinit-18</title>
      <link href="2020/12/09/CentOS6-5%E5%AE%89%E8%A3%85cloudinit-18/"/>
      <url>2020/12/09/CentOS6-5%E5%AE%89%E8%A3%85cloudinit-18/</url>
      
        <content type="html"><![CDATA[<p>目前有个 CentOS6.x 的系统镜像，默认支持 cloud-init-0.7.5 版本 rpm，但是 cloud-init-0.7.5 无法通过本地化 QEMU 利用 NoCloud 数据源进行 IP 地址管理，因此无法实现虚机的网络初始化，需要手动进行配置。经过测试实验，cloud-init 17 以上版本能够支持 NoCloud 数据源信息注入，但是 cloud-init 17 及以上版本需要 python2.7 或者 python3 才能运行，而 CentOS6.x 系统默认使用 python2.6。因此为了在 CentOS6.x 上安装 cloud-init 17 以上的版本，需要先升级 python2.7，然后再安装 cloud-init。</p><a id="more"></a><hr><h1 id="具体步骤"><a href="#具体步骤" class="headerlink" title="具体步骤"></a>具体步骤</h1><h3 id="更新软件包"><a href="#更新软件包" class="headerlink" title="更新软件包"></a>更新软件包</h3><h5 id="1、安装-EPEL-源"><a href="#1、安装-EPEL-源" class="headerlink" title="1、安装 EPEL 源"></a>1、安装 EPEL 源</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install -y epel-release</span><br></pre></td></tr></table></figure><blockquote><ul><li><p>如果安装软件出现问题，见后续的问题记录1。</p></li><li><p>此外，安装 EPEL 源之后，安装软件还可能出问题，继续见后续问题记录2。</p></li></ul></blockquote><h5 id="2、安装-cloud-init-等软件包"><a href="#2、安装-cloud-init-等软件包" class="headerlink" title="2、安装 cloud-init 等软件包"></a>2、安装 cloud-init 等软件包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y install qemu-guest-agent cloud-utils-growpart gdisk libicu cloud-init dracut-modules-growroot</span><br></pre></td></tr></table></figure><h5 id="3、安装-versionlock-并锁定-cloud-init"><a href="#3、安装-versionlock-并锁定-cloud-init" class="headerlink" title="3、安装 versionlock 并锁定 cloud-init"></a>3、安装 versionlock 并锁定 cloud-init</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum -y install yum-plugin-versionlock</span><br><span class="line">yum versionlock add cloud-init</span><br></pre></td></tr></table></figure><h5 id="4、修改配置"><a href="#4、修改配置" class="headerlink" title="4、修改配置"></a>4、修改配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">rpm -qa kernel | sed &#39;s&#x2F;^kernel-&#x2F;&#x2F;&#39;  | xargs -I &#123;&#125; dracut -f &#x2F;boot&#x2F;initramfs-&#123;&#125;.img &#123;&#125;</span><br><span class="line"></span><br><span class="line">chkconfig cloud-config on</span><br><span class="line">chkconfig cloud-init on</span><br><span class="line">chkconfig cloud-final on</span><br><span class="line"></span><br><span class="line">sed -i &#39;&#x2F;$cloud_init $CLOUDINITARGS init&#x2F;a \</span><br><span class="line">    service network restart&#39; &#x2F;etc&#x2F;init.d&#x2F;cloud-init</span><br></pre></td></tr></table></figure><h3 id="安装-python2-7"><a href="#安装-python2-7" class="headerlink" title="安装 python2.7"></a>安装 python2.7</h3><h5 id="1、源码安装-python"><a href="#1、源码安装-python" class="headerlink" title="1、源码安装 python"></a>1、源码安装 python</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">yum -y install gcc openssl-devel bzip2-devel</span><br><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">wget https:&#x2F;&#x2F;www.python.org&#x2F;ftp&#x2F;python&#x2F;2.7.16&#x2F;Python-2.7.16.tgz</span><br><span class="line">tar xzf Python-2.7.16.tgz</span><br><span class="line">cd Python-2.7.16</span><br><span class="line">.&#x2F;configure --enable-optimizations</span><br><span class="line">make altinstall</span><br><span class="line">curl &quot;https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py&quot; -o &quot;get-pip.py&quot;</span><br><span class="line">python2.7 get-pip.py</span><br></pre></td></tr></table></figure><blockquote><p>下载 get-pip.py 脚本时可能碰到 curl: (35) SSL connect error 的问题，见问题记录3。</p></blockquote><h5 id="2、下载-cloud-init-依赖的-python-包"><a href="#2、下载-cloud-init-依赖的-python-包" class="headerlink" title="2、下载 cloud-init 依赖的 python 包"></a>2、下载 cloud-init 依赖的 python 包</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">pip2.7 install six</span><br><span class="line">pip2.7 install pyyaml</span><br><span class="line">pip2.7 install requests</span><br><span class="line">pip2.7 install jsonpatch</span><br><span class="line">pip2.7 install configobj</span><br></pre></td></tr></table></figure><blockquote><p>pip 下载失败可以更换国内源，见问题记录4。</p></blockquote><h3 id="更新-Cloud-init"><a href="#更新-Cloud-init" class="headerlink" title="更新 Cloud-init"></a>更新 Cloud-init</h3><h5 id="1、下载安装-cloud-init"><a href="#1、下载安装-cloud-init" class="headerlink" title="1、下载安装 cloud-init"></a>1、下载安装 cloud-init</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">cd &#x2F;usr&#x2F;local&#x2F;src</span><br><span class="line">mkdir cloud-init</span><br><span class="line">cd cloud-init</span><br><span class="line">wget http:&#x2F;&#x2F;ftp.riken.jp&#x2F;Linux&#x2F;cern&#x2F;centos&#x2F;7&#x2F;updates&#x2F;x86_64&#x2F;Packages&#x2F;cloud-init-18.5-3.el7.centos.x86_64.rpm</span><br><span class="line">rpm2cpio cloud-init-18.5-3.el7.centos.x86_64.rpm  | cpio -idmv</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;etc&#x2F;bash_completion.d&#x2F;* &#x2F;etc&#x2F;bash_completion.d</span><br><span class="line">rm -rf &#x2F;etc&#x2F;cloud&#x2F;</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;etc&#x2F;cloud  &#x2F;etc&#x2F;</span><br><span class="line">mv -f &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;etc&#x2F;rsyslog.d&#x2F;* &#x2F;etc&#x2F;rsyslog.d&#x2F;</span><br><span class="line">mkdir -p &#x2F;run&#x2F;cloud-init</span><br><span class="line">sed -i &#39;s&#x2F;\&#x2F;usr\&#x2F;bin\&#x2F;python&#x2F;\&#x2F;usr\&#x2F;local\&#x2F;bin\&#x2F;python2.7&#x2F;g&#39; &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;bin&#x2F;*</span><br><span class="line">mv -f &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;bin&#x2F;* &#x2F;usr&#x2F;bin&#x2F;</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;* &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;site-packages&#x2F;</span><br><span class="line">mkdir -p &#x2F;usr&#x2F;lib&#x2F;tmpfiles.d</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;lib&#x2F;tmpfiles.d&#x2F;* &#x2F;usr&#x2F;lib&#x2F;tmpfiles.d&#x2F;</span><br><span class="line">rm -rf &#x2F;usr&#x2F;libexec&#x2F;cloud-init</span><br><span class="line">mv &#x2F;usr&#x2F;local&#x2F;src&#x2F;cloud-init&#x2F;usr&#x2F;libexec&#x2F;* &#x2F;usr&#x2F;libexec&#x2F;</span><br><span class="line">rm -rf &#x2F;usr&#x2F;local&#x2F;src&#x2F;*</span><br></pre></td></tr></table></figure><h5 id="2、修改-cloud-init-配置"><a href="#2、修改-cloud-init-配置" class="headerlink" title="2、修改 cloud-init 配置"></a>2、修改 cloud-init 配置</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sed -i &quot;s&#x2F;disable_root.*&#x2F;disable_root\: 0&#x2F;;s&#x2F;ssh_pwauth.*&#x2F;ssh_pwauth\: 0&#x2F;&quot; &#x2F;etc&#x2F;cloud&#x2F;cloud.cfg</span><br></pre></td></tr></table></figure><p>最后执行验证 cloud-init 更新成功：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># cloud-init</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;cloud-init 18.5</span><br></pre></td></tr></table></figure><p>大功告成！！！后面就可以对虚机做一些别的配置，最后制作成一个镜像了。</p><hr><h1 id="可能遇到的问题记录"><a href="#可能遇到的问题记录" class="headerlink" title="可能遇到的问题记录"></a>可能遇到的问题记录</h1><h5 id="1、yum-下载软件包出错-Error-Cannot-find-a-valid-baseurl-for-repo-base"><a href="#1、yum-下载软件包出错-Error-Cannot-find-a-valid-baseurl-for-repo-base" class="headerlink" title="1、yum 下载软件包出错 Error: Cannot find a valid baseurl for repo: base"></a>1、yum 下载软件包出错 Error: Cannot find a valid baseurl for repo: base</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y epel-release</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Determining fastest mirrors</span><br><span class="line">YumRepo Error: All mirror URLs are not using ftp, http[s] or file.</span><br><span class="line"> Eg. Invalid release&#x2F;repo&#x2F;arch combination&#x2F;</span><br><span class="line">removing mirrorlist with no valid mirrors: &#x2F;var&#x2F;cache&#x2F;yum&#x2F;x86_64&#x2F;6&#x2F;base&#x2F;mirrorlist.txt</span><br><span class="line">Error: Cannot find a valid baseurl for repo: base</span><br></pre></td></tr></table></figure><p><strong>解决方法</strong>：修改 yum 源，更换成国内源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cp &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo.bak</span><br><span class="line">curl http:&#x2F;&#x2F;mirrors.163.com&#x2F;.help&#x2F;CentOS5-Base-163.repo -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo</span><br></pre></td></tr></table></figure><p>使用 yum 再次安装又出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># yum install -y epel-release</span><br><span class="line">Loaded plugins: fastestmirror</span><br><span class="line">Loading mirror speeds from cached hostfile</span><br><span class="line">http:&#x2F;&#x2F;mirrors.163.com&#x2F;centos&#x2F;6&#x2F;addons&#x2F;x86_64&#x2F;repodata&#x2F;repomd.xml: [Errno 14] PYCURL ERROR 22 - &quot;The requested URL returned error: 404 Not Found&quot;</span><br><span class="line">Trying other mirror.</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: addons. Please verify its path and try again</span><br></pre></td></tr></table></figure><p>再次搜索之后，发现可以使用 <strong>vault.centos.org</strong> 作为更新源</p><p><strong>具体操作步骤：</strong></p><ol><li><p>关闭 fastestmirror</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;yum&#x2F;pluginconf.d&#x2F;fastestmirror.conf</span><br><span class="line">#修改参数</span><br><span class="line">enable&#x3D;0</span><br></pre></td></tr></table></figure></li><li><p>备份原来的源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mv &#x2F;etc&#x2F;yum.repo.d&#x2F;CentOS-Base.repo &#x2F;etc&#x2F;yum.repo.d&#x2F;CentOS-Base.repo.bak</span><br></pre></td></tr></table></figure></li><li><p>更换 yum 源</p><ul><li><p>阿里云 Vault 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># curl -o &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;www.xmpan.com&#x2F;Centos-6-Vault-Aliyun.repo </span><br><span class="line"></span><br><span class="line"># wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;static.lty.fun&#x2F;%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90&#x2F;SourcesList&#x2F;Centos-6-Vault-Aliyun.repo</span><br></pre></td></tr></table></figure><blockquote><p>我的虚机上面没有 wget 命令，所以用 curl 命令来下载文件。</p></blockquote></li><li><p>官方 Vault 源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget -O &#x2F;etc&#x2F;yum.repos.d&#x2F;CentOS-Base.repo https:&#x2F;&#x2F;static.lty.fun&#x2F;%E5%85%B6%E4%BB%96%E8%B5%84%E6%BA%90&#x2F;SourcesList&#x2F;Centos-6-Vault-Official.repo</span><br></pre></td></tr></table></figure></li></ul></li><li><p>清理并构建缓存</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">yum clean all</span><br><span class="line">yum makecache</span><br><span class="line">yum repolist</span><br></pre></td></tr></table></figure><p>再次使用 yum 安装软件，成功。</p></li></ol><hr><h5 id="2、安装-EPEL-源后，使用报错"><a href="#2、安装-EPEL-源后，使用报错" class="headerlink" title="2、安装 EPEL 源后，使用报错"></a>2、安装 EPEL 源后，使用报错</h5><p>具体错误如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># yum install cloud-init</span><br><span class="line">Error: Cannot retrieve repository metadata (repomd.xml) for repository: epel. Please verify its path and try again</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong>修改 /etc/yum.repo.d/epel.repo，将 mirrorlist=<a href="https://xxxx/">https://xxxx</a> 修改为 http，即可正常使用。</p><hr><h5 id="3、curl-35-SSL-connect-error-问题处理"><a href="#3、curl-35-SSL-connect-error-问题处理" class="headerlink" title="3、curl: (35) SSL connect error 问题处理"></a>3、curl: (35) SSL connect error 问题处理</h5><p>下载 get-pip.py 脚本出现下面错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># curl https:&#x2F;&#x2F;bootstrap.pypa.io&#x2F;get-pip.py -o get-pip.py</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">  0     0    0     0    0     0      0      0 --:--:--  0:00:03 --:--:--     0</span><br><span class="line">curl: (35) SSL connect error</span><br></pre></td></tr></table></figure><p>解决方法：无法在服务器使用 curl 命令访问 https 域名，原因是 nss 版本有点旧了，<code>yum -y update nss</code> 更新一下，重新 curl 即可！</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum -y update nss</span><br></pre></td></tr></table></figure><hr><h5 id="4、更换-pip-源"><a href="#4、更换-pip-源" class="headerlink" title="4、更换 pip 源"></a>4、更换 pip 源</h5><p>在 <code>~/.pip/pip.conf</code> 文件中添加或修改：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># mkdir ~&#x2F;.pip</span><br><span class="line"># cat ~&#x2F;.pip&#x2F;pip.conf</span><br><span class="line">[global]</span><br><span class="line">index-url &#x3D; http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;pypi&#x2F;simple&#x2F;</span><br><span class="line"></span><br><span class="line">[install]</span><br><span class="line">trusted-host&#x3D;mirrors.aliyun.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CentOS </tag>
            
            <tag> Cloud-init </tag>
            
            <tag> 镜像 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Kubeadm快速部署kubernetes</title>
      <link href="2020/10/21/Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/"/>
      <url>2020/10/21/Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/</url>
      
        <content type="html"><![CDATA[<p>本文基于kubeadm快速部署一套Kubernetes集群用于个人学习和测试，针对国内网络环境选择合适的镜像源，减少镜像下载时间，并安装calico网络插件。</p><a id="more"></a><h2 id="环境准备"><a href="#环境准备" class="headerlink" title="环境准备"></a>环境准备</h2><p>本次环境由两台虚拟机来部署，安装CentOS7.6系统：</p><table><thead><tr><th align="center">主机名</th><th align="center">IP</th></tr></thead><tbody><tr><td align="center">master</td><td align="center">10.0.0.3</td></tr><tr><td align="center">node1</td><td align="center">10.0.0.4</td></tr></tbody></table><h3 id="配置hostname与host"><a href="#配置hostname与host" class="headerlink" title="配置hostname与host"></a>配置hostname与host</h3><p>分别在两台主机上执行命令，修改主机名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.3节点</span></span><br><span class="line">hostnamectl set-hostname master</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 10.0.0.4节点</span></span><br><span class="line">hostnamectl set-hostname node1</span><br></pre></td></tr></table></figure><blockquote><p>hostnamectl 命令会替换<code>/etc/hostname</code>文件中的主机名，保证重启后主机名还是生效；</p><p>hostname 命令可以临时修改主机名，重启后失效。</p></blockquote><p>两台机器都要配置host，允许主机通过主机名直接通信，<code>/etc/hosts</code>文件添加一下配置：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">10.0.0.3 master</span><br><span class="line">10.0.0.4 node1</span><br></pre></td></tr></table></figure><h3 id="关闭防火墙"><a href="#关闭防火墙" class="headerlink" title="关闭防火墙"></a>关闭防火墙</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">systemctl stop firewalld</span><br><span class="line">systemctl disable firewalld</span><br><span class="line">systemctl status firewalld</span><br></pre></td></tr></table></figure><h3 id="关闭selinux"><a href="#关闭selinux" class="headerlink" title="关闭selinux"></a>关闭selinux</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sed -i &#x27;s/SELINUX=enforcing/SELINUX=disabled/g&#x27; /etc/selinux/config  # 永久 需重启</span><br><span class="line">setenforce 0   # 临时</span><br></pre></td></tr></table></figure><h3 id="关闭swap"><a href="#关闭swap" class="headerlink" title="关闭swap"></a>关闭swap</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">swapoff -a</span><br><span class="line">sed -i &#x27;s/^[^#].*swap/#&amp;/&#x27; /etc/fstab</span><br><span class="line">systemctl daemon-reload</span><br></pre></td></tr></table></figure><p>若要启用swap设备，则需要在集群初始化时添加 <code>--ignore-preflight-errors=swap</code>，可忽略因swap设备导致的报错。</p><h3 id="关闭ipv6"><a href="#关闭ipv6" class="headerlink" title="关闭ipv6"></a>关闭ipv6</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">echo net.ipv6.conf.all.disable_ipv6=1 &gt;&gt; /etc/sysctl.conf</span><br><span class="line">echo NETWORKING_IPV6=no &gt;&gt; /etc/sysconfig/network</span><br><span class="line">sed -i &#x27;s/IPV6INIT=yes/IPV6INIT=no/g&#x27; /etc/sysconfig/network-scripts/ifcfg-ens33</span><br><span class="line">sysctl -p</span><br><span class="line">ip a             # 查看ipv6是否关闭</span><br></pre></td></tr></table></figure><h3 id="将桥接的ipv4流量传递到iptables"><a href="#将桥接的ipv4流量传递到iptables" class="headerlink" title="将桥接的ipv4流量传递到iptables"></a>将桥接的ipv4流量传递到iptables</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/sysctl.d/kubernetes.conf &lt;&lt; EOF</span><br><span class="line">net.bridge.bridge-nf-call-ip6tables =1</span><br><span class="line">net.bridge.bridge-nf-call-iptables =1</span><br><span class="line">EOF</span><br><span class="line"></span><br><span class="line">sysctl --system  # 生效</span><br></pre></td></tr></table></figure><blockquote><p>这个不知道什么意思但是通过Kubeadm安装Kubenetes集群时会校验。这里也搜到<a href="https://www.joeys.top/2021/01/iptable-net-bridge-bridge-nf-call-iptables%E7%9A%84%E4%BD%9C%E7%94%A8/">一篇文章</a>说明<code>net.bridge.bridge-nf-call-iptables的作用</code>参数作用，不明所以。</p></blockquote><h3 id="安装Docker"><a href="#安装Docker" class="headerlink" title="安装Docker"></a>安装Docker</h3><p>容器运行时是运行容器的基础，有多种可选的容器运行时，这里选择kubernetes默认的Docker。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装 yum-utils</span></span><br><span class="line">sudo yum install -y yum-utils</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置 yum 源为阿里云方便下载 Docker Engine</span></span><br><span class="line">sudo yum-config-manager --add-repo http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装最新版的docker，不同版本的k8s适配的docker版本不同，所以可能需要指定docker版本</span></span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io</span><br><span class="line"><span class="meta">#</span><span class="bash"> 获取docker版本列表</span></span><br><span class="line">sudo yum list docker-ce --showduplicates | sort -r</span><br><span class="line"><span class="meta">#</span><span class="bash"> 安装指定版本的docker</span></span><br><span class="line">sudo yum install docker-ce-&lt;VERSION_STRING&gt; docker-ce-cli-&lt;VERSION_STRING&gt; containerd.io</span><br><span class="line">sudo yum install docker-ce-19.03.9-3.el7 docker-ce-cli-19.03.9-3.el7 containerd.io</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动 docker</span></span><br><span class="line">sudo systemctl start docker</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 设置开机启动</span></span><br><span class="line">sudo systemctl enable docker</span><br></pre></td></tr></table></figure><p><strong>并且配置Docker的Cgroup Driver为systemd：</strong></p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">vi /etc/docker/daemon.json</span><br><span class="line"></span><br><span class="line">&#123;</span><br><span class="line">    &quot;exec-opts&quot;:[&quot;native.cgroupdriver=systemd&quot;]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">systemctl restart docker</span><br></pre></td></tr></table></figure><ul><li><p>什么是cgroups?</p><p>首先说下容器是什么？容器是一个视图隔离、资源可限制、独立文件系统的进程集合。cgroups(Control Groups) 是 linux 内核提供的一种机制，作用就是可以对资源进行限制。此外，视图隔离是通过namespace实现，而文件系统是通过chroot实现。</p></li><li><p>为什么要修改Cgroup Driver？</p><p>Docker默认的Cgroup Driver是cgroupfs，而Kubernetes 推荐使用 systemd 来代替 cgroupfs。如果不修改，那么同时运行有两个cgroup控制管理器，当资源有压力的情况时，有可能出现不稳定的情况。并且在kubeadm init时也会出现警告。</p></li></ul><h3 id="master节点配置免密登录node节点"><a href="#master节点配置免密登录node节点" class="headerlink" title="master节点配置免密登录node节点"></a>master节点配置免密登录node节点</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa # 一路默认回车即可</span><br><span class="line">ssh-copy-id master   # 过程中需要输入密码</span><br><span class="line">ssh-copy-id node1</span><br><span class="line"></span><br><span class="line">ssh root@node1   # 测试是否成功</span><br></pre></td></tr></table></figure><h2 id="集群部署"><a href="#集群部署" class="headerlink" title="集群部署"></a>集群部署</h2><h3 id="安装kubeadm、kubelet、kubectl"><a href="#安装kubeadm、kubelet、kubectl" class="headerlink" title="安装kubeadm、kubelet、kubectl"></a>安装kubeadm、kubelet、kubectl</h3><p>以下操作在所有节点进行</p><ul><li><p>添加阿里云YUM源</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">cat &gt;/etc/yum.repos.d/kubernetes.repo &lt;&lt; EOF</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https://mirrors.aliyun.com/kubernetes/yum/repos/kubernetes-el7-x86_64</span><br><span class="line">enabled=1</span><br><span class="line">gpgcheck=0</span><br><span class="line">repo_gpgcheck=0</span><br><span class="line">gpgkey=https://mirrors.aliyun.com/kubernetes/yum/doc/yum-key.gpg https://mirrors.aliyun.com/kubernetes/yum/doc/rpm-package-key.gpg</span><br><span class="line">EOF</span><br></pre></td></tr></table></figure></li><li><p>指定版本安装软件，这里安装1.19.8版本，1.20不再把Docker作为默认的容器运行时，所以这里选择1.19版本</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yum install -y kubelet-1.19.8 kubeadm-1.19.8 kubectl-1.19.8</span><br><span class="line">systemctl enable kubelet</span><br></pre></td></tr></table></figure><h3 id="Master节点安装"><a href="#Master节点安装" class="headerlink" title="Master节点安装"></a>Master节点安装</h3></li></ul><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubeadm init --kubernetes-version=1.19.8 --image-repository=registry.aliyuncs.com/google_containers</span><br></pre></td></tr></table></figure><p>安装成功之后，按照提示执行下列命令：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">mkdir -p $HOME/.kube</span><br><span class="line">sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config</span><br><span class="line">sudo chown $(id -u):$(id -g) $HOME/.kube/config</span><br></pre></td></tr></table></figure><p>同时要记住打印出的下列命令，用于添加Node节点：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">kubeadm join 10.0.0.3:6443 --token j91yvn.qvhw9t0n0nvjd9j7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:68f5132eed6c9a9f1dc59cd304220542e4635dbf629cc789d0d0e0b91bb909cd</span><br></pre></td></tr></table></figure><p>若没注意，可通过<code>kubeadm token list</code>查看当前的token，默认有效期为24小时，若忘记token或token过期，可使用命令<code>kubeadm token create --print-join-command</code>重新生成，若初始有问题可通过命令<code>kubeadm reset</code>重置。</p><p>启动kubelet：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet</span><br></pre></td></tr></table></figure><h3 id="Node节点安装"><a href="#Node节点安装" class="headerlink" title="Node节点安装"></a>Node节点安装</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">systemctl start kubelet</span><br><span class="line"></span><br><span class="line">kubeadm join 10.0.0.3:6443 --token j91yvn.qvhw9t0n0nvjd9j7 \</span><br><span class="line">    --discovery-token-ca-cert-hash sha256:68f5132eed6c9a9f1dc59cd304220542e4635dbf629cc789d0d0e0b91bb909cd</span><br></pre></td></tr></table></figure><h3 id="安装calico"><a href="#安装calico" class="headerlink" title="安装calico"></a>安装calico</h3><p>master与node节点安装好之后，获取一下节点信息：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl get nodes</span><br></pre></td></tr></table></figure><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/nodes_not_ready.png" alt="node notReady"></p><p>可以看到master节点与node1节点都处于NotReady状态。查看kubelet的状态：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl status kubelet</span><br></pre></td></tr></table></figure><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/systemctl_status_kubelet.png" alt="systemctl status kubelet"></p><p> <code>No networks found in /etc/cni/net.d</code> 这行错误信息表示节点没有CNI网络插件，这是因为kubeadm目标是在不安装其他功能插件的基础上，建立一个通过Kubernetes一致性测试Kubernetes Conformance tests的最小可行集群。它在设计上并不会安装网络解决方案，而是需要用户自行安装第三方符合CNI的网络解决方案（如：flannel，calico，weave network等）。</p><p>fannel和calico算是目前网络实现最热门的2个插件，经过简单的对比，calico在性能更好以外，还可以与服务网格 Istio 集成，所以毫不犹豫的选择calico。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl https://docs.projectcalico.org/manifests/calico.yaml -o calico.yaml</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">kubectl apply -f calico.yaml </span><br></pre></td></tr></table></figure><p>安装好calico相关组件之后，再次查看节点状态变为Ready：</p><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/nodes_ready.png" alt="node ready"></p><p>再查看基础应用：</p><p><img src="2020-10-21-Kubeadm%E5%BF%AB%E9%80%9F%E9%83%A8%E7%BD%B2kubernetes/pods.png" alt="system pod"></p><p>到此，一个kubenetes集群就搭建完毕，可以在该集群上创建deployment部署应用，创建service暴露服务了。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> kubeadm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Rancher部署k8s</title>
      <link href="2020/10/01/Rancher%E9%83%A8%E7%BD%B2k8s/"/>
      <url>2020/10/01/Rancher%E9%83%A8%E7%BD%B2k8s/</url>
      
        <content type="html"><![CDATA[<p>Rancher是一个开源的企业级容器管理平台。通过Rancher，企业再也不必自己使用一系列的开源软件去从头搭建容器服务平台。Rancher提供了在生产环境中使用的管理Docker和Kubernetes的全栈化容器部署与管理平台。本文记录Rancher部署k8s的过程。</p><a id="more"></a><h3 id="1-基本环境"><a href="#1-基本环境" class="headerlink" title="1. 基本环境"></a>1. 基本环境</h3><p>本文基于Ubuntu 16.04部署 Rancher，首先需要安装好 Docker。</p><blockquote><p>刚开始部署 Rancher 时，因为 Ubuntu 20.04 已经更新很久了都没有使用过，所以就尝试了用 Ubuntu 20.04来部署。但是在部署过程中一直不成功，仔细检查了一下才发现 Docker 针对 Ubuntu 20.04 只提供了 Docker 19.0.x 版本，官方下载链接中不支持其他的低版本。最后只能选择 Ubuntu 16.04 来部署（至于如何在 Ubuntu 20.04 上安装更低版本的后面再尝试了）。</p></blockquote><p>支持的Docker版本:</p><ul><li>17.03.x</li><li>18.06.x</li><li>18.09.x</li></ul><p><strong>安装 Docker 首先设置存储库：</strong></p><ol><li><p>更新<code>apt</code>软件包索引并安装软件包以允许<code>apt</code>通过HTTPS使用存储库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    gnupg-agent \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>添加Docker的官方GPG密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>使用以下命令来设置<strong>稳定的</strong>存储库。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">   &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">   $(lsb_release -cs) \</span><br><span class="line">   stable&quot;</span><br></pre></td></tr></table></figure></li></ol><p><strong>安装DOCKER引擎：</strong></p><ol><li><p>要安装<em>特定版本</em>的 Docker Engine，请在存储库中列出可用版本，然后选择并安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ apt-cache madison docker-ce</span><br><span class="line"></span><br><span class="line">  docker-ce | 5:18.09.1~3-0~ubuntu-xenial | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br><span class="line">  docker-ce | 5:18.09.0~3-0~ubuntu-xenial | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.1~ce~3-0~ubuntu       | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br><span class="line">  docker-ce | 18.06.0~ce~3-0~ubuntu       | https:&#x2F;&#x2F;download.docker.com&#x2F;linux&#x2F;ubuntu  xenial&#x2F;stable amd64 Packages</span><br></pre></td></tr></table></figure></li><li><p>更新<code>apt</code>程序包索引，并安装指定版本的Docker Engine和容器，或转到下一步以安装特定版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"> $ sudo apt-get install docker-ce&#x3D;5:18.09.1~3-0~ubuntu-xenial docker-ce-cli&#x3D;5:18.09.1~3-0~ubuntu-xenial containerd.io</span><br></pre></td></tr></table></figure></li><li><p>将当前用户加入 docker 用户组，下次登陆后执行 docker 命令可不加 sudo：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure></li></ol><hr><h3 id="2-安装Rancher"><a href="#2-安装Rancher" class="headerlink" title="2. 安装Rancher"></a>2. 安装Rancher</h3><p>执行以下命令安装 Rancher server：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d --restart&#x3D;unless-stopped -v &lt;主机路径&gt;:&#x2F;var&#x2F;lib&#x2F;rancher&#x2F; -p 80:80 -p 443:443 rancher&#x2F;rancher:stable</span><br></pre></td></tr></table></figure><hr><h3 id="3-登录Rancher，并创建集群"><a href="#3-登录Rancher，并创建集群" class="headerlink" title="3. 登录Rancher，并创建集群"></a>3. 登录Rancher，并创建集群</h3><p>稍等片刻之后，可以使用主机的 IP 在浏览器中登录 Rancher UI，并创建集群。参考链接：<a href="https://docs.rancher.cn/rancher2x/quick-start.html#_4-%E7%99%BB%E5%BD%95rancher">登录Rancher</a>。</p><hr><h3 id="4-复制向集群添加主机"><a href="#4-复制向集群添加主机" class="headerlink" title="4. 复制向集群添加主机"></a>4. 复制向集群添加主机</h3><p>接着在前端界面的主机角色选项中勾选 <code>etcd</code> 以及 <code>Control</code>，然后复制添加主机的命令到对应的主机中执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo docker run -d --privileged --restart&#x3D;unless-stopped --net&#x3D;host -v &#x2F;etc&#x2F;kubernetes:&#x2F;etc&#x2F;kubernetes -v &#x2F;var&#x2F;run:&#x2F;var&#x2F;run rancher&#x2F;rancher-agent:v2.4.5 --server https:&#x2F;&#x2F;192.168.184.129 --token hhkvrndn7lktsmz6fxnjw9jltppq5w6ttt466rbmzsr7pwxktjq6hr --ca-checksum fc92e9aa8d072c2e2731a34d9242bb71e8abcee3b059c6c6bcddd685acbd16b1 --etcd --controlplane --worker</span><br></pre></td></tr></table></figure><p>这个过程中需要下载较多 docker 容器镜像，需要等待较长时间。</p><hr><h3 id="5-部署工作负载"><a href="#5-部署工作负载" class="headerlink" title="5. 部署工作负载"></a>5. 部署工作负载</h3><p>这个也可以参考链接：<a href="https://docs.rancher.cn/rancher2x/quick-start.html#_6-%E9%83%A8%E7%BD%B2%E5%B7%A5%E4%BD%9C%E8%B4%9F%E8%BD%BD">部署工作负载</a>，这里就不截图展示了。</p><hr><h3 id="6-删除-Rancher"><a href="#6-删除-Rancher" class="headerlink" title="6. 删除 Rancher"></a>6. 删除 Rancher</h3><p>可使用一下脚本删除：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#!/bin/bash</span></span><br><span class="line"></span><br><span class="line">docker rm -f $(sudo docker ps -aq);</span><br><span class="line">docker volume rm $(sudo docker volume ls -q);</span><br><span class="line"></span><br><span class="line">rm -rf /etc/ceph \</span><br><span class="line">       /etc/cni \</span><br><span class="line">       /etc/kubernetes \</span><br><span class="line">       /opt/cni \</span><br><span class="line">       /opt/rke \</span><br><span class="line">       /run/secrets/kubernetes.io \</span><br><span class="line">       /run/calico \</span><br><span class="line">       /run/flannel \</span><br><span class="line">       /var/lib/calico \</span><br><span class="line">       /var/lib/etcd \</span><br><span class="line">       /var/lib/cni \</span><br><span class="line">       /var/lib/kubelet \</span><br><span class="line">       /var/lib/rancher/rke/<span class="built_in">log</span> \</span><br><span class="line">       /var/<span class="built_in">log</span>/containers \</span><br><span class="line">       /var/<span class="built_in">log</span>/pods \</span><br><span class="line">       /var/run/calico</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> mount <span class="keyword">in</span> $(mount | grep tmpfs | grep <span class="string">&#x27;/var/lib/kubelet&#x27;</span> | awk <span class="string">&#x27;&#123; print $3 &#125;&#x27;</span>) /var/lib/kubelet /var/lib/rancher; <span class="keyword">do</span> umount <span class="variable">$mount</span>; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">rm -f /var/lib/containerd/io.containerd.metadata.v1.bolt/meta.db</span><br><span class="line">sudo systemctl restart containerd</span><br><span class="line">sudo systemctl restart docker</span><br><span class="line"></span><br><span class="line">IPTABLES=<span class="string">&quot;/sbin/iptables&quot;</span></span><br><span class="line">cat /proc/net/ip_tables_names | <span class="keyword">while</span> <span class="built_in">read</span> table; <span class="keyword">do</span></span><br><span class="line">  <span class="variable">$IPTABLES</span> -t <span class="variable">$table</span> -L -n | <span class="keyword">while</span> <span class="built_in">read</span> c chain rest; <span class="keyword">do</span></span><br><span class="line">      <span class="keyword">if</span> <span class="built_in">test</span> <span class="string">&quot;X<span class="variable">$c</span>&quot;</span> = <span class="string">&quot;XChain&quot;</span> ; <span class="keyword">then</span></span><br><span class="line">        <span class="variable">$IPTABLES</span> -t <span class="variable">$table</span> -F <span class="variable">$chain</span></span><br><span class="line">      <span class="keyword">fi</span></span><br><span class="line">  <span class="keyword">done</span></span><br><span class="line">  <span class="variable">$IPTABLES</span> -t <span class="variable">$table</span> -X</span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><p>不仅要删除相关的容器，还需要删除对应的 docker volume，以及其他的一些配置，最后重启主机，之后才能重新运行新的 Rancher 平台。</p><hr><h3 id="6-总结"><a href="#6-总结" class="headerlink" title="6. 总结"></a>6. 总结</h3><p>在我多次尝试之后，发现 Docker 是关键，包括 Docker 的版本以及对应的镜像源，都对 Rancher 的成功部署有重要的影响。</p><p>在基本的 Docker 环境没有问题之后，用过 Rancher 来管理 Kubernetes 真的是太简单了。</p>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Rancher </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库锁</title>
      <link href="2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/"/>
      <url>2020/09/14/%E6%95%B0%E6%8D%AE%E5%BA%93%E9%94%81/</url>
      
        <content type="html"><![CDATA[<p>根据加锁的范围，MySQL 里面的锁大致可以分成全局锁、表级锁和行锁三类。本文记录在学习数据库锁过程中的关键概念以及一些个人的理解。</p><a id="more"></a><h5 id="全局锁"><a href="#全局锁" class="headerlink" title="全局锁"></a>全局锁</h5><p>全局锁就是对整个数据库实例加锁。MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。当你需要让整个库处于只读状态的时候，可以使用这个命令，之后其他线程的以下语句会被阻塞：数据更新语句（数据的增删改）——DML（Data Manipulate Language）、数据定义语句（包括建表、修改表结构等）——DDL（Data Definition Language）和更新类事务的提交语句。</p><p><strong>全局锁的典型使用场景是，做全库逻辑备份。</strong>也就是把整库每个表都 select 出来存成文本。但是在备份过程中整个库完全处于只读状态，如果在主库上面备份，那么在备份期间都不能执行更新，业务基本停摆；如果在从库备份，那么备份期间不能执行从主库同步过来的binlog，会导致主从延迟。</p><p>所以更好的备份方法是在可重复读隔离级别下开启一个事务，在整个备份过程中，都能拿到一致性视图，并且数据可以正常更新。但是可重复读隔离级别需要引擎支持才能使用，对于MyISAM等不支持事务的引擎，只能使用FTWRL全局锁的方式备份。<!--这也是使用 InnoDB 替代 MyISAM 的原因之一-->。</p><p>还有另一种方法实现全库只读——<code>set global readonly=true</code>，但是相比之下，还是推荐用FTWRL方式，原因如下：</p><ul><li>一是，在有些系统中，readonly 的值会被用来做其他逻辑，比如用来判断一个库是主库还是备库。因此，修改 global 变量的方式影响面更大，不建议使用。</li><li>二是，在异常处理机制上有差异。如果执行 FTWRL 命令之后由于客户端发生异常断开，那么 MySQL 会自动释放这个全局锁，整个库回到可以正常更新的状态。而将整个库设置为 readonly 之后，如果客户端发生异常，则数据库就会一直保持 readonly 状态，这样会导致整个库长时间处于不可写状态，风险较高。</li></ul><h5 id="表级锁"><a href="#表级锁" class="headerlink" title="表级锁"></a>表级锁</h5><p>MySQL 里面表级别的锁有两种：一种是表锁，一种是元数据锁（meta data lock，MDL)。</p><ul><li><strong>表锁</strong>的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。</li><li><strong>元数据锁 MDL</strong>（metadata lock)不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性，当对一个表做增删改查操作的时候，加 MDL 读锁；当要对表做结构变更操作的时候，加 MDL 写锁。MDL 会直到事务提交才会释放，在做表结构变更的时候，一定要小心不要导致锁住线上查询和更新。<ul><li>读锁之间不互斥，因此你可以有多个线程同时对一张表增删改查。</li><li>读写锁之间、写锁之间是互斥的，用来保证变更表结构操作的安全性。因此，如果有两个线程要同时给一个表加字段，其中一个要等另一个执行完才能开始执行。</li></ul></li></ul><h5 id="行锁"><a href="#行锁" class="headerlink" title="行锁"></a>行锁</h5><p>MySQL 的行锁是在引擎层由各个引擎自己实现的。但并不是所有的引擎都支持行锁，比如 MyISAM 引擎就不支持行锁。不支持行锁意味着并发控制只能使用表锁，对于这种引擎的表，同一张表上任何时刻只能有一个更新在执行，这就会影响到业务并发度。InnoDB 是支持行锁的，<!--这也是 MyISAM 被 InnoDB 替代的重要原因之一-->。</p><p>在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是<strong>两阶段锁协议</strong>。如果事务中需要锁多个行，要把最可能造成锁冲突、最可能影响并发度的锁尽量往后放。</p><p>当并发系统中不同线程出现循环资源依赖，涉及的线程都在等待别的线程释放资源时，就会导致这几个线程都进入无限等待的状态，称为死锁。当出现死锁以后，有两种解决策略：</p><ul><li>一种策略是，直接进入等待，直到超时。这个超时时间可以通过参数 innodb_lock_wait_timeout 来设置。默认是50s，当出现死锁时，第一个被锁住的线程需要过50s才会超时退出，然后其他线程才有可能继续执行，这个时间对于在线业务是无法接受的。但是如果把这个时间设置成一个很小的时间，比如1s，会导致普通的锁等待也超时退出，造成误伤。1</li><li>另一种策略是，发起死锁检测，发现死锁后，主动回滚死锁链条中的某一个事务，让其他事务得以继续执行。将参数 innodb_deadlock_detect 设置为 on，表示开启这个逻辑。每当一个事务被锁的时候，就要看看它所依赖的线程有没有被别人锁住，如此循环，最后判断是否出现了循环等待，也就是死锁，这是一个时间复杂度为O(n)的操作。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>B+树与索引</title>
      <link href="2020/09/01/B+%E6%A0%91%E4%B8%8E%E7%B4%A2%E5%BC%95/"/>
      <url>2020/09/01/B+%E6%A0%91%E4%B8%8E%E7%B4%A2%E5%BC%95/</url>
      
        <content type="html"><![CDATA[<h4 id="B-树与数据库索引"><a href="#B-树与数据库索引" class="headerlink" title="B+树与数据库索引"></a>B+树与数据库索引</h4><p>MySQL InnoDB引擎中，使用了B+树的索引模型，数据都是存储在B+树中的，每一个索引在InnoDB中都是一棵B+树。本文首先介绍B+树的概念，然后介绍MySQL的索引。</p><a id="more"></a><h5 id="B-树"><a href="#B-树" class="headerlink" title="B+树"></a>B+树</h5><p>数据库引擎有很多可用的数据结构，如哈希表、有序数组、二叉树搜索树。</p><ul><li>哈希表：键值对，把值放在数组中，用一个哈希函数把key换算成一个确定的位置，然后把value放在数组的这个位置，如果有哈希冲突，其中一种解决方法是链表。哈希表只适用于等值查询的场景。</li><li>有序数组：按顺序存储，查询用二分法可以快速查询，但是更新效率低，只适用于静态存储引擎。</li><li>二叉树搜索树：每个节点的左儿子小于父节点，父节点小于右儿子，查询和更新时间复杂度都是O(logN)。</li></ul><p>在上述三种数据结构中，只有二叉搜索树能够适用的场景更多，但是直接通过二叉搜索树也不太适合数据库存储，因为二叉搜索树的树高太高，而每一层的数据不太可能存在连续的数据块中，因此一次查询需要访问的数据块太多，尤其是在数据库可能存在磁盘中，速度就更慢了，所以一般都采用“N叉”树。InnoDB采用的是B+树结构，因为B+树能够很好地配合磁盘的读写特性，减少单词查询的磁盘访问次数。</p><p>B+树的查询效率更加稳定：由于非终节点并不是最终指向文件内容的节点，而只是叶子节点中关键字的索引。所以任何关键字的查找必须走一条从根节点到叶子节点的路。所有关键字查询的路径长度相同，导致每一个数据的查询效率相当。</p><h5 id="数据库索引"><a href="#数据库索引" class="headerlink" title="数据库索引"></a>数据库索引</h5><p>数据库索引用于提高数据查询效率，索引类型分为主键索引和非主键索引（普通索引）：</p><ul><li><p><strong>主键索引</strong>的叶子节点存的是整行数据；</p></li><li><p><strong>非主键索引</strong>的叶子节点内容是主键的值，所以非主键索引也被称为二级索引，通过普通索引查询时，需要先搜索非主键索引树，找到主键，然后再到主键索引树中再搜索一次，这个过程称为回表。基于非主键索引的查询需要多扫描一棵索引树，因此在应用中应该尽量使用主键索引。如果不通过索引来查询，就是遍历主键索引树，因此效率是最低的。</p></li></ul><p>优化数据库索引的一些方法：</p><ul><li>覆盖索引：假设有一张表，主键是ID，还有一个字段k，并且对k建立了一个非主键索引，在执行<code>select ID from T where k between 3 and 5</code>语句时，因为只需要查询主键ID的值，而主键ID是非主键索引k的叶子节点的值，因此索引k已经“覆盖了”我们的查询需求，不需要回表过程，这就被称为覆盖索引。</li><li>前缀索引：B+树这种索引结构，可以利用索引的“最左前缀”来定位记录。对于联合索引的最左N个字段或者字符串索引最左M个字符，都可以利用索引来加速检索。</li><li>索引下推：索引下推指的是可以在索引遍历过程中，对索引中包含的字段先做判断，直接过滤掉不满足条件的记录，减少回表次数。</li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库事务</title>
      <link href="2020/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/"/>
      <url>2020/08/18/%E6%95%B0%E6%8D%AE%E5%BA%93%E4%BA%8B%E5%8A%A1/</url>
      
        <content type="html"><![CDATA[<p>本文记录在学习数据库事务中的一些关键概念，包括事务的ACID特性、多事务同时执行可能存在的问题、事务的隔离级别，最后对数据库的长连接与长事务做了一个对比。</p><a id="more"></a><h5 id="事务的ACID特性："><a href="#事务的ACID特性：" class="headerlink" title="事务的ACID特性："></a>事务的ACID特性：</h5><ul><li>原子性（Atomicity）：一个事务（transaction）中的所有操作，或者全部完成，或者全部不完成，不会结束在中间某个环节。事务在执行过程中发生错误，会被回滚（Rollback）到事务开始前的状态，就像这个事务从来没有执行过一样。即，事务不可分割、不可约简。</li><li>一致性（Consistency）：在事务开始之前和事务结束以后，数据库的完整性没有被破坏。这表示写入的资料必须完全符合所有的预设约束、触发器、级联回滚等。</li><li>隔离性（Isolation）：数据库允许多个并发事务同时对其数据进行读写和修改的能力，隔离性可以防止多个事务并发执行时由于交叉执行而导致数据的不一致。事务隔离分为不同级别，包括未提交读、提交读、可重复读和串行化。</li><li>持久性（Durability）：事务处理结束后，对数据的修改就是永久的，即便系统故障也不会丢失。</li></ul><h5 id="多事务同时执行可能存在的问题："><a href="#多事务同时执行可能存在的问题：" class="headerlink" title="多事务同时执行可能存在的问题："></a>多事务同时执行可能存在的问题：</h5><ul><li>脏读（dirty read）：读到其他事务未提交的数据。</li><li>不可重复读（non-repeatable read）：前后读取的记录内容不一致。</li><li>幻读（phantom read）：前后读取的记录数量不一致。</li></ul><h5 id="隔离性与隔离级别"><a href="#隔离性与隔离级别" class="headerlink" title="隔离性与隔离级别"></a>隔离性与隔离级别</h5><ul><li>读未提交（read uncommitted）：一个事务还没提交时，它做的变更就能被别的事务看到。</li><li>读提交（read committed）：一个事务提交之后，它做的变更才会被其他事务看到。</li><li>可重复读（repeatable read）：一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。</li><li>串行化（serializable）：顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。</li></ul><h5 id="长连接与长事务"><a href="#长连接与长事务" class="headerlink" title="长连接与长事务"></a>长连接与长事务</h5><ul><li><p>长连接：是指连接数据库成功后，如果客户端持续有请求，则一直使用同一个连接。对应的短连接则是指每次执行完很少的几次查询就断开连接，下次查询再重新建立一个。</p><p>建立连接的过程通常是比较复杂的，所以我建议你在使用中要尽量减少建立连接的动作，<strong>也就是尽量使用长连接</strong>。但是全部使用长连接后，你可能会发现，有些时候 MySQL 占用内存涨得特别快，这是因为 MySQL 在执行过程中临时使用的内存是管理在连接对象里面的。这些资源会在连接断开的时候才释放。所以如果长连接累积下来，可能导致内存占用太大，被系统强行杀掉（OOM），从现象看就是 MySQL 异常重启了。</p></li><li><p>长事务：一直不提交的事务，就是长事务。<strong>尽量不要使用长事务</strong>，因为长事务意味着系统里面会存在很老的事务视图。由于这些事务随时可能访问数据库里面的任何数据，所以这个事务提交之前，数据库里面它可能用到的回滚记录都必须保留，这就会导致大量占用存储空间。除了对回滚段的影响，长事务还占用锁资源，也可能拖垮整个库。</p></li></ul>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>redo log与bin log的个人理解</title>
      <link href="2020/08/06/redo%20log%E4%B8%8Ebin%20log%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/"/>
      <url>2020/08/06/redo%20log%E4%B8%8Ebin%20log%E7%9A%84%E4%B8%AA%E4%BA%BA%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<p>MySQL数据库的更新流程涉及两个重要的日志模块：redo log与bin log，本文记录一下在学习丁奇大佬的《MySQL实战45讲》过程中我个人的一些理解，如有不对的地方，欢迎指正。</p><a id="more"></a><h5 id="redo-log"><a href="#redo-log" class="headerlink" title="redo log"></a>redo log</h5><ul><li><p><strong>特点：</strong>InnoDB引擎所特有的；是物理日志，记录的是数据“做了什么改动”；redo log循环写，空间固定，会用完。</p></li><li><p><strong>作用：</strong>用于保证数据库发生异常重启恢复数据，之前提交的记录都不会丢失，也就是 <strong>crash-safe</strong>。</p></li><li><p><strong>理解：</strong>数据库更新的部分数据可以暂时保存在内存中，并不是立马写到磁盘中，这样可以减少读写磁盘的次数。但是保存在内存中的数据可能会因为数据库出现异常重启的情况而导致数据丢失，无法从磁盘中的数据恢复最新的数据。有了redo log之后可以解决这个问题，每次更新完数据之前，会在redo log文件中记录数据的变更操作，这样在数据库异常重启之后，会根据磁盘中的数据以及redo log，恢复最新的数据。</p></li></ul><h5 id="bin-log"><a href="#bin-log" class="headerlink" title="bin log"></a>bin log</h5><ul><li><strong>特点：</strong>MySQL server层实现的日志，所有存储引擎插件都可以使用；是逻辑日志，记录的是这个语句的原始逻辑（有两种模式，statement格式记录sql语句，row格式会记录行的内容，记两条，更新前与更新后都有）；bin log可以追加写，文件写到一定大小会写到下一个文件，不会覆盖以前的日志。</li><li><strong>作用：</strong>将数据库rollback至某个操作或者某个时间点之前的状态，或者用于备份数据。</li><li><strong>理解：</strong>无法通过redo log来实现这个rollback操作，因为redo log记录的是内存数据与磁盘数据的变化，就算要通过redo log来rollback，那也只能将最新的数据库回滚到内存中某个时间点的状态，而无法回滚到磁盘中数据的某个时间点。但是通过bin log可以实现这种回滚需求，假设需要回滚至某个删表操作之前的状态，只需要从删除操作之前最近的一个数据备份开始，重新执行bin log中从数据备份开始至删除操作之前的bin log即可。</li></ul><blockquote><p>通过对redo log与bin log的介绍与理解，可知二者作用不同，需同时存在才能实现数据库的某些可用性与可靠性。但是二者之间必须按照某个特定的逻辑顺序来处理才能处理一些出现错误的场景，也就是redo log的两阶段提交，先执行写redo log的prepare阶段，然后执行写bin log，最后执行写redo log的commit阶段，如果中间有某个阶段出错，都会让redo log、bin log回滚。</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> MySQL </category>
          
      </categories>
      
      
        <tags>
            
            <tag> MySQL </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>二分查找算法总结</title>
      <link href="2019/04/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>2019/04/01/%E4%BA%8C%E5%88%86%E6%9F%A5%E6%89%BE%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<p>二分查找或二分搜索（binary search），是一种在有序数组中查找某一特定元素的搜索算法。必须满足以下特征：</p><ul><li>存储在数组中</li><li>有序排列</li></ul><blockquote><p>如果是用链表存储的，就无法应用二分查找了，因为链表不能通过下标随机访问其元素。</p></blockquote><p>本文介绍基本的二分查找及其各种变体。</p><a id="more"></a><h4 id="1-基本二分查找"><a href="#1-基本二分查找" class="headerlink" title="1.基本二分查找"></a>1.基本二分查找</h4><p>基本二分查找的搜索过程是从数组的中间元素开始，如果中间元素正好是要查找的元素，则搜索过程结束；如果中间元素大于目标值，则在数组小于中间元素的那一半中查找；如果中间元素小于目标值，则在数组大于中间元素的那一半查找。如果在某一步数组为空，则代表找不到。二分查找算法每一次比较都会使搜索范围缩小一半。</p><p>基本二分查找的代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">basic_binary_search</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="comment">//target在左边，改右边界</span></span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="comment">//target在右边，改左边界</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (target &gt; nums[mid])</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="2-各种变体"><a href="#2-各种变体" class="headerlink" title="2. 各种变体"></a>2. 各种变体</h4><p>二分查找除了基本的查找某个元素的位置之外，还有很多的变体。比如查找第一个大于target的元素位置，这经常用于寻找要插入的位置；反过来，也会查找第一个比target小的元素的位置。有时也会查找某个元素在数组中的上下界，也就是查找不大于target的最后一个元素的位置或是查找不小于target的第一个元素的位置。最后还会出现数组中有多个target元素时，需要查找第一次或最后一次出现target元素的位置。</p><p>因此，如下分成了六种变体，在编写相应的二分查找算法的代码时，需要注意的就是判断条件以及返回值的问题。不多说，先看代码：</p><h5 id="变体1：查找第一个大于target的元素位置"><a href="#变体1：查找第一个大于target的元素位置" class="headerlink" title="变体1：查找第一个大于target的元素位置"></a>变体1：查找第一个大于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_greater</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;        </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size())</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体2：查找最后一个小于target的元素位置"><a href="#变体2：查找最后一个小于target的元素位置" class="headerlink" title="变体2：查找最后一个小于target的元素位置"></a>变体2：查找最后一个小于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_less</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与标准库中 upper_bound 函数功能一致。</p></blockquote><hr><h5 id="变体3：查找第一个大于等于target的元素位置"><a href="#变体3：查找第一个大于等于target的元素位置" class="headerlink" title="变体3：查找第一个大于等于target的元素位置"></a>变体3：查找第一个大于等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_first_greater_equal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size())</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>与标准库中 lower_bound 函数的功能是一样的。</p></blockquote><hr><h5 id="变体4：查找最后一个小于等于target的元素位置"><a href="#变体4：查找最后一个小于等于target的元素位置" class="headerlink" title="变体4：查找最后一个小于等于target的元素位置"></a>变体4：查找最后一个小于等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_last_less_equal</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体5：查找第一个等于target的元素位置"><a href="#变体5：查找第一个等于target的元素位置" class="headerlink" title="变体5：查找第一个等于target的元素位置"></a>变体5：查找第一个等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_first</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt;= nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (left &lt; nums.size() &amp;&amp; nums[left] == target)</span><br><span class="line">        <span class="keyword">return</span> left;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h5 id="变体6：查找最后一个等于target的元素位置"><a href="#变体6：查找最后一个等于target的元素位置" class="headerlink" title="变体6：查找最后一个等于target的元素位置"></a>变体6：查找最后一个等于target的元素位置</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find_the_last</span><span class="params">(<span class="keyword">const</span> <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums, <span class="keyword">int</span> target)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">0</span>, right = nums.size()<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">        mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (target &lt; nums[mid])</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (right &gt;= <span class="number">0</span> &amp;&amp; nums[right] == target)</span><br><span class="line">        <span class="keyword">return</span> right;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="3-总结"><a href="#3-总结" class="headerlink" title="3. 总结"></a>3. 总结</h4><p>看以上循环部分的代码都有一种结构：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (left &lt;= right)&#123;</span><br><span class="line">    mid = left + (right - left)/<span class="number">2</span>;</span><br><span class="line">    <span class="keyword">if</span> (target ➀ nums[mid])</span><br><span class="line">        right = mid - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        left = mid + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> ➁;</span><br></pre></td></tr></table></figure><p>不同的地方有两个：</p><ul><li><p>循环体内部的判断条件：<code>if (target ➀ nums[mid])</code></p><p>➀所在的位置的比较符号是 &lt; 或 &lt;= 。不存在大于或大于等于的情况。</p></li><li><p>返回值：<code>return ➁;</code></p><p>➁所在位置返回值是 left 或 right。</p></li></ul><blockquote><p>循环的终止条件都是 left &gt; right。</p></blockquote><p>不同变体的情况下，➀➁处的取值如下表：</p><table><thead><tr><th align="center">变体</th><th align="center">➀</th><th align="center">➁</th></tr></thead><tbody><tr><td align="center">查找<strong>第一个大于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个小于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">right</td></tr><tr><td align="center">查找<strong>第一个大于等于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个小于等于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">right</td></tr><tr><td align="center">查找<strong>第一个等于</strong>target的元素位置</td><td align="center">&lt;=</td><td align="center">left</td></tr><tr><td align="center">查找<strong>最后一个等于</strong>target的元素位置</td><td align="center">&lt;</td><td align="center">right</td></tr></tbody></table><p>根据上表，再根据问题的一些特点可以得出以下一些规律：</p><ul><li>查找第一个（大于、大于等于、等于）target的元素位置，也就是找左边界，返回 left。</li><li>查找最后一个（小于、小于等于、等于）target的元素位置，也就是找右边界，返回 right。</li></ul><blockquote><p>另外，其实变体 5、6 在元素存在于数组中时，与变体3、4是一样的解法。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二分查找 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>查找数组中重复的元素</title>
      <link href="2019/03/20/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/"/>
      <url>2019/03/20/%E6%9F%A5%E6%89%BE%E6%95%B0%E7%BB%84%E4%B8%AD%E9%87%8D%E5%A4%8D%E7%9A%84%E5%85%83%E7%B4%A0/</url>
      
        <content type="html"><![CDATA[<p>查找数组中重复的元素：在一个长度为 n 的数组里的所有数字都在 0 到 n-1 的范围内。数组中某些数字是重复的，但不知道有几个数字是重复的。也不知道每个数字重复几次。请找出数组中任意一个重复的数字。 例如，如果输入长度为 7 的数组{2, 3, 1, 0, 2, 5, 3}，那么对应的输出是第一个重复的数字 2。</p><a id="more"></a><h2 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h2><h4 id="常规思路"><a href="#常规思路" class="headerlink" title="常规思路"></a>常规思路</h4><p>最简单的方法就是用一个集合 set，遍历数组的每一个元素，在 set 中查找是否存在该元素，如果存在则返回；不存在则放入集合，并继续循环。</p><p>复杂度：</p><ul><li>空间复杂度为：<code>O(N)</code></li><li>时间复杂度为：<code>O(NlogN)</code> （遍历数组为 <code>O(N)</code>，set 中查找为 <code>O(logN)</code>）</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> n, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="built_in">set</span>&lt;<span class="keyword">int</span>&gt; Set;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; numbers.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (Set.find(numbers[i]) != Set.end())&#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        Set.insert(numbers[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="改进：使用hash表"><a href="#改进：使用hash表" class="headerlink" title="改进：使用hash表"></a>改进：使用hash表</h4><p>使用一个长度为 n 的数组来作为 hash 表，初始化为 0。然后遍历数组，利用数组元素作为 hash 表的索引，如果其对应的值为 1，说明是第二次访问该索引，那么该索引就是原数组中重复的元素；如果其对应的值为 0，说明是第一次访问，设置为 1。</p><p>复杂度：</p><ul><li>空间复杂度为：<code>O(N)</code></li><li>时间复杂度为：<code>O(N)</code> </li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> hash_table[length];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; i++)&#123;</span><br><span class="line">        <span class="keyword">if</span> (hash_table[numbers[i]] == <span class="number">1</span>)&#123;</span><br><span class="line">            *duplication = numbers[i];</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            hash_table[numbers[i]] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h4 id="常数空间"><a href="#常数空间" class="headerlink" title="常数空间"></a>常数空间</h4><p>上面的方法都会使用 O(N) 的内存空间，如果只能使用 O(1) 的空间，那么可以考虑下面的方法。</p><p>一种类似于基数排序的方法：</p><p>索引 i 从 0 开始遍历数组，</p><ul><li>如果 i == numbers[i]，说明 numbers[i] 在正确的位置上；</li><li>如果 i != numbers[i]，<ul><li>如果 numbers[i] != numbers[numbers[i]]，交换 numbers[i] 和 numbers[numbers[i]]，那么 numbers[numbers[i]] 将会在正确的位置上。</li><li>否则 numbers[i] == numbers[numbers[i]]，那么就找到了 numbers[i]。</li></ul></li></ul><p>复杂度：</p><ul><li>空间复杂度：O(1)</li><li>时间复杂度：O(N)</li></ul><p>代码如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">duplicate</span><span class="params">(<span class="keyword">int</span> numbers[], <span class="keyword">int</span> length, <span class="keyword">int</span>* duplication)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; length; ++i)&#123;</span><br><span class="line">        <span class="keyword">while</span> (i != numbers[i])&#123;</span><br><span class="line">            <span class="keyword">if</span> (numbers[i] == numbers[numbers[i]])&#123;</span><br><span class="line">                *duplication = numbers[i];</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                swap(numbers[i], numbers[numbers[i]]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数组 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>C/C++中 sizeof 的用法总结</title>
      <link href="2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/"/>
      <url>2019/03/12/C-%E4%B8%ADsizeof%E7%9A%84%E7%94%A8%E6%B3%95%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h4 id="sizeof-运算符"><a href="#sizeof-运算符" class="headerlink" title="sizeof 运算符"></a>sizeof 运算符</h4><p>需要注意的是 sizeof() 是运算符，而不是一个函数，在编译时就计算好了，用于计算数据空间的字节数。因此，sizeof 不能用来返回动态分配的内存空间的大小。sizeof 常用于返回类型和静态分配的对象、结构或数组所占的空间，返回值跟对象、结构、数组所存储的内容没有关系。</p><p>本文将介绍使用 sizeof 来判定 <strong>共用体</strong>、<strong>结构体</strong>、<strong>嵌套结构体</strong>、<strong>混合结构体</strong> 以及 <strong>类对象</strong> 所占空间的大小。</p><a id="more"></a><hr><h4 id="不同数据类型所占的内存大小"><a href="#不同数据类型所占的内存大小" class="headerlink" title="不同数据类型所占的内存大小"></a>不同数据类型所占的内存大小</h4><table><thead><tr><th align="center"></th><th align="center">32 位</th><th align="center">64 位</th></tr></thead><tbody><tr><td align="center">char</td><td align="center">1</td><td align="center">1</td></tr><tr><td align="center">int</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">short</td><td align="center">2</td><td align="center">2</td></tr><tr><td align="center">long</td><td align="center">4</td><td align="center">8</td></tr><tr><td align="center">float</td><td align="center">4</td><td align="center">4</td></tr><tr><td align="center">double</td><td align="center">8</td><td align="center">8</td></tr><tr><td align="center">指针</td><td align="center">4</td><td align="center">8</td></tr></tbody></table><p>long 类型与指针类型在 32 位机器上只占 4 字节，在 64 位机器上占 8 字节。其他类型在 32 位机器和 64 位机器都是占同样的大小空间。</p><hr><h4 id="共用体的大小"><a href="#共用体的大小" class="headerlink" title="共用体的大小"></a>共用体的大小</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">union A&#123;</span><br><span class="line">    int a[5];</span><br><span class="line">    char b;</span><br><span class="line">    double c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">cout &lt;&lt; sizeof(A) &lt;&lt; endl;</span><br></pre></td></tr></table></figure><p>上面求出共用体的大小为：<strong>24</strong></p><p>union 中变量共用内存，应以最长的为准，A 中最长的成员是数组 a，其长度为 20。与结果不一样，这是因为在共用体内变量的默认对齐方式，必须以最长的 double（8Byte）对齐，所以得到 sizeof(A) = 24。所以将共用体内的 int a[5] 修改成 int a[6] 后，结果仍然不变；但如果将 int a[5] 修改成 int a[7]，结果就变成 32。</p><blockquote><p><strong>对齐系数</strong>：每个平台上的编译器都有默认对齐系数 n，但是可以通过 <code>#pragma pack(n)</code> 来设定。</p><p><strong>有效对齐系数</strong>：对于一个复杂类型变量，有效对齐系数 = min(对齐系数 n，复杂类型中最长数据类型的长度)。比如设定的对齐系数为 8，而结构体中最长的是 int，4个字节，那么有效对齐值为 4。</p></blockquote><p>通过下面的例子说明有效对齐系数：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">pragma</span> pack(4)</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">A</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> b;</span><br><span class="line">    <span class="keyword">double</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(A) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出为：<strong>20</strong></p><p>这是因为通过 <code>#pragma pack(n)</code> 设置对齐系数为 4，所以实际的有效对齐系数为：min(4, sizeof(double)) = 4，所以最后共用体 A 的大小为 5*int(4) = 20。</p><hr><h4 id="结构体的大小"><a href="#结构体的大小" class="headerlink" title="结构体的大小"></a>结构体的大小</h4><p>首先介绍一个概念和两条原则：</p><p><strong>偏移量</strong> ：偏移量指的是 <u>结构体变量中成员的地址</u> 和 <u>结构体变量地址</u> 的差。</p><p>存储变量时地址要求对齐，编译器在编译程序时会遵循<strong>两条原则</strong>：</p><ol><li>结构体变量中成员的偏移量必须是成员大小的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，也即所有成员大小的公倍数。</li></ol><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">B</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="keyword">double</span> b;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(B) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出为：<strong>24</strong></p><p>这是因为 char a 的偏移量为 0，占用 1Byte；double b 指的下一个可用的地址的偏移量为 1，不是 sizeof(double)=8 的整数倍，需要补足 7Byte 才能是偏移量为 8；int c 指的下一个可用的地址的偏移量为 16，是 sizeof(int)=4 的整数倍，满足 int 的对齐方式。</p><p>故所有成员的变量都分配了空间，空间总的大小为 1+7+8+4 = 20，不是结构的节边界数（即结构中占用最大空间的类型所占用的字节数 sizeof(double)=8）的倍数，所以需要填充 4Byte，以满足结构的大小为 sizeof(double)=8 的倍数，即 24 。</p><hr><h4 id="嵌套结构体的大小"><a href="#嵌套结构体的大小" class="headerlink" title="嵌套结构体的大小"></a>嵌套结构体的大小</h4><p>对于嵌套的结构体，需要将其展开。对嵌套结构体求 sizeof 时，上述原则变为：</p><ol><li>展开后的结构体的第一个成员的偏移量应当是被展开的结构体中最大的成员的整数倍。</li><li>结构体大小必须是所有成员大小的整数倍，这里所有成员计算的是展开后的成员，而不是将嵌套的结构体当做一个整体。</li></ol><p>例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">C</span>&#123;</span></span><br><span class="line">    <span class="keyword">char</span> a;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">        <span class="keyword">char</span> b;</span><br><span class="line">        <span class="keyword">int</span> c;</span><br><span class="line">    &#125; ss;</span><br><span class="line">    <span class="keyword">short</span> d;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(C) &lt;&lt; <span class="built_in">endl</span>;</span><br></pre></td></tr></table></figure><p>输出：<strong>16</strong></p><p>char a 的偏移量为 0，占用 1Byte；但是对于展开后的结构体的第一个成员 char b，下一个可用的地址的偏移量为 1，不是被展开结构体中最大成员 int c 的整数倍，需补充 3Byte 才能是偏移量变为 4；char b 占用 1Byte，下一个可用地址的偏移量是 5，又不是 int c 大小的整数倍，又需补充 3Byte 变为 8；short d 的偏移量为 12，满足 short 的对齐方式。</p><p>故所有成员变量都分配了空间，空间总的大小为 1+3+1+3+4+2 = 14，结尾还得填充 2Byte，以满足为 4 的倍数，所以总的大小为 16。</p><hr><h4 id="混合结构体的大小"><a href="#混合结构体的大小" class="headerlink" title="混合结构体的大小"></a>混合结构体的大小</h4><p>混合结构体指的是结构体中包含有共用体（或数组）等比较复杂的结构体。如下面的例子：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">union</span>&#123;</span></span><br><span class="line">    <span class="keyword">long</span> i;</span><br><span class="line">    <span class="keyword">int</span> k[<span class="number">5</span>];</span><br><span class="line">    <span class="keyword">char</span> c;</span><br><span class="line">&#125; UDATE;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">data</span>&#123;</span></span><br><span class="line">    <span class="keyword">int</span> cat;</span><br><span class="line">    UDATE cow;</span><br><span class="line">    <span class="keyword">double</span> dog;</span><br><span class="line">&#125;too;</span><br><span class="line">UDATE temp;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="keyword">sizeof</span>(struct data) + <span class="keyword">sizeof</span>(temp) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>摘自《后台开发：核心技术与应用实践》例1.16，书中后面的解释有部分错误。</p></blockquote><p>输出：<strong>64</strong></p><p>假设测试机器是 64 位。UDATE 是一个 union，作为变量公用空间。里面占用字节数最多的变量是数组 int k[5]，有 20Byte，但是它要与 long 类型的 8Byte 对齐，所以占用 24Byte。data 是一个 struct，每个变量分开占用空间，依次为 int(4+4) + UDATE(24) + double(8) = 40，字节已对齐，故 sizeof(struct data) 是 40。所以最后的结果为 40+24 = 64。</p><hr><h4 id="类对象的大小"><a href="#类对象的大小" class="headerlink" title="类对象的大小"></a>类对象的大小</h4><p>关于类占用的内存空间，有以下几点需要注意：</p><ol><li><p>如果类中含有虚函数，则编译器需要为类构建虚函数表，类中需要存储一个指针指向这个虚函数表的首地址，注意不管有几个虚函数，都只建立一张表，所有的虚函数地址都存在这张表里，类中只需要一个指针指向虚函数表首地址即可。</p></li><li><p>类中的静态成员是被类所有实例所共享的，它不计入sizeof计算的空间。</p></li><li><p>类中的普通函数或静态普通函数都存储在栈中，不计入sizeof计算的空间。</p></li><li><p>类成员采用字节对齐的方式分配空间。</p></li></ol><p><strong>总的来说</strong>，类对象占用的内存空间为：<u>非静态成员变量总和</u> 加上 <u>编译器为了 CPU 计算做出的数据对齐处理</u> 和 <u>支持虚函数所产生的负担</u> 的总和。</p><p>例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class B&#123;</span><br><span class="line">    public:</span><br><span class="line">        virtual void funa();</span><br><span class="line">        virtual void funb();</span><br><span class="line">        void func();</span><br><span class="line">        static void fund();</span><br><span class="line">        static int si; </span><br><span class="line"></span><br><span class="line">    private:</span><br><span class="line">        char c;</span><br><span class="line">        int i;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>以上类的大小：<strong>sizeof(B) = 12（32位）</strong>；<strong>sizeof(B) = 16（64位）</strong>。</p><p>根据以上的规则，多个虚函数只建立一张虚函数表，类中只存有一个指向虚函数表首地址的指针；普通函数 <code>func()</code> 不计入；静态成员 <code>fund()</code> 与 <code>si</code> 也不计入；char c 占用 1Byte，再需补充 3Byte；int i 占用 4Byte。所以总的大小为：一个指针大小+1+3+4。32位系统指针大小为 4Byte，所以为 12Byte；64位系统指针大小为 8Byte，所以总大小为 16Byte。</p><hr>]]></content>
      
      
      <categories>
          
          <category> C++ </category>
          
      </categories>
      
      
        <tags>
            
            <tag> sizeof </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>GDB 使用简介</title>
      <link href="2019/03/03/GDB%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/"/>
      <url>2019/03/03/GDB%E4%BD%BF%E7%94%A8%E7%AE%80%E4%BB%8B/</url>
      
        <content type="html"><![CDATA[<p>本文内容是我个人觉得在使用 gdb 时经常会用到的一些东西，根据以下参考链接中的内容整理而来，如需更全面的内容请查看参考链接。</p><p>参考链接：</p><p><a href="https://sourceware.org/gdb/onlinedocs/gdb/">Debugging with GDB</a></p><p><a href="http://wiki.ubuntu.org.cn/%E7%94%A8GDB%E8%B0%83%E8%AF%95%E7%A8%8B%E5%BA%8F#.E6.98.BE.E7.A4.BA.E6.BA.90.E4.BB.A3.E7.A0.81">用GDB调试程序</a></p><a id="more"></a><hr><h3 id="1-使用-GDB-调试-C-C-程序"><a href="#1-使用-GDB-调试-C-C-程序" class="headerlink" title="1.  使用 GDB 调试 C/C++ 程序"></a>1.  使用 GDB 调试 C/C++ 程序</h3><p>要调试 C/C++ 程序，在使用 gcc/g++ 编译器编译生成可执行文件时要加上 -g 选项，把调试信息加到可执行文件中。编译如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ gcc -g hello.c -o hello</span><br><span class="line">$ g++ -g hello.cpp -o hello</span><br></pre></td></tr></table></figure><blockquote><p>如果没有-g，你将看不见程序的函数名、变量名，所代替的全是运行时的内存地址。</p></blockquote><p>当你用 -g 把调试信息加入之后，并成功编译目标代码以后，让我们来看看如何用 gdb 来调试他。</p><hr><h3 id="2-启动-GDB-并加载被调试程序"><a href="#2-启动-GDB-并加载被调试程序" class="headerlink" title="2.  启动 GDB 并加载被调试程序"></a>2.  启动 GDB 并加载被调试程序</h3><p>启动 gdb 并加载被调试程序的方式有以下几种：</p><ul><li><p><code>gdb &lt;program&gt;</code></p><p>program也就是你的执行文件，一般在当前目录下。</p></li><li><p><code>gdb &lt;program&gt; core</code></p><p>用gdb同时调试一个运行程序和core文件，core是程序非法执行后core dump后产生的文件。</p></li><li><p><code>gdb &lt;program&gt; &lt;PID&gt;</code></p><p>如果你的程序是一个服务程序，那么你可以指定这个服务程序运行时的进程ID。gdb会自动attach上去，并调试他。program应该在PATH环境变量中搜索得到。</p></li></ul><blockquote><p>以上三种都是在启动 gdb 的同时加载被调试程序。也可以先进入gdb环境，然后再加载被调试程序，方法如下：</p><ol><li>先启动 gdb：终端输入命令 gdb</li><li>加载被调试程序：在 gdb 环境中执行 <code>file &lt;program&gt;</code></li></ol><p>注：上面两步与 <code>gdb &lt;program&gt;</code> 等效。</p></blockquote><p>进入 gdb 的调试环境后，可以使用 help 命令来查看 gdb 相关的命令，这些帮助信息都是可以根据提示来操作的。</p><hr><h3 id="3-查看源代码"><a href="#3-查看源代码" class="headerlink" title="3.  查看源代码"></a>3.  查看源代码</h3><h4 id="3-1-显示源代码"><a href="#3-1-显示源代码" class="headerlink" title="3.1  显示源代码"></a>3.1  显示源代码</h4><p>GDB 可以打印出所调试程序的源代码，当然，在程序编译时一定要加上-g的参数，把源程序信息编译到执行文件中。不然就看不到源程序了。当程序停下来以后，GDB会报告程序停在了那个文件的第几行上。你可以用list命令来打印程序的源代码。还是来看一看<strong>查看源代码的GDB命令</strong>：</p><ul><li><p><code>list &lt;n&gt;</code></p><p>显示程序第 n 行周围的源程序</p></li><li><p><code>list &lt;function&gt;</code></p><p>显示函数名为function的函数的源程序</p></li><li><p><code>list</code></p><p>显示当前行 <strong>后面</strong> 的源程序</p></li><li><p><code>list -</code></p><p>显示当前行 <strong>前面</strong> 的源程序</p></li></ul><p>一般是打印当前行的上5行和下5行，如果显示函数是是上2行下8行，默认是10行。当然，你也可以定制显示的范围，使用下面命令可以<strong>设置一次显示源程序的行数</strong>：</p><ul><li><p><code>set listsize &lt;count&gt;</code></p><p>设置一次显示 count 行源代码</p></li><li><p><code>show listsize</code></p><p>查看当前 listsize 的设置</p></li></ul><p><strong>list命令还有下面的用法：</strong></p><ul><li><p><code>list &lt;first&gt;, &lt;last&gt;</code></p><p>显示从 first 行到 last 行之间的源代码</p></li><li><p><code>list ,&lt;last&gt;</code></p><p>显示从当前行到last行之间的源代码</p></li><li><p><code>list +</code></p><p>往后显示源代码</p></li></ul><p><strong>总结一下，一般来说在list后面可以跟以下这些参数：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;linenum&gt;   行号</span><br><span class="line">&lt;+offset&gt;   当前行号的正偏移量</span><br><span class="line">&lt;-offset&gt;   当前行号的负偏移量</span><br><span class="line">&lt;filename:linenum&gt;  哪个文件的哪一行</span><br><span class="line">&lt;function&gt;  函数名</span><br><span class="line">&lt;filename:function&gt; 哪个文件中的哪个函数</span><br><span class="line">&lt;*address&gt;  程序运行时的语句在内存中的地址</span><br></pre></td></tr></table></figure><hr><h4 id="3-2-搜索源代码"><a href="#3-2-搜索源代码" class="headerlink" title="3.2  搜索源代码"></a>3.2  搜索源代码</h4><p>GDB 提供了以下源代码搜索命令：</p><ul><li><p><code>search &lt;regexp&gt;</code> 或 <code>forward-search &lt;regexp&gt;</code></p><p><strong>往下查找</strong>第一个符合正则表达式 regexp 的行</p></li><li><p><code>reverse-search &lt;regexp&gt;</code></p><p><strong>往上查找</strong>第一个符合正则表达式 regexp 的行</p></li></ul><hr><h4 id="3-3-指定源文件的路径"><a href="#3-3-指定源文件的路径" class="headerlink" title="3.3  指定源文件的路径"></a>3.3  指定源文件的路径</h4><p>某些时候，用-g编译过后的执行程序中只是包括了源文件的名字，没有路径名。GDB提供了可以让你指定源文件的路径的命令，以便GDB进行搜索。</p><ul><li><p><code>directory &lt;dirname ...&gt;</code> 或 <code>dir &lt;dirname ...&gt;</code></p><p>添加一个源文件路径到当前路径的前面。如果你要指定多个路径，UNIX下你可以使用“:”，Windows下你可以使用“;”。</p></li><li><p><code>directory</code></p><p>重置源文件路径为默认值（<code>$cdir:$cwd</code> on Unix systems）。需要确认</p></li><li><p><code>show directories</code></p><p>显示定义了的源文件搜索路径</p></li></ul><hr><h3 id="4-在-GDB-中运行程序"><a href="#4-在-GDB-中运行程序" class="headerlink" title="4.  在 GDB 中运行程序"></a>4.  在 GDB 中运行程序</h3><p>当以 <code>gdb &lt;program&gt;</code> 方式启动 gdb 后，运行程序使用 <code>r</code> 或是 <code>run</code> 命令。程序的运行，你有可能需要设置下面四方面的事：</p><ol><li><p>程序运行参数</p><p><code>set args</code> ：可指定运行时参数。（如：<code>set args 10 20 30 40 50</code>）<br><code>show args</code> ：命令可以查看设置好的运行参数。</p></li><li><p>运行环境</p><p><code>path &lt;dir&gt;</code> ：可设定程序的运行路径。<br><code>show paths</code>： 查看程序的运行路径。<br><code>set environment varname [=value]</code>： 设置环境变量。如：<code>set env USER=hchen</code><br><code>show environment [varname]</code> ：查看环境变量。</p></li><li><p>工作目录</p><p><code>cd &lt;dir&gt;</code> ：相当于 shell 的 cd 命令。<br><code>pwd</code>： 显示当前的所在目录。</p></li><li><p>程序的输入输出</p><p><code>info terminal</code>：显示你程序用到的终端的模式。<br><code>run &gt; outfile</code> ：使用重定向控制程序输出。<br><code>tty /dev/ttyb</code>：tty命令可以指定输入输出的终端设备。</p></li></ol><hr><h3 id="5-暂停程序运行"><a href="#5-暂停程序运行" class="headerlink" title="5.  暂停程序运行"></a>5.  暂停程序运行</h3><p>调试程序中，暂停程序运行是必须的，GDB可以方便地暂停程序的运行。你可以设置程序的在哪行停住，在什么条件下停住，在收到什么信号时停往等等。以便于你查看运行时的变量，以及运行时的流程。</p><p>当进程被gdb停住时，你可以使用info program 来查看程序的是否在运行，进程号，被暂停的原因。</p><p>在gdb中，我们可以有以下几种暂停方式：</p><ul><li>断点（BreakPoint）；</li><li>观察点（Watch Point）；</li><li>捕捉点（Catch Point）；</li><li>信号（Signals）；</li><li>线程停止（Thread Stops）。</li></ul><p>如果要恢复程序运行，可以使用 c 或是 continue命令。</p><h4 id="5-1-断点设置"><a href="#5-1-断点设置" class="headerlink" title="5.1  断点设置"></a>5.1  断点设置</h4><p>我们用 break 命令（简写为 b）来设置断点。下面有几点<strong>设置断点的方法</strong>：</p><ul><li><p><code>break &lt;function&gt;</code></p><p>在进入指定函数时停住。C++ 中可以使用 class::function 或 function(type,type) 格式来指定函数名.</p></li><li><p><code>break &lt;linenum&gt;</code></p><p>在指定行号设置断点。</p></li><li><p><code>break +offset</code> 与 <code>break -offset</code></p><p>在当前行号的前面或后面的 offset 行停住。offiset为自然数。</p></li><li><p><code>break filename:linenum</code></p><p>在源文件 filename 的 linenum 行处停住。</p></li><li><p><code>break filename:linenum</code></p><p>在源文件 filename 的 function 函数的入口处停住。</p></li><li><p><code>break *address</code></p><p>在程序运行的内存地址处停住。</p></li><li><p><code>break</code></p><p>break命令没有参数时，表示在下一条指令处停住。</p></li><li><p><code>break ... if &lt;condition&gt;</code></p><p>…可以是上述的参数，condition表示条件，在条件成立时停住。比如在循环体中，可以设置break if i==100，表示当i为100时停住程序。</p></li></ul><p><strong>查看断点时，可使用info命令</strong>，如下所示：</p><ul><li><code>info breakpoints [n]</code></li><li><code>info break [n]</code></li></ul><blockquote><p>注：n表示断点号。也可以不加 n，表示显示所有断点。</p><p><strong>断点菜单：</strong></p><p>在C++中，可能会重复出现同一个名字的函数若干次（函数重载），在这种情况下，break <function>不能告诉GDB要停在哪个函数的入口。当然，你可以使用break &lt;function(type)&gt;也就是把函数的参数类型告诉GDB，以指定一个函数。否则的话，GDB会给你列出一个断点菜单供你选择你所需要的断点。你只要输入你菜单列表中的编号就可以了。如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">(gdb) b String::after</span><br><span class="line">[0] cancel</span><br><span class="line">[1] all</span><br><span class="line">[2] file:String.cc; line number:867</span><br><span class="line">[3] file:String.cc; line number:860</span><br><span class="line">[4] file:String.cc; line number:875</span><br><span class="line">[5] file:String.cc; line number:853</span><br><span class="line">[6] file:String.cc; line number:846</span><br><span class="line">[7] file:String.cc; line number:735</span><br><span class="line">&gt; 2 4 6</span><br><span class="line">Breakpoint 1 at 0xb26c: file String.cc, line 867.</span><br><span class="line">Breakpoint 2 at 0xb344: file String.cc, line 875.</span><br><span class="line">Breakpoint 3 at 0xafcc: file String.cc, line 846.</span><br><span class="line">Multiple breakpoints were set.</span><br><span class="line">Use the &quot;delete&quot; command to delete unwanted</span><br><span class="line">breakpoints.</span><br><span class="line">(gdb)</span><br></pre></td></tr></table></figure><p>可见，GDB 列出了所有 after 的重载函数，你可以选一下列表编号就行了。0表示放弃设置断点，1表示所有函数都设置断点。</p></blockquote><hr><h4 id="5-2-观察点设置"><a href="#5-2-观察点设置" class="headerlink" title="5.2  观察点设置"></a>5.2  观察点设置</h4><p>观察点一般来观察某个表达式（变量也是一种表达式）的值是否有变化了，如果有变化，马上停住程序。我们有下面的几种方法来<strong>设置观察点</strong>：</p><ul><li><p><code>watch &lt;expr&gt;</code></p><p>为表达式（变量）expr 设置一个观察点。一表达式值有变化时，马上停住程序。</p></li><li><p><code>rwatch &lt;expr&gt;</code></p><p>当表达式（变量）expr被读时，停住程序。</p></li><li><p><code>awatch &lt;expr&gt;</code></p><p>当表达式（变量）的值被读或被写时，停住程序。</p></li><li><p><code>info watchpoints</code></p><p>列出当前所设置的所有观察点。</p></li></ul><hr><h4 id="5-3-捕捉点设置"><a href="#5-3-捕捉点设置" class="headerlink" title="5.3  捕捉点设置"></a>5.3  捕捉点设置</h4><p>你可设置捕捉点来捕捉程序运行时的一些事件。如：载入共享库（动态链接库）或是C++的异常。用以下格式<strong>设置捕捉点</strong>：</p><ul><li><p><code>catch &lt;event&gt;</code></p><p>当event发生时，停住程序。event可以是下面的内容：</p><ul><li>throw 一个C++抛出的异常。（throw为关键字）</li><li>catch 一个C++捕捉到的异常。（catch为关键字）</li><li>exec 调用系统调用exec时。（exec为关键字，目前此功能只在HP-UX下有用）</li><li>fork 调用系统调用fork时。（fork为关键字，目前此功能只在HP-UX下有用）</li><li>vfork 调用系统调用vfork时。（vfork为关键字，目前此功能只在HP-UX下有用）</li><li>load 或 load <libname> 载入共享库（动态链接库）时。（load为关键字，目前此功能只在HP-UX下有用）</li><li>unload 或 unload <libname> 卸载共享库（动态链接库）时。（unload为关键字，目前此功能只在HP-UX下有用）</li></ul></li><li><p><code>tcatch &lt;event&gt;</code></p><p>只设置一次捕捉点，当程序停住以後，该点被自动删除。</p></li></ul><hr><h4 id="5-4-维护停止点"><a href="#5-4-维护停止点" class="headerlink" title="5.4  维护停止点"></a>5.4  维护停止点</h4><p>上面说了如何设置程序的停止点，GDB中的停止点也就是上述的三类。在GDB中，如果你觉得已定义好的停止点没有用了，你可以使用delete、clear、disable、enable这几个命令来进行维护：</p><ul><li><p><code>clear</code></p><p>清除所有的已定义的停止点。</p></li><li><p><code>clear &lt;function&gt;</code> 与 <code>clear &lt;filename:function&gt;</code></p><p>清除所有设置在函数上的停止点。</p></li><li><p><code>clear &lt;linenum&gt;</code> 与 <code>clear &lt;filename:linenum&gt;</code></p><p>清除所有设置在指定行上的停止点。</p></li><li><p><code>delete [breakpoints][range...]</code></p><p>删除指定的断点，breakpoints为断点号。如果不指定断点号，则表示删除所有的断点。range 表示断点号的范围（如：3-7）。其简写命令为 d。</p></li><li><p><code>disable [breakpoints][range...]</code></p><p>disable所指定的停止点，breakpoints为停止点号。如果什么都不指定，表示disable所有的停止点。简写命令是dis。这是一种比删除更好的方法，在需要时可以通过 enable 再次启用。</p></li><li><p><code>enable [breakpoints][range...]</code></p><p>enable所指定的停止点，breakpoints为停止点号。</p></li><li><p><code>enable [breakpoints] once range...</code></p><p>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动disable。</p></li><li><p><code>enable [breakpoints] delete range...</code></p><p>enable所指定的停止点一次，当程序停止后，该停止点马上被GDB自动删除。</p></li></ul><hr><h3 id="6-恢复程序运行和单步调试"><a href="#6-恢复程序运行和单步调试" class="headerlink" title="6.  恢复程序运行和单步调试"></a>6.  恢复程序运行和单步调试</h3><p>当程序被停住了，你可以用 continue 命令恢复程序的运行直到程序结束，或下一个断点到来。也可以使用 step或 next 命令单步跟踪程序。</p><ul><li><p><code>continue [ignore-count]</code> 或 <code>c [ignore-count]</code> 或 <code>fg [ignore-count]</code></p><p>恢复程序运行，直到程序结束，或是下一个断点到来。ignore-count表示忽略其后的断点次数。continue，c，fg三个命令都是一样的意思。</p></li><li><p><code>step &lt;count&gt;</code></p><p>单步跟踪，如果有函数调用，他会进入该函数。进入函数的前提是，此函数被编译有debug信息。很像VC等工具中的step in。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p></li><li><p><code>next &lt;count&gt;</code></p><p>同样单步跟踪，如果有函数调用，他不会进入该函数。很像VC等工具中的step over。后面可以加count也可以不加，不加表示一条条地执行，加表示执行后面的count条指令，然后再停住。</p></li><li><p><code>set step-mode</code>  或 <code>set step-mode on</code></p><p>打开step-mode模式，于是，在进行单步跟踪时，程序不会因为没有 debug 信息而不停住。这个参数很有利于查看机器码。</p></li><li><p><code>set step-mode off</code></p><p>关闭step-mode模式</p></li><li><p><code>finish</code></p><p>运行程序，直到当前函数完成返回。并打印函数返回时的堆栈地址和返回值及参数值等信息。</p></li><li><p><code>until</code> 或 <code>u</code></p><p>当你厌倦了在一个循环体内单步跟踪时，这个命令可以运行程序直到退出循环体。</p></li><li><p><code>stepi</code> 或 <code>si</code> | <code>nexti</code> 或 <code>ni</code></p><p>单步跟踪一条机器指令！一条程序代码有可能由数条机器指令完成，stepi和nexti可以单步执行机器指令。与之一样有相同功能的命令是 “display/i $pc” ，当运行完这个命令后，单步跟踪会在打出程序代码的同时打出机器指令（也就是汇编代码）</p></li></ul><hr><h3 id="7-查看栈信息"><a href="#7-查看栈信息" class="headerlink" title="7.  查看栈信息"></a>7.  查看栈信息</h3><p>当程序被停住了，你需要做的第一件事就是查看程序是在哪里停住的。当你的程序调用了一个函数，函数的地址，函数参数，函数内的局部变量都会被压入“栈”（Stack）中。你可以用GDB命令来查看当前的栈中的信息。</p><p>下面是一些<strong>查看函数调用栈信息</strong>的 GDB 命令：</p><ul><li><p><code>backtrace</code> 或 <code>bt</code></p><p>打印当前的函数调用栈的所有信息。</p></li><li><p><code>backtrace &lt;n&gt;</code> 或 <code>bt &lt;n&gt;</code></p><p>n是一个正整数，表示只打印栈顶上n层的栈信息。</p></li><li><p><code>backtrace &lt;-n&gt;</code> 或 <code>bt &lt;-n&gt;</code> </p><p>-n表一个负整数，表示只打印栈底下n层的栈信息。</p></li></ul><p>如果你要查看某一层的信息，你需要切换当前栈，一般来说，程序停止时，最顶层的栈就是当前栈，如果你要查看栈下面层的详细信息，首先要做的是<strong>切换当前栈</strong>：</p><ul><li><p><code>frame &lt;n&gt;</code> 或 <code>f &lt;n&gt;</code></p><p>n是一个从0开始的整数，是栈中的层编号。比如：frame 0，表示栈顶，frame 1，表示栈的第二层。</p></li><li><p><code>up &lt;n&gt;</code></p><p>表示向栈的上面移动n层，可以不打n，表示向上移动一层。</p></li><li><p><code>down &lt;n&gt;</code></p><p>表示向栈的下面移动n层，可以不打n，表示向下移动一层。</p></li></ul><p><strong>查看当前栈层的信息</strong>，你可以用以下GDB命令：</p><ul><li><p><code>frame</code> 或 <code>f</code></p><p>会打印出这些信息：栈的层编号，当前的函数名，函数参数值，函数所在文件及行号，函数执行到的语句。</p></li><li><p><code>info frame</code> 或 <code>info f</code></p><p>这个命令会打印出更为详细的当前栈层的信息，只不过，大多数都是运行时的内存地址。比如：函数地址，调用函数的地址，被调用函数的地址，目前的函数是由什么样的程序语言写成的、函数参数地址及值、局部变量的地址等等。</p></li><li><p><code>info args</code></p><p>打印出当前函数的参数名及其值。</p></li><li><p><code>info locals</code></p><p>打印出当前函数中所有局部变量及其值。</p></li><li><p><code>info catch</code></p><p>打印出当前的函数中的异常处理信息。</p></li></ul><hr><h3 id="8-查看运行时数据"><a href="#8-查看运行时数据" class="headerlink" title="8.  查看运行时数据"></a>8.  查看运行时数据</h3><p>在你调试程序时，当程序被停住时，你可以使用 print 命令（简写命令为p），或是同义命令 inspect 来查看当前程序的运行数据。print 命令的格式是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print &lt;expr&gt;</span><br><span class="line">print &#x2F;&lt;f&gt; &lt;expr&gt;</span><br></pre></td></tr></table></figure><p><code>&lt;expr&gt;</code> 是表达式，是你所调试的程序的语言的表达式（GDB可以调试多种编程语言），<code>&lt;f&gt;</code> 是输出的格式，比如，如果要把表达式按16进制的格式输出，那么就是 <code>/x</code>。</p><h4 id="8-1-程序变量"><a href="#8-1-程序变量" class="headerlink" title="8.1  程序变量"></a>8.1  程序变量</h4><p>在GDB中，你可以随时查看以下三种变量的值：</p><ol><li>全局变量（所有文件可见的）</li><li>静态全局变量（当前文件可见的）</li><li>局部变量（当前Scope可见的）</li></ol><p>如果你的局部变量和全局变量发生冲突（也就是重名），一般情况下是局部变量会隐藏全局变量，也就是说，如果一个全局变量和一个函数中的局部变量同名时，如果当前停止点在函数中，用 print 显示出的变量的值会是函数中的局部变量的值。如果此时你想查看全局变量的值时，你可以使用 “::” 操作符：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print  file::variable</span><br><span class="line">print  function::variable</span><br></pre></td></tr></table></figure><hr><h4 id="8-2-自动显示"><a href="#8-2-自动显示" class="headerlink" title="8.2  自动显示"></a>8.2  自动显示</h4><p>你可以设置一些自动显示的变量，当程序停住时，或是在你单步跟踪时，这些变量会自动显示。相关的GDB命令是 display：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">display &lt;expr&gt;</span><br><span class="line">display&#x2F;&lt;fmt&gt; &lt;expr&gt;</span><br><span class="line">display&#x2F;&lt;fmt&gt; &lt;addr&gt;</span><br></pre></td></tr></table></figure><p>expr是一个表达式，fmt表示显示的格式，addr表示内存地址，当你用display设定好了一个或多个表达式后，只要你的程序被停下来，GDB会自动显示你所设置的这些表达式的值。</p><p>下面是一些和display相关的GDB命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">undisplay &lt;dnums...&gt;</span><br><span class="line">delete display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><p>删除自动显示，dnums意为所设置好了的自动显式的编号。如果要同时删除几个，编号可以用空格分隔，如果要删除一个范围内的编号，可以用减号表示（如：2-5）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">disable display &lt;dnums...&gt;</span><br><span class="line">enable display &lt;dnums...&gt;</span><br></pre></td></tr></table></figure><p>disable和enalbe不删除自动显示的设置，而只是让其失效和恢复。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">info display</span><br></pre></td></tr></table></figure><p>查看display设置的自动显示的信息。GDB会打出一张表格，向你报告当前调试中设置了多少个自动显示设置，其中包括，设置的编号，表达式，是否enable。</p><hr><h3 id="后记"><a href="#后记" class="headerlink" title="后记"></a>后记</h3><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> GDB </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>给新 Git 账户添加 ssh-key</title>
      <link href="2019/02/21/%E7%BB%99%E6%96%B0git%E8%B4%A6%E6%88%B7%E6%B7%BB%E5%8A%A0ssh-key/"/>
      <url>2019/02/21/%E7%BB%99%E6%96%B0git%E8%B4%A6%E6%88%B7%E6%B7%BB%E5%8A%A0ssh-key/</url>
      
        <content type="html"><![CDATA[<h2 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h2><p>在使用 git 的时候，git 与远程服务器一般通过 https 进行传输，这种传输方式在每次 push 和 pull 时都需要输入账户和密码，比较麻烦。所以更好的方法是通过 ssh 进行传输，这需要在本机上创建 ssh-key 密钥对，并把其中的公钥添加到远程的 Git 服务器中。但有时又会使用到多个 git 账户登录不同的 git 服务器，所以就涉及到添加 ssh-key 密钥对了。</p><a id="more"></a><p>我的环境中最初是针对 GitHub 的账户设置了 ssh 的密钥对，然后我现在需要针对另一个 git 账户进行设置密钥对，比如牛客网的 git 服务器。</p><h2 id="添加操作过程"><a href="#添加操作过程" class="headerlink" title="添加操作过程"></a>添加操作过程</h2><p><strong>1. 新建 SSH key：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.ssh</span><br><span class="line">$ ssh-keygen -t rsa -C &quot;xxx@email.com&quot;</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;chl&#x2F;.ssh&#x2F;id_rsa): id_rsa_nowcoder</span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in id_rsa_nowcoder.</span><br><span class="line">Your public key has been saved in id_rsa_nowcoder.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:hjOHuHTiXqCjTPCBf81owybsdflq&#x2F;HVWcq4jBZjnCNs xxx@email.com</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|                 |</span><br><span class="line">|   . o           |</span><br><span class="line">|o   Oo o         |</span><br><span class="line">|&#x3D;...oBoo         |</span><br><span class="line">| &#x3D;.+*+O.S o      |</span><br><span class="line">|+.o&#x3D;EB.&#x3D;.&#x3D;       |</span><br><span class="line">|o.* +.o .o .     |</span><br><span class="line">|.o + o.o.        |</span><br><span class="line">|o.  o  ...       |</span><br><span class="line">+----[SHA256]-----+</span><br></pre></td></tr></table></figure><blockquote><p>上面设置名称为 id_rsa_nowcoder</p></blockquote><p><strong>2. 新秘钥添加到 SSH agent 中</strong></p><p>因为默认只读取 id_rsa，为了让 SSH 识别新的私钥，需将其添加到 SSH agent 中：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa_nowcoder</span><br><span class="line">Could not open a connection to your authentication agent.</span><br></pre></td></tr></table></figure><p>但是出现了 Could not open a connection to your authentication agent. 的错误，用一下方法解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-agent bash</span><br><span class="line">$ ssh-add ~&#x2F;.ssh&#x2F;id_rsa_nowcoder</span><br><span class="line">Identity added: ~&#x2F;.ssh&#x2F;id_rsa_nowcoder (~&#x2F;.ssh&#x2F;id_rsa_nowcoder)</span><br></pre></td></tr></table></figure><p><strong>3. 在 git 账户中添加 SSH key</strong></p><p>登录 git 账户中添加，完成之后，SSH key 就生效了。检测方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone 你的仓库ssh地址</span><br></pre></td></tr></table></figure><p>若这时不再询问密码，说明设置生效。</p><p><strong>4. 更改远程仓库地址</strong></p><ul><li><p>修改命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git remote set-url origin 你的仓库ssh地址</span><br></pre></td></tr></table></figure></li><li><p>或者先删后加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git remote rm origin</span><br><span class="line">$ git remote add origin 你的仓库ssh地址</span><br></pre></td></tr></table></figure></li><li><p>或者修改 config 文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ git config -e</span><br><span class="line">修改 url</span><br></pre></td></tr></table></figure><p>更改完成之后，再通过 git push 或 git pull 就不需要输入账号和密码了。</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基于 v2ray 实现科学上网</title>
      <link href="2019/02/15/v2ray%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/"/>
      <url>2019/02/15/v2ray%E5%AE%9E%E7%8E%B0%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>原本在 vultr 上面购买的 VPS 上面搭建的 VPN 不能用了，具体原因就是 GTW 经过一波加强，可以通过 TCP 阻断来封锁一些用于搭建 VPN 的 VPS。TCP 阻断的结果就是在国内无法通过 tcp 来连接访问国外的 vps，从而在国内无法 ssh 登录 vps，但是使用 ping 工具却能 ping 通被 tcp 阻断的服务器，因为 ping 是基于 ICMP 的。这样给人一种 vps 没被封的错觉。</p><a id="more"></a><p>当 vps 被 TCP 阻断时，原本基于 shadowsocks 的科学上网方式就不能使用了，本文就是针对被 TCP 阻断的 vps，通过 v2ray 来实现科学上网。当然对于没有被 TCP 阻断的 vps 使用该方法来搭梯子也不容易被封。</p><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h3 id="1-服务器安装"><a href="#1-服务器安装" class="headerlink" title="1. 服务器安装"></a>1. 服务器安装</h3><p>在 Linux 操作系统， V2Ray 的安装有脚本安装、手动安装、编译安装 3 种方式，选择其中一种即可，本指南仅提供使用使用脚本安装的方法，并仅推荐使用脚本安装，该脚本由 V2Ray 官方提供。该脚本仅可以在 Debian 系列或者支持 Systemd 的 Linux 操作系统使用。 </p><p>本文基于 CentOS 7 服务器来实现。</p><p>首先下载脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># wget https:&#x2F;&#x2F;install.direct&#x2F;go.sh</span><br><span class="line">--2019-02-15 07:53:34--  https:&#x2F;&#x2F;install.direct&#x2F;go.sh</span><br><span class="line">Resolving install.direct (install.direct)... 104.27.174.71, 104.27.175.71, 2606:4700:30::681b:af47, ...</span><br><span class="line">Connecting to install.direct (install.direct)|104.27.174.71|:443... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: unspecified [text&#x2F;plain]</span><br><span class="line">Saving to: ‘go.sh’</span><br><span class="line"></span><br><span class="line">    [ &lt;&#x3D;&gt;                                                                                                               ] 13,915      --.-K&#x2F;s   in 0s      </span><br><span class="line"></span><br><span class="line">2019-02-15 07:53:34 (58.3 MB&#x2F;s) - ‘go.sh’ saved [13915]</span><br></pre></td></tr></table></figure><p>然后执行安装脚本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># sudo bash go.sh</span><br><span class="line">Installing V2Ray v4.16.0 on x86_64</span><br><span class="line">Downloading V2Ray: https:&#x2F;&#x2F;github.com&#x2F;v2ray&#x2F;v2ray-core&#x2F;releases&#x2F;download&#x2F;v4.16.0&#x2F;v2ray-linux-64.zip</span><br><span class="line">  % Total    % Received % Xferd  Average Speed   Time    Time     Time  Current</span><br><span class="line">                                 Dload  Upload   Total   Spent    Left  Speed</span><br><span class="line">100   608    0   608    0     0   1330      0 --:--:-- --:--:-- --:--:--  1333</span><br><span class="line">100 10.2M  100 10.2M    0     0  1723k      0  0:00:06  0:00:06 --:--:-- 2356k</span><br><span class="line">Updating software repo</span><br><span class="line">http:&#x2F;&#x2F;mirrors.syringanetworks.net&#x2F;fedora-epel&#x2F;7&#x2F;x86_64&#x2F;repodata&#x2F;5a7d69681e5cfd3ae41829a733077e717b512d3dee2d802edeeb206b7d8bda33-updateinfo.xml.bz2: [Errno 14] HTTP Error 404 - Not Found</span><br><span class="line">Trying other mirror.</span><br><span class="line">To address this issue please refer to the below wiki article </span><br><span class="line"></span><br><span class="line">https:&#x2F;&#x2F;wiki.centos.org&#x2F;yum-errors</span><br><span class="line"></span><br><span class="line">If above article doesn&#39;t help to resolve this issue please use https:&#x2F;&#x2F;bugs.centos.org&#x2F;.</span><br><span class="line"></span><br><span class="line">Installing unzip</span><br><span class="line">Extracting V2Ray package to &#x2F;tmp&#x2F;v2ray.</span><br><span class="line">Archive:  &#x2F;tmp&#x2F;v2ray&#x2F;v2ray.zip</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;config.json  </span><br><span class="line">   creating: &#x2F;tmp&#x2F;v2ray&#x2F;doc&#x2F;</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;doc&#x2F;readme.md  </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;geoip.dat    </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;geosite.dat  </span><br><span class="line">   creating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;systemd&#x2F;v2ray.service  </span><br><span class="line">   creating: &#x2F;tmp&#x2F;v2ray&#x2F;systemv&#x2F;</span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;systemv&#x2F;v2ray  </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;v2ctl        </span><br><span class="line"> extracting: &#x2F;tmp&#x2F;v2ray&#x2F;v2ctl.sig    </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;v2ray        </span><br><span class="line"> extracting: &#x2F;tmp&#x2F;v2ray&#x2F;v2ray.sig    </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;vpoint_socks_vmess.json  </span><br><span class="line">  inflating: &#x2F;tmp&#x2F;v2ray&#x2F;vpoint_vmess_freedom.json  </span><br><span class="line">PORT:40827</span><br><span class="line">UUID:505f001d-4aa8-4519-9c54-6b65749ee3fb</span><br><span class="line">Created symlink from &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;multi-user.target.wants&#x2F;v2ray.service to &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;v2ray.service.</span><br><span class="line">V2Ray v4.16.0 is installed.</span><br></pre></td></tr></table></figure><p>看到类似于这样的提示就算安装成功了。如果安装不成功脚本会有红色的提示语句，这个时候你应当按照提示除错，除错后再重新执行一遍脚本安装 V2Ray。 </p><p>在上面的提示中，有一行 “PORT:40827” 代表着端口号为 40827，还有一行 “UUID:505f001d-4aa8-4519-9c54-6b65749ee3fb” 代表着 id 为 505f001d-4aa8-4519-9c54-6b65749ee3fb。这两个都是随机生成的，不用担心跟别人撞上了。 </p><p>安装完之后，使用以下命令启动 V2Ray：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl start v2ray</span><br></pre></td></tr></table></figure><p>在首次安装完成之后，V2Ray 不会自动启动，需要手动运行上述启动命令。 </p><hr><h3 id="2-服务端配置"><a href="#2-服务端配置" class="headerlink" title="2. 服务端配置"></a>2. 服务端配置</h3><p>v2ray 的配置文件位于 <code>/etc/v2ray/config.json</code>。v2ray 相对于 shadowsocks 更复杂的地方就在于其有众多的配置选项，针对不同的应用场景有不同的配置方案，从而实现不同的功能，而 shadowsocks 则相对傻瓜一些。要详细讲述 v2ray 的所有配置选项是需要很长的内容的，本文针对被 TCP 阻断的 VPS 来实现 vpn 的场景。下面简单介绍一些配置内容：</p><ul><li><p><strong>VMess</strong></p><p>VMess 协议是由 V2Ray 原创并使用于 V2Ray 的加密传输协议，如同 Shadowsocks 一样为了对抗墙的深度包检测而研发的。在 V2Ray 上客户端与服务器的通信主要是通过 VMess 协议通信。 </p><p>V2Ray 使用 inbound(传入) 和 outbound(传出) 的结构，这样的结构非常清晰地体现了数据包的流动方向，同时也使得 V2Ray 功能强大复杂的同时而不混乱，清晰明了。形象地说，我们可以把 V2Ray 当作一个盒子，这个盒子有入口和出口(即 inbound 和 outbound)，我们将数据包通过某个入口放进这个盒子里，然后这个盒子以某种机制（这个机制其实就是路由，后面会讲到）决定这个数据包从哪个出口吐出来。以这样的角度理解的话，V2Ray 做客户端，则 inbound 接收来自浏览器数据，由 outbound 发出去(通常是发到 V2Ray 服务器)；V2Ray 做服务器，则 inbound 接收来自 V2Ray 客户端的数据，由 outbound 发出去(通常是如 Google 等想要访问的目标网站)。 </p></li><li><p><strong>mKCP</strong></p><p>V2Ray 引入了 KCP 传输协议，并且做了一些不同的优化，称为 mKCP。 mKCP 使用 UDP 来模拟 TCP 连接，这样即使 vps 被 TCP 阻断了，还是能够通过 UDP 来连接。mKCP 牺牲带宽来降低延迟，传输同样的内容，mKCP 一般比 TCP 消耗更多的流量，但是对于我购买的 vps 流量一般都用的很少，每个月用不完 十分之一，所以采用 mKCP 对流量消耗也没有太大的问题。</p></li></ul><p>服务端采用 <code>vmess + mKCP</code> 的配置时，配置文件 <code>/etc/v2ray/config.json</code> 的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;port&quot;: 40827,</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;clients&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;id&quot;: &quot;505f001d-4aa8-4519-9c54-6b65749ee3fb&quot;,</span><br><span class="line">            &quot;alterId&quot;: 64</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;mkcp&quot;,</span><br><span class="line">        &quot;kcpSettings&quot;: &#123;</span><br><span class="line">          &quot;uplinkCapacity&quot;: 5,</span><br><span class="line">          &quot;downlinkCapacity&quot;: 100,</span><br><span class="line">          &quot;congestion&quot;: true,</span><br><span class="line">          &quot;header&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;none&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;freedom&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改完配置文件后，需要重新启动 v2ray：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># systemctl restart v2ray</span><br></pre></td></tr></table></figure><p>最后，还需要修改 vps 的防火墙设置，将对应的 udp 端口放行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --zone&#x3D;public --add-port&#x3D;40827&#x2F;udp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><p>再设置 v2ray 开机自启动，修改 <code>/etc/rc.local</code> 文件，添加：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">systemctl restart v2ray</span><br></pre></td></tr></table></figure><p>服务端配置完毕。</p><hr><h3 id="3-客户端安装"><a href="#3-客户端安装" class="headerlink" title="3. 客户端安装"></a>3. 客户端安装</h3><p>下载客户端，windows 系统下有两种客户端，一种是不带图形界面的，另一种是在其基础上增加了图形界面的。为了方便，使用带有图形界面的版本。下载连接：<a href="https://github.com/2dust/v2rayN/releases">v2rayN</a>，下载 Lastest release 的 <code>v2rayN.zip</code> 压缩包。</p><p>解压后运行 <code>v2rayN.exe</code> 程序，双击任务栏图标打开界面：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/v2rayN%E7%95%8C%E9%9D%A2.png?raw=true" alt="v2rayN界面"></p><p>点击上方<strong>检查更新</strong>，<strong>检查更新 v2rayCore</strong>，点击“是”。</p><p>更新完后，点击<strong>服务器</strong>，<strong>添加[VMess]服务器</strong>，如下配置：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/vmess%E6%9C%8D%E5%8A%A1%E5%99%A8%E9%85%8D%E7%BD%AE.png?raw=true" alt="vmess服务器配置"></p><p>配置完成点击确定，右键任务栏 v2rayN 图标，点击<strong>启用http代理</strong>，http 代理模式可选择 <strong>PAC模式</strong> 或者 <strong>全局模式</strong>。</p><p>这样，客户端的配置也完成，即可开始科学上网。</p><hr><h2 id="其他内容"><a href="#其他内容" class="headerlink" title="其他内容"></a>其他内容</h2><ol><li><p><strong>非图形界面客户端配置：</strong></p><p>如果客户端没有使用带有图形界面的 v2rayN，其配置稍微复杂一点，需要自己修改客户端配置文件 <code>config.json</code>，配置内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;inbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;port&quot;: 1080,</span><br><span class="line">      &quot;protocol&quot;: &quot;socks&quot;,</span><br><span class="line">      &quot;sniffing&quot;: &#123;</span><br><span class="line">        &quot;enabled&quot;: true,</span><br><span class="line">        &quot;destOverride&quot;: [&quot;http&quot;, &quot;tls&quot;]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;auth&quot;: &quot;noauth&quot;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ],</span><br><span class="line">  &quot;outbounds&quot;: [</span><br><span class="line">    &#123;</span><br><span class="line">      &quot;protocol&quot;: &quot;vmess&quot;,</span><br><span class="line">      &quot;settings&quot;: &#123;</span><br><span class="line">        &quot;vnext&quot;: [</span><br><span class="line">          &#123;</span><br><span class="line">            &quot;address&quot;: &quot;xxx.xxx.xxx.xxx&quot;,</span><br><span class="line">            &quot;port&quot;: 40827,</span><br><span class="line">            &quot;users&quot;: [</span><br><span class="line">              &#123;</span><br><span class="line">                &quot;id&quot;: &quot;505f001d-4aa8-4519-9c54-6b65749ee3fb&quot;,</span><br><span class="line">                &quot;alterId&quot;: 64</span><br><span class="line">              &#125;</span><br><span class="line">            ]</span><br><span class="line">          &#125;</span><br><span class="line">        ]</span><br><span class="line">      &#125;,</span><br><span class="line">      &quot;streamSettings&quot;: &#123;</span><br><span class="line">        &quot;network&quot;: &quot;mkcp&quot;,</span><br><span class="line">        &quot;kcpSettings&quot;: &#123;</span><br><span class="line">          &quot;uplinkCapacity&quot;: 5,</span><br><span class="line">          &quot;downlinkCapacity&quot;: 100,</span><br><span class="line">          &quot;congestion&quot;: true,</span><br><span class="line">          &quot;header&quot;: &#123;</span><br><span class="line">            &quot;type&quot;: &quot;none&quot;</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>配置完 v2ray 并启动之后，还需要配合浏览器的一些代理插件来实现科学上网，如谷歌浏览器与火狐浏览器的 <code>SwitchyOmega</code> 插件，如何使用这里不介绍。</p></li><li><p><strong>参考链接</strong></p><p>v2ray 配置指南：<a href="https://toutyrater.github.io/">https://toutyrater.github.io</a></p><p>v2ray配置模板：<a href="https://github.com/KiriKira/vTemplate">https://github.com/KiriKira/vTemplate</a></p></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> v2ray </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>孤儿进程与僵尸进程</title>
      <link href="2018/12/26/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/"/>
      <url>2018/12/26/%E5%AD%A4%E5%84%BF%E8%BF%9B%E7%A8%8B%E4%B8%8E%E5%83%B5%E5%B0%B8%E8%BF%9B%E7%A8%8B/</url>
      
        <content type="html"><![CDATA[<p>本文主要内容包括：</p><ul><li>产生孤儿进程、僵尸进程的条件；</li><li>通过程序来产生孤儿进程与僵尸进程。</li></ul><a id="more"></a><hr><h3 id="孤儿进程与僵尸进程的产生条件"><a href="#孤儿进程与僵尸进程的产生条件" class="headerlink" title="孤儿进程与僵尸进程的产生条件"></a>孤儿进程与僵尸进程的产生条件</h3><p>在 UNIX/Linux 中，正常情况下，子进程是通过父进程创建的，子进程再创建新的进程。子进程的结束和父进程的运行是一个异步过程，即父进程永远无法预测子进程到底什么时候结束。于是就产生了孤儿进程和僵尸进程。</p><ul><li><strong>孤儿进程</strong>：是指一个父进程退出后，而它的一个或多个子进程还在运行，那么那些子进程将会成为孤儿进程。孤儿进程将被 init 进程（进程号为 1）所收养，并由 init 进程对它们完成状态收集工作。</li><li><strong>僵尸进程</strong>：是指一个进程使用 fork 创建子进程，如果子进程退出，而父进程并没有调用 wait 或 waitpid 获取子进程的状态信息，那么子进程的进程描述符仍然保存在系统中，这种进程称为僵尸进程。当一个进程完成它的工作终止之后，它的父进程需要调用 wait() 或 waitpid() 系统调用取得子进程的终止状态。</li></ul><p>可以这样理解孤儿进程和僵尸进程的区别：孤儿进程是父进程已退出，而子进程未退出；僵尸进程是父进程未退出，而子进程已退出。他们的共同点：都是子进程处于这两种状态。</p><hr><h3 id="通过程序产生孤儿进程与僵尸进程"><a href="#通过程序产生孤儿进程与僵尸进程" class="headerlink" title="通过程序产生孤儿进程与僵尸进程"></a>通过程序产生孤儿进程与僵尸进程</h3><p>下面通过程序来具体展示如何产生孤儿进程与僵尸进程，并且说明如何在 Linux 系统中检测这些处于非正常状态的进程。</p><h4 id="产生一个孤儿进程："><a href="#产生一个孤儿进程：" class="headerlink" title="产生一个孤儿进程："></a>产生一个孤儿进程：</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;    <span class="comment">/* 父进程 */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent, PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Child PID: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;  <span class="comment">/* 子进程 */</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child,  PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Parent PID: &quot;</span> &lt;&lt; getppid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># .&#x2F;a.out</span><br><span class="line">Parent, PID: 16911 Child PID: 16912</span><br><span class="line">Child,  PID: 16912 Parent PID: 1</span><br></pre></td></tr></table></figure><p>可以看到，子进程中输出的父进程ID是 1，而不是 16911。这就是因为在子进程睡眠的时间内，父进程运行结束并退出了，子进程称为了一个孤儿进程，并且被 init 进程收养，所以子进程的父进程ID就是 init 进程的进程ID了。</p><p>或者比较快地（睡眠时间结束前）在另一个终端上面使用 ps 命令可以显示出 PID 为 16912 的进程的 PPID 是 1。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps -ef |egrep &#39;(a.out|PID)&#39; |grep -v grep</span><br><span class="line">UID        PID  PPID  C STIME TTY          TIME CMD</span><br><span class="line">chl      16912     1  0 16:17 pts&#x2F;18   00:00:00 &#x2F;tmp&#x2F;a.out</span><br></pre></td></tr></table></figure><blockquote><p>以上用了支持扩展正则表达式的 egrep 命令来过滤输出，以同时输出标题行。并且使用 grep -v 来反向选择了 grep，使得不输出包含 grep 的行。</p></blockquote><hr><h4 id="产生一个僵尸进程："><a href="#产生一个僵尸进程：" class="headerlink" title="产生一个僵尸进程："></a>产生一个僵尸进程：</h4><p>还是和上面类似的进程，不过是需要使父进程进入睡眠：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">pid_t</span> pid;</span><br><span class="line">    pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Parent, PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Child PID: &quot;</span> &lt;&lt; pid &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        sleep(<span class="number">10</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;Child,  PID: &quot;</span> &lt;&lt; getpid() &lt;&lt; <span class="string">&quot; Parent PID: &quot;</span> &lt;&lt; getppid() &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>输出为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Parent, PID: 17135 Child PID: 17136</span><br><span class="line">Child,  PID: 17136 Parent PID: 17135</span><br></pre></td></tr></table></figure><p>以上程序中，子进程会比父进程先运行完并退出，但是父进程并没有采用其他的手段来获取子进程的状态消息并回收子进程的进程描述符，所以子进程变成了一个僵尸进程。</p><p>既可以通过 top 命令来检测当前系统的运行环境中存在僵尸进程，但是无法查看具体的信息。也可以通过 ps 命令来查看状态为 Z 的进程即为僵尸进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux |grep Z |grep -v grep</span><br><span class="line">USER       PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">chl      17136  0.0  0.0      0     0 pts&#x2F;18   Z+   16:36   0:00 [a.out] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><p>可以看到 PID 为 17136 的进程的状态 STAT 为 Z+，由此就创建了一个僵尸进程。但是在父进程结束睡眠并退出之后，如果再次使用上述的 ps 命令查看的话，会发现该僵尸进程消失了，这是因为：父进程退出后，这个僵尸进程就成为孤儿进程，过继给了 init 进程，而 init 进程会周期性地调用 wait 系统调用来清除各个僵尸的子进程。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 操作系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 孤儿进程 </tag>
            
            <tag> 僵尸进程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>kubeadm join success but node not joined</title>
      <link href="2018/12/18/kubernetes-node-not-joined/"/>
      <url>2018/12/18/kubernetes-node-not-joined/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>在搭建 Kubernetes 集群时，遇到这样一个问题，就是在 node 节点上使用 kubeadm join 时能够成功的加入节点，但是在 master 节点上却无法查看集群中的 node 节点。如下：</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">node1$ sudo kubeadm join --token 1bc310.cb323487a828849e 10.2.7.114:6443 --discovery-token-ca-cert-hash sha256:3d39f8fe34a043ccef4821014fd6d3e0f222614d37d59a6e4944c74f257c6d4d</span><br><span class="line">[preflight] Running pre-flight checks.</span><br><span class="line">[WARNING FileExisting-crictl]: crictl not found in system path</span><br><span class="line">[discovery] Trying to connect to API Server &quot;10.2.7.114:6443&quot;</span><br><span class="line">[discovery] Created cluster-info discovery client, requesting info from &quot;https:&#x2F;&#x2F;10.2.7.114:6443&quot;</span><br><span class="line">[discovery] Requesting info from &quot;https:&#x2F;&#x2F;10.2.7.114:6443&quot; again to validate TLS against the pinned public key</span><br><span class="line">[discovery] Cluster info signature and contents are valid and TLS certificate validates against pinned roots, will use API Server &quot;10.2.7.114:6443&quot;</span><br><span class="line">[discovery] Successfully established connection with API Server &quot;10.2.7.114:6443&quot;</span><br><span class="line"></span><br><span class="line">This node has joined the cluster:</span><br><span class="line">* Certificate signing request was sent to master and a response</span><br><span class="line">  was received.</span><br><span class="line">* The Kubelet was informed of the new secure connection details.</span><br><span class="line"></span><br><span class="line">Run &#39;kubectl get nodes&#39; on the master to see this node join the cluster.</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">master$ kubectl get nodes</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">ubuntu    Ready     master    4h        v1.9.1</span><br></pre></td></tr></table></figure><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><p>出现这个问题的原因是 node 节点的主机名与 master 节点的相同，因此需要给 所有的 node 节点取与 master 节点不同的主机名。</p><p>修改 <code>/etc/hostname</code> 以及 <code>/etc/hosts</code> 文件中的主机名，再通过命令临时设置主机名：<code>sudo hostname 主机名</code>。</p><p>配置完之后，在 node 节点上执行 <code>kubeadm reset</code>， 再重新执行 <code>kubeadm join</code> 。</p><p>最后在 master 节点上查看节点：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ kubectl get nodes</span><br><span class="line">NAME      STATUS    ROLES     AGE       VERSION</span><br><span class="line">node1     Ready     &lt;none&gt;    1h        v1.9.1</span><br><span class="line">node2     Ready     &lt;none&gt;    1h        v1.9.1</span><br><span class="line">ubuntu    Ready     master    6h        v1.9.1</span><br></pre></td></tr></table></figure><p>可以看到有两个 node 节点。</p><p>参考：<a href="https://github.com/kubernetes/kubernetes/issues/61224">issue 61224</a></p><hr>]]></content>
      
      
      <categories>
          
          <category> Kubernetes </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Bugs </tag>
            
            <tag> kubeadm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>解决 VPN 无法打开谷歌学术的问题</title>
      <link href="2018/12/17/%E8%A7%A3%E5%86%B3vpn%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98/"/>
      <url>2018/12/17/%E8%A7%A3%E5%86%B3vpn%E6%97%A0%E6%B3%95%E6%89%93%E5%BC%80%E8%B0%B7%E6%AD%8C%E5%AD%A6%E6%9C%AF%E7%9A%84%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><p>之前搭好的 VPN 用的好好的，最近两天突然不能登录谷歌学术（Google Scholar），但是还能使用谷歌搜索等其他国外的网站。登录谷歌学术网站出现：<code>We&#39;re sorry...... but your computer or network may be sending automated queries. To protect our users, we can&#39;t process your request right now.</code></p><a id="more"></a><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/google%20scholar%20error.png?raw=true"></p><h2 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h2><p>出现这个问题是因为我使用的是 Vultr 的 VPS 来搭建 shadowsocks 服务端，而且有很多人都在这些 VPS 服务商（Vultr，搬瓦工，DigitalOcean，Linode等等），然后有人使用这些公网的 IP 段来做爬虫，所以 Google 把这些公网 IP 给封了。但是一般封的都是 IPv4 的地址，IPv6 的地址一般没有被封，所以可以考虑使用 IPv6 来访问谷歌学术的网站。</p><hr><h2 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h2><ol><li><p>首先，找到最新的 Google IPv6 地址，可以在这里查看：<a href="https://raw.githubusercontent.com/lennylxx/ipv6-hosts/master/hosts">IPv6-hosts</a></p><p>找到 Google 学术对应的 IPv6 地址后，修改服务器的 hosts 文件，<code>vim /etc/hosts</code>，在文件的最后加入如下配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">## Scholar 学术搜索</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com.hk</span><br><span class="line">2404:6800:4008:c06::be scholar.google.com.tw</span><br><span class="line">2404:6800:4005:805::200e scholar.google.cn #www.google.cn</span><br></pre></td></tr></table></figure></li><li><p>然后，重启 shadowsocks 服务端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks restart</span><br></pre></td></tr></table></figure><blockquote><p>注：不同的搭建方式可能重启的方式不太一样。我的搭建方式请参考：<a href="https://cao0507.github.io/2018/08/21/VPS%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B6%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/">shadowsocks服务端搭建</a></p></blockquote><p>之后，就能够正常访问谷歌学术的网站了。</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/google%20scholar.png?raw=true"></p></li></ol><h2 id="其他问题"><a href="#其他问题" class="headerlink" title="其他问题"></a>其他问题</h2><p>有些时候，到这里可能还是不能正常访问谷歌学术。这个可能是因为 Vultr 上 5 美元的 VPS 默认使用的是 IPv4 的地址，而没有启用 IPv6 的地址，所以需要给你的 VPS 分配一个 IPv6 的地址。</p><p><strong>Server Information</strong> -&gt; <strong>Settings</strong> -&gt; <strong>IPv6</strong>：给你的 Server 分配（assign）一个 IPv6 地址，分配一个 IPv6 地址是不要钱的。这个过程会重启你的 VPS，重启之后，能看到有一个 IPv6 的地址，如下图：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/vps%20assign%20ipv6.png?raw=true"></p><blockquote><p>我一开始就是因为没有给我的 VPS 分配 IPv6 地址，所以修改了服务器的 hosts 文件也还是没有解决这个问题。你在解决问题的时候注意要先分配 IPv6 地址哦！</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shadowsocks </tag>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hyperledger Caliper Disable TLS</title>
      <link href="2018/12/15/fabric-disable-tls/"/>
      <url>2018/12/15/fabric-disable-tls/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>最近在使用 Hyperledger Caliper 时，想通过 wireshark 抓包来分析 fabric 运行流程中各阶段的数据信息，但是发现 fabric 节点间的通信使用了传输层安全（Transport Layer Security，TLS）协议，使得通信的报文的内容在抓包后无法分析。因此考虑在测试环境中暂时关闭 TLS，从而能够直接查看报文中承载的数据内容。</p><a id="more"></a><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><h4 id="1-在-docker-compose-的配置文件中修改环境变量"><a href="#1-在-docker-compose-的配置文件中修改环境变量" class="headerlink" title="1. 在 docker-compose 的配置文件中修改环境变量"></a>1. 在 docker-compose 的配置文件中修改环境变量</h4><p>本实验是在 Hyperledger Caliper 的测试环境中进行的，Caliper 测试工具在运行初始阶段会调用 docker-compose 启动 fabric 的网络，启动的 fabric 默认启用了 TLS，可以在其 docker-compose 的启动配置文件 docker-compose.yaml 中看到环境变量：</p><ul><li><code>FABRIC_CA_SERVER_TLS_ENABLED=true</code></li><li><code>ORDERER_GENERAL_TLS_ENABLED=true</code></li><li><code>CORE_PEER_TLS_ENABLED=true</code></li></ul><p>以上三个环境变量都设置为 true。如果要 disable TLS，则需在配置文件 docker-compose.yaml 中将这三个环境变量都注释掉，或者将它们设置为 false。即：</p><ul><li><code>FABRIC_CA_SERVER_TLS_ENABLED=false</code></li><li><code>ORDERER_GENERAL_TLS_ENABLED=false</code></li><li><code>CORE_PEER_TLS_ENABLED=false</code></li></ul><h4 id="2-修改-benchmark-中的-fabric-json-文件"><a href="#2-修改-benchmark-中的-fabric-json-文件" class="headerlink" title="2. 修改 benchmark 中的 fabric.json 文件"></a>2. 修改 benchmark 中的 fabric.json 文件</h4><p>在 benchmark 中的每个例子中，如 simple 的网络配置文件 fabric.json 中，client 与 peer 、orderer、ca 等节点都是通过 grpcs 或 https 来通信的，而这是在使用了 TLS 时的通信方式，因此需要将其改为 grpc 或 http 来通信。修改入下：</p><ul><li><code>orderer.url</code>：<code>grpcs://localhost:7050</code>  ==&gt;  <code>grpc://localhost:7050</code></li><li><code>ca.url</code>：<code>https://localhost:7054</code>  ==&gt;  <code>http://localhost:7054</code></li><li><code>peer1.requests</code>：<code>grpcs://localhost:7051</code>   ==&gt;  <code>grpc://localhost:7051</code></li><li><code>peer1.events</code>：<code>grpcs://localhost:7053</code>   ==&gt;   <code>grpc://localhost:7053</code></li></ul><p>其他的都是如此修改。</p><blockquote><p>如果用 vim 编辑器的话，可以快捷的使用全局替换功能，在 normal 模式下输入冒号：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:1,$  s&#x2F;grpcs&#x2F;grpc&#x2F;g       #表示将第一行到最后一行间的所有grpcs替换成grpc</span><br></pre></td></tr></table></figure></blockquote><h4 id="3-错误记录"><a href="#3-错误记录" class="headerlink" title="3. 错误记录"></a>3. 错误记录</h4><p>如果仅仅修改 docker-compose.yaml 文件中的环境变量，没有修改 fabric.json 中的通信方式的话，则在运行测试时会出现如下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"># create mychannel......</span><br><span class="line">E1215 12:26:25.877864366    9327 ssl_transport_security.cc:989] Handshake failed with fatal error SSL_ERROR_SSL: error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number.</span><br><span class="line">E1215 12:26:25.879670836    9327 ssl_transport_security.cc:989] Handshake failed with fatal error SSL_ERROR_SSL: error:1408F10B:SSL routines:SSL3_GET_RECORD:wrong version number.</span><br><span class="line">error: [Orderer.js]: sendBroadcast - on error: &quot;Error: 14 UNAVAILABLE: Connect Failed\n    at createStatusError (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:64:15)\n    at ClientDuplexStream._emitStatusIfDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:270:19)\n    at ClientDuplexStream._readsDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:236:8)\n    at readCallback (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:296:12)&quot;</span><br><span class="line">not ok 1 Failed to create channels Error: SERVICE_UNAVAILABLE at ClientDuplexStream.&lt;anonymous&gt; (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Orderer.js:136:21) at emitOne (events.js:116:13) at ClientDuplexStream.emit (events.js:211:7) at ClientDuplexStream._emitStatusIfDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:271:12) at ClientDuplexStream._readsDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:236:8) at readCallback (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:296:12)</span><br><span class="line">  ---</span><br><span class="line">    operator: fail</span><br><span class="line">    at: channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:159:19)</span><br><span class="line">    stack: |-</span><br><span class="line">      Error: Failed to create channels Error: SERVICE_UNAVAILABLE</span><br><span class="line">          at ClientDuplexStream.&lt;anonymous&gt; (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Orderer.js:136:21)</span><br><span class="line">          at emitOne (events.js:116:13)</span><br><span class="line">          at ClientDuplexStream.emit (events.js:211:7)</span><br><span class="line">          at ClientDuplexStream._emitStatusIfDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:271:12)</span><br><span class="line">          at ClientDuplexStream._readsDone (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:236:8)</span><br><span class="line">          at readCallback (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;grpc&#x2F;src&#x2F;client.js:296:12)</span><br><span class="line">          at Test.assert [as _assert] (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:224:54)</span><br><span class="line">          at Test.bound [as _assert] (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:76:32)</span><br><span class="line">          at Test.fail (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:317:10)</span><br><span class="line">          at Test.bound [as fail] (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:76:32)</span><br><span class="line">          at channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:159:19)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">  ...</span><br><span class="line">fabric.init() failed, Error: Fabric: Create channel failed</span><br><span class="line">    at channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:160:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">[Transaction Info] - Submitted: 0 Succ: 0 Fail:0 Unfinished:0</span><br><span class="line">unexpected error, Error: Fabric: Create channel failed</span><br><span class="line">    at channels.reduce.then.then.catch (&#x2F;home&#x2F;user1&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;create-channel.js:160:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br></pre></td></tr></table></figure><p>这个问题需要注意。</p><hr><h2 id="结果"><a href="#结果" class="headerlink" title="结果"></a>结果</h2><p>在 TLS 被开启或关闭两种情况下，能够发现关闭 TLS 后，系统的吞吐率略有提升，这是可想而知的，毕竟减少了一层传输层安全协议的封装。结果图如下：</p><ul><li><p><strong>Enable TLS</strong></p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/enable_tls.png?raw=true"></p></li><li><p><strong>Disable TLS</strong></p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/disable_tls.png?raw=true"></p></li></ul><p>不过以上的结果在实际中的意义并不大，因为在实际应用中肯定需要进行传输层安全协议的封装，不然这区块链的安全从和谈起。</p><p>如下图可以看到关闭 TLS 后，抓包后能够查看数据内容：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/disable-tls%20%E6%8A%93%E5%8C%85%E7%BB%93%E6%9E%9C.png?raw=true"></p><p>太不安全了！所以以上内容均只能应用于测试。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> Hyperledger caliper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Docker 容器启动时端口映射失败</title>
      <link href="2018/12/05/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5/"/>
      <url>2018/12/05/docker%E5%AE%B9%E5%99%A8%E5%90%AF%E5%8A%A8%E6%97%B6%E7%AB%AF%E5%8F%A3%E6%98%A0%E5%B0%84%E5%A4%B1%E8%B4%A5/</url>
      
        <content type="html"><![CDATA[<h4 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h4><p>在一台虚拟机上创建容器时因为端口映射的问题而导致容器启动失败，并提示 <code>docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated. </code></p><a id="more"></a><hr><h4 id="1-错误发现过程"><a href="#1-错误发现过程" class="headerlink" title="1. 错误发现过程"></a>1. 错误发现过程</h4><ul><li><p>通过 docker-compose 启动一个容器是提示无法启动容器，错误原因是 <code>Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</code> 。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f docker-compose-orderer.yaml up -d</span><br><span class="line">Creating orderer.example.com ... error</span><br><span class="line"></span><br><span class="line">ERROR: for orderer.example.com  Cannot start service orderer.example.com: b&#39;driver failed programming external connectivity on endpoint orderer.example.com (b1253c6e3542219f989fb9f6508c738066aeeb2fcdebd1e13b9b85c63c2715dd): Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</span><br><span class="line"></span><br><span class="line">ERROR: for orderer.example.com  Cannot start service orderer.example.com: b&#39;driver failed programming external connectivity on endpoint orderer.example.com (b1253c6e3542219f989fb9f6508c738066aeeb2fcdebd1e13b9b85c63c2715dd): Bind for 0.0.0.0:7050 failed: port is already allocated&#39;</span><br><span class="line">ERROR: Encountered errors while bringing up the project.</span><br></pre></td></tr></table></figure></li><li><p>接着直接使用 docker run 命令启动容器，还是提示一样的错误。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name orderer.example.com -d -p 7050:7050 hyperledger&#x2F;fabric-orderer:x86_64-1.1.0 </span><br><span class="line">07c97104c290f470588bf0cfe041f76771bfc8586b3ad0fe784a20f97c4e4a6f</span><br><span class="line">docker: Error response from daemon: driver failed programming external connectivity on endpoint orderer.example.com (ae62c5d74521cc7ea21dc4d4c762cf09390839a1a21d8dcfdcb3784ecdc5e568): Bind for 0.0.0.0:7050 failed: port is already allocated.</span><br></pre></td></tr></table></figure></li><li><p>查看主机的端口是否被占用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ netstat -ntlp</span><br><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br><span class="line">Active Internet connections (only servers)</span><br><span class="line">Proto Recv-Q Send-Q Local Address        Foreign Address     State       PID&#x2F;Program name</span><br><span class="line">tcp        0      0 0.0.0.0:22           0.0.0.0:*           LISTEN      -               </span><br><span class="line">tcp6       0      0 :::22                :::*                LISTEN      -               </span><br><span class="line">tcp6       0      0 :::2375              :::*                LISTEN      -</span><br></pre></td></tr></table></figure><p>发现并没有 7050 端口并没有在使用。</p></li><li><p>启动另一个容器，绑定主机的另一个端口：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker run -d -p 8050:7050 hyperledger&#x2F;fabric-orderer:x86_64-1.1.0 </span><br><span class="line">fba31d37ff4cc409740ce8cd045f4f4bc6a76f7c69c454a2d7e380327613acb0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker ps</span><br><span class="line">CONTAINER ID        IMAGE                                     COMMAND             CREATED              STATUS              PORTS                    NAMES</span><br><span class="line">fba31d37ff4c        hyperledger&#x2F;fabric-orderer:x86_64-1.1.0   &quot;orderer&quot;           8 seconds ago        Up 7 seconds        0.0.0.0:8050-&gt;7050&#x2F;tcp   confident_wescoff</span><br></pre></td></tr></table></figure><p>可以启动。</p></li><li><p>查看 docker 服务状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ systemctl status docker</span><br><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (&#x2F;lib&#x2F;systemd&#x2F;system&#x2F;docker.service; enabled; vendor preset: enabled)</span><br><span class="line">  Drop-In: &#x2F;etc&#x2F;systemd&#x2F;system&#x2F;docker.service.d</span><br><span class="line">           └─override.conf</span><br><span class="line">   Active: active (running) since Wed 2018-12-05 09:29:11 CST; 1h 14min ago</span><br><span class="line">     Docs: https:&#x2F;&#x2F;docs.docker.com</span><br><span class="line"> Main PID: 987 (dockerd)</span><br><span class="line">    Tasks: 35</span><br><span class="line">   Memory: 161.2M</span><br><span class="line">      CPU: 54.874s</span><br><span class="line">   CGroup: &#x2F;system.slice&#x2F;docker.service</span><br><span class="line">           ├─ 987 &#x2F;usr&#x2F;bin&#x2F;dockerd</span><br><span class="line">           └─1089 docker-containerd --config &#x2F;var&#x2F;run&#x2F;docker&#x2F;containerd&#x2F;containerd.toml</span><br></pre></td></tr></table></figure><p>服务显示是正常运行的。</p></li></ul><hr><h4 id="2-解决方法"><a href="#2-解决方法" class="headerlink" title="2.解决方法"></a>2.解决方法</h4><p>网上查看了一些方法，可以通过重启 docker 服务来解决：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><p>真的解决了。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ docker run --name orderer.example.com -d -p 7050:7050 hyperledger&#x2F;fabric-orderer:x86_64-1.1.0 </span><br><span class="line">2f289e5225344e4e07230a0985e9f51f2ef6584af263be28388bdb7f6c80af35</span><br><span class="line"></span><br><span class="line">$ docker ps </span><br><span class="line">CONTAINER ID        IMAGE                                     COMMAND             CREATED             STATUS              PORTS                    NAMES</span><br><span class="line">2f289e522534        hyperledger&#x2F;fabric-orderer:x86_64-1.1.0   &quot;orderer&quot;           7 seconds ago       Up 6 seconds        0.0.0.0:7050-&gt;7050&#x2F;tcp   orderer.example.com</span><br></pre></td></tr></table></figure><hr>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
            <tag> Bugs </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNP练习：确定主机字节序</title>
      <link href="2018/11/08/%E7%A1%AE%E5%AE%9A%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F/"/>
      <url>2018/11/08/%E7%A1%AE%E5%AE%9A%E4%B8%BB%E6%9C%BA%E5%AD%97%E8%8A%82%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h3 id="确定主机字节序的程序"><a href="#确定主机字节序的程序" class="headerlink" title="确定主机字节序的程序"></a>确定主机字节序的程序</h3><p>记录 UNP 学习第三章的确定主机字节序的程序，使用 C++ 语言编写。</p><p>程序如下：</p><a id="more"></a><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> CPU_VENDOR_OS <span class="meta-string">&quot;x86_64-unknown-linux-gnu&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="keyword">short</span> s;</span><br><span class="line">        <span class="keyword">char</span> c[<span class="keyword">sizeof</span>(<span class="keyword">short</span>)];</span><br><span class="line">    &#125; un; </span><br><span class="line">    </span><br><span class="line">    un.s = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; CPU_VENDOR_OS &lt;&lt; <span class="string">&quot;: &quot;</span>;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">sizeof</span>(<span class="keyword">short</span>) == <span class="number">2</span> )&#123;</span><br><span class="line">        <span class="keyword">if</span> ( un.c[<span class="number">0</span>] == <span class="number">1</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">2</span> ) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;big-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> ( un.c[<span class="number">0</span>] == <span class="number">2</span> &amp;&amp; un.c[<span class="number">1</span>] == <span class="number">1</span> ) </span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;little-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;unknown&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;sizeof(short) = &quot;</span> &lt;&lt; <span class="keyword">sizeof</span>(<span class="keyword">short</span>) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在我的 Ubuntu 16.04 虚拟机上运行上面的程序得到的结果是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">x86_64-unknown-linux-gnu: little-endian</span><br></pre></td></tr></table></figure><p>这说明我的虚拟机在内存中存储数据的字节序是 <strong>小端字节序</strong>。</p><blockquote><p>上面定义的 CPU_VENDOR_OS 宏的值是可在 UNP 随书的源码得到的 config.h 头文件中查看。</p></blockquote><hr><h3 id="大端模式与小端模式理解"><a href="#大端模式与小端模式理解" class="headerlink" title="大端模式与小端模式理解"></a>大端模式与小端模式理解</h3><p>考虑一个 16 位整数，它由 2 个字节组成。内存中存储这两个字节有两种方法：</p><ul><li>一种将低序字节存储在起始地址，这称为 <strong>小端字节序</strong>；</li><li>另一种将高序字节存储在起始地址，这称为 <strong>大端字节序</strong>。</li></ul><p>在上面的程序中，定义了一个联合体变量 un，包含一个短整形变量 s 和一个包含 2 个字符的字符数组 c。首先给 un.s 赋值 0x0102，这样在字符串数组 c 中存放的字符串对应的 ASCII 值为 0x0102 。高序字节为 0x01，低序字节为 0x02 。</p><p><strong>如果系统是小端模式：</strong></p><p>低序字节存储在起始地址，也就是 0x02 存放在数组的起始地址 un.c；高序字节存储在起始地址+1，即 0x01 存放在 un.c+1 中。即有一下等式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">un.c[0] &#x3D;&#x3D; 0x02</span><br><span class="line">un.c[1] &#x3D;&#x3D; 0x01</span><br></pre></td></tr></table></figure><p><strong>如果系统是大端模式：</strong></p><p>高序字节存储在起始地址，也就是 0x01 存放在数组的起始地址 un.c；低序字节存储在起始地址+1，即 0x02 存放在 un.c+1 中。有以下等式：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">un.c[0] &#x3D;&#x3D; 0x01</span><br><span class="line">un.c[1] &#x3D;&#x3D; 0x02</span><br></pre></td></tr></table></figure><blockquote><p>对于一个二进制或十六进制的值，如 0x01020304，位于左边的 0x01 字节是高序字节，位于右边 0x04 的是低序字节。</p></blockquote><hr><h3 id="或者用以下更简单的程序来确定："><a href="#或者用以下更简单的程序来确定：" class="headerlink" title="或者用以下更简单的程序来确定："></a>或者用以下更简单的程序来确定：</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">short</span> val = <span class="number">0x0102</span>;</span><br><span class="line">    <span class="keyword">char</span> *p = (<span class="keyword">char</span> *) &amp;val;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (*p == <span class="number">1</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">2</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;big-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (*p == <span class="number">2</span> &amp;&amp; *(p+<span class="number">1</span>) == <span class="number">1</span>)</span><br><span class="line">        <span class="built_in">cout</span> &lt;&lt; <span class="string">&quot;little-endian&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>将短整形变量 val 的地址强制转换成字符型指针的地址 p。p 是低地址，(p+1)是高地址。0x01是 val 的高有效字节，0x02是 val 的低有效字节。则有一下两种情况：</p><ul><li><code>*p == 0x01 &amp;&amp; *(p+1) == 0x02</code>：高有效字节存放在低地址，大端模式。</li><li><code>*p == 0x02 &amp;&amp; *(p+1) == 0x01</code>：低有效字节存放在低地址，小端模式。</li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> UNIX网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 大小端模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>socket编程之bind函数</title>
      <link href="2018/11/07/socket%E7%BC%96%E7%A8%8B%E4%B9%8Bbind%E5%87%BD%E6%95%B0/"/>
      <url>2018/11/07/socket%E7%BC%96%E7%A8%8B%E4%B9%8Bbind%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<p><strong>bind 函数：关联地址和套接字</strong></p><p>定义：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">bind</span><span class="params">(<span class="keyword">int</span> sockfd, <span class="keyword">const</span> struct sockaddr *addr, <span class="keyword">socklen_t</span> len)</span></span>;</span><br></pre></td></tr></table></figure><p>返回值：若成功，返回 0；若出错，返回 -1.</p><a id="more"></a><h3 id="使用-bind-时遇到的错误"><a href="#使用-bind-时遇到的错误" class="headerlink" title="使用 bind 时遇到的错误"></a>使用 bind 时遇到的错误</h3><p>在练习 UNP 代码 daytimetcpsrv.c 时遇到两个问题：</p><ol><li><p><strong>Permission denied</strong></p><p>这是因为地址中的端口号必须不小于 1024，除非该进程具有相应的特权（即 root 用户）。</p></li><li><p><strong>Address already in use</strong></p><p>这个问题有时会让人很疑问，明明已经结束了使用对应端口的进程，端口应该不是 <code>in use</code> 的啊，但却无法再次调用 bind 函数来绑定该端口到一个套接字端点（bind 函数返回 <code>EADDRINUSE</code>）。其实这是由 TCP 套接字状态 <code>TIME_WAIT</code> 引起的，该状态在套接字关闭后约保留 2 到 4 分钟，因此无法再次绑定刚刚使用的端口。在 <code>TIME_WAIT</code> 状态退出之后，套接字被删除，该地址才能被重新绑定而不出问题。</p><p>可以通过 netstat -ant 来查看这个端口还处于 <code>TIME_WAIT</code> 状态：</p><p>等待 <code>TIME_WAIT</code> 结束可能是令人恼火的一件事，特别是如果您正在开发一个套接字服务器，就需要停止服务器来做一些改动，然后重启。幸运的是，有方法可以避开 <code>TIME_WAIT</code> 状态。可以给套接字应用 <code>SO_REUSEADDR</code> 套接字选项，以便端口可以马上重用。</p><p>对于 daytimetcpsrv.c，可以加上以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> reuse = <span class="number">1</span>;</span><br><span class="line">listenfd = Socket(AF_INET, SOCK_STREAM, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (setsockopt(listenfd, SOL_SOCKET, SO_REUSEADDR, &amp;reuse, <span class="keyword">sizeof</span>(reuse)) &lt; <span class="number">0</span>)</span><br><span class="line"> &#123;</span><br><span class="line">  perror(<span class="string">&quot;setsockopet error\n&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure><p>重新编译运行。</p></li></ol><h3 id="关于-TIME-WAIT-状态"><a href="#关于-TIME-WAIT-状态" class="headerlink" title="关于 TIME_WAIT 状态"></a>关于 TIME_WAIT 状态</h3><p>TCP 设计中之所以要让一个旧的连接处于 TIME_WAIT 状态是因为要防止旧连接的老的重复分组出现在新连接中。拿 UNP 上面的例子来说：</p><p>假设在 12.106.32.245 的端口 1500 和 206.168.112.219 的端口 21 之间有一个 TCP 连接。当我们关闭这个连接后，很快又重新建立一条相同 IP 和端口的 TCP 连接。在这种情况下，假如旧连接在网络中还存在没有被丢弃的重复分组，而且重复分组又出现在了新连接中了，TCP 将无法正确处理这个分组。为了防止这种情况的发生，TCP 将刚关闭的连接置于 TIME_WAIT 状态，不允许给处于该状态的连接启动新的化身，持续时间是 2MSL，如此将能保证该连接的老的重复分组都已在网络中消逝。</p><blockquote><p>注：是主动执行关闭 TCP 连接的那端将处于 TIME_WAIT 状态。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> UNIX网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> bind </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>UNP练习：TCP时间获取程序</title>
      <link href="2018/11/07/TCP%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F/"/>
      <url>2018/11/07/TCP%E6%97%B6%E9%97%B4%E8%8E%B7%E5%8F%96%E7%A8%8B%E5%BA%8F/</url>
      
        <content type="html"><![CDATA[<h5 id="《UNIX-网络编程：卷1》学习记录1："><a href="#《UNIX-网络编程：卷1》学习记录1：" class="headerlink" title="《UNIX 网络编程：卷1》学习记录1："></a>《UNIX 网络编程：卷1》学习记录1：</h5><p>书本上有两个程序：</p><ul><li>1.2节：简单的 TCP 时间获取客户程序</li><li>1.5节：简单的 TCP 时间获取服务器程序</li></ul><p>本文记录的是我在学习过程编写的 C++ 版本的程序（但其实还是 C 程序，hahaha…），为了熟悉 UNIX 函数库，这里并没有基于书中的 &lt;unp.h&gt; 头文件来编写，而是全部自己添加 C 函数库中的头文件。程序如下：</p><a id="more"></a><h5 id="简单的-TCP-时间获取客户程序"><a href="#简单的-TCP-时间获取客户程序" class="headerlink" title="简单的 TCP 时间获取客户程序"></a>简单的 TCP 时间获取客户程序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;arpa/inet.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE     4096</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>         sockfd, n;</span><br><span class="line">    <span class="keyword">char</span>        recevline[MAXLINE + <span class="number">1</span>]; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">// sockaddr_in结构定义在&lt;netinet/in.h&gt;头文件中</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">3</span>)&#123; </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;IPaddress&gt; &lt;port&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    <span class="comment">//socket()在&lt;sys/socket.h&gt;</span></span><br><span class="line">    <span class="keyword">if</span> ( (sockfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> )&#123;      </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));     <span class="comment">//定义在&lt;string.h&gt;头文件中</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_port = htons(atoi(argv[<span class="number">2</span>]));       <span class="comment">//头文件&lt;arpa/inet.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//inet_pton()在头文件&lt;arpa/inet.h&gt;</span></span><br><span class="line">    <span class="keyword">if</span> ( inet_pton(AF_INET, argv[<span class="number">1</span>], &amp;servaddr.sin_addr) &lt;= <span class="number">0</span> )&#123;    </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;inet_pton error for &quot;</span> &lt;&lt; argv[<span class="number">1</span>] &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (connect(sockfd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;connect error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> ( (n = read(sockfd, recevline, MAXLINE)) &gt; <span class="number">0</span> )&#123;   <span class="comment">//头文件&lt;unisted.h&gt;</span></span><br><span class="line">        recevline[n] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span> ( <span class="built_in">fputs</span>(recevline, <span class="built_in">stdout</span>) == EOF )&#123;     <span class="comment">//头文件&lt;stdio.h&gt;</span></span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;fputs error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( n &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;read error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="简单的-TCP-时间获取服务器程序"><a href="#简单的-TCP-时间获取服务器程序" class="headerlink" title="简单的 TCP 时间获取服务器程序"></a>简单的 TCP 时间获取服务器程序</h5><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/socket.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;netinet/in.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdlib&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXLINE     4096</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> LISTENQ     1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span> **argv)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>                 listenfd, connfd;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sockaddr_in</span>  <span class="title">servaddr</span>;</span>   <span class="comment">// sockaddr_in结构定义在&lt;netinet/in.h&gt;头文件中</span></span><br><span class="line">    <span class="keyword">char</span>                buff[MAXLINE];</span><br><span class="line">    <span class="keyword">time_t</span>              ticks;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (argc != <span class="number">2</span>)&#123; </span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;usage: &quot;</span> &lt;&lt; argv[<span class="number">0</span>] &lt;&lt; <span class="string">&quot; &lt;listen_port&gt;&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"> </span><br><span class="line">    <span class="keyword">if</span> ( (listenfd = socket(AF_INET, SOCK_STREAM, <span class="number">0</span>)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;socket error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line"></span><br><span class="line">    bzero(&amp;servaddr, <span class="keyword">sizeof</span>(servaddr));<span class="comment">//定义在&lt;string.h&gt;头文件中</span></span><br><span class="line">    servaddr.sin_family = AF_INET;</span><br><span class="line">    servaddr.sin_addr.s_addr = htonl(INADDR_ANY);<span class="comment">//头文件&lt;arpa/inet.h&gt;</span></span><br><span class="line">    servaddr.sin_port = htons(atoi(argv[<span class="number">1</span>]));<span class="comment">//头文件&lt;arpa/inet.h&gt;</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">//bind()在头文件&lt;sys/socket.h&gt;中</span></span><br><span class="line">    <span class="keyword">if</span> ( bind(listenfd, (struct sockaddr *) &amp;servaddr, <span class="keyword">sizeof</span>(servaddr)) &lt; <span class="number">0</span> )&#123;</span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;bind error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (listen(listenfd, LISTENQ) &lt; <span class="number">0</span>)&#123;<span class="comment">//头文件&lt;sys/socket.h&gt;</span></span><br><span class="line">        <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;listen error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (;;)&#123;</span><br><span class="line">        <span class="keyword">if</span> ((connfd = accept(listenfd, (struct sockaddr *) <span class="literal">NULL</span>, <span class="literal">NULL</span>)) &lt; <span class="number">0</span>)&#123;</span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;accept error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        ticks = time(<span class="literal">NULL</span>);</span><br><span class="line">        <span class="built_in">snprintf</span>(buff, <span class="keyword">sizeof</span>(buff), <span class="string">&quot;%.24s\r\n&quot;</span>, ctime(&amp;ticks));<span class="comment">//c头文件&lt;stdio.h&gt; 或c++头文件&lt;cstdlib&gt;</span></span><br><span class="line">        <span class="keyword">if</span> ( write(connfd, buff, <span class="built_in">strlen</span>(buff)) &lt; <span class="number">0</span> )&#123;<span class="comment">//头文件&lt;unisted&gt;</span></span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;write error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (close(connfd) &lt; <span class="number">0</span>)&#123;<span class="comment">//头文件&lt;unisted&gt;</span></span><br><span class="line">            <span class="built_in">cerr</span> &lt;&lt; <span class="string">&quot;close error&quot;</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> UNIX网络编程 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> socket </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>基本排序算法实现</title>
      <link href="2018/10/25/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/"/>
      <url>2018/10/25/%E5%9F%BA%E6%9C%AC%E6%8E%92%E5%BA%8F%E7%AE%97%E6%B3%95%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<p>本文介绍一些常见的基本排序算法的实现，以及相应的时间空间负责度分析。包括冒泡排序、插入排序、选择排序、归并排序、快速排序、堆排序这六种比较排序算法，以及计数排序这种线性时间排序算法。算法基于 C++ 语言实现。</p><a id="more"></a><h3 id="1-冒泡排序"><a href="#1-冒泡排序" class="headerlink" title="1. 冒泡排序"></a>1. 冒泡排序</h3><p>学的第一个算法估计就是冒泡排序算法了。原理很简单，每次从左到右两两比较，把大的交换到后面，每次都会把当前未排序数组的最大元素放到最右边。</p><p><strong>步骤：</strong></p><ol><li>从左开始比较相邻的两个元素 nums[j] 和 nums[j+1]，如果 nums[j] &gt; nums[j+1] 就交换两者；</li><li>执行比较和交换，直到到达当前未排序数组的最后一个元素；</li><li>重复执行 1 和 2，直到当前未排序数组只有一个元素。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bubble_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;::size_type i, j;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-1</span>; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">0</span>; j+<span class="number">1</span> &lt; nums.size()-i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[j] &gt; nums[j+<span class="number">1</span>])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[j];</span><br><span class="line">                nums[j] = nums[j+<span class="number">1</span>];</span><br><span class="line">                nums[j+<span class="number">1</span>] = temp;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>由于我们需要执行 n 次冒泡，每次冒泡要执行 n 次比较（实际是 1 到 n 的等差数列，也就是 <code>(1+n)n/2</code> ），所以总的时间复杂度是 <code>O(n^2)</code> ；只需要常数个额外的元素空间存储临时数据，空间复杂度为 <code>O(1)</code>。</p><hr><h3 id="2-插入排序"><a href="#2-插入排序" class="headerlink" title="2. 插入排序"></a>2. 插入排序</h3><p>插入排序的原理是从左向右，把当前位置的数与它前面的数进行比较，找到最适合它的位置放入，使前面部分有序。</p><p><strong>步骤：</strong></p><ol><li>选出当前位置的数 nums[i]，从左向右，将 nums[i] 与它前面的每一个元素相比较，如果 nums[i] &lt; nums[j]，则将 nums[i] 与 nums[j] 交换；</li><li>再选择 nums[i+1] 与其前面的数进行比较。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">insert_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">1</span>; i &lt; nums.size(); i++)&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = <span class="number">0</span>; j &lt; i; j++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (nums[i] &lt; nums[j])&#123;</span><br><span class="line">                <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">                nums[i] = nums[j];</span><br><span class="line">                nums[j] = temp;</span><br><span class="line">            &#125;   </span><br><span class="line">        &#125;   </span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>总共要插入 n 次，每次插入的复杂度是 O(n)，所以总的时间复杂度为 O(n^2)，空间复杂度为 O(1)。</p><hr><h3 id="3-选择排序"><a href="#3-选择排序" class="headerlink" title="3. 选择排序"></a>3. 选择排序</h3><p>选择排序的原理是，每次都从乱序数组中找到最小值，放到当前乱序数组头部，最终使数组有序。</p><p><strong>步骤：</strong></p><ol><li>从左开始，选择后面元素中最小值，和当前元素交换；</li><li>直到未排序数组只有一个元素。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">select_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                             </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size()<span class="number">-1</span>; i++)&#123;                               </span><br><span class="line">        <span class="keyword">size_t</span> min_index = i;                                                 </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">size_t</span> j = i+<span class="number">1</span>; j &lt; nums.size(); j++)&#123;                           </span><br><span class="line">            <span class="keyword">if</span> (nums[j] &lt; nums[min_index])&#123;                                   </span><br><span class="line">                min_index = j;                                                </span><br><span class="line">            &#125;                                                                 </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">int</span> temp = nums[i];</span><br><span class="line">        nums[i] = nums[min_index];</span><br><span class="line">        nums[mid_index] = temp;                                       </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>需要选择 n 次最小值，且每次选择最小值的复杂度又是 O(n)，所以总共的时间复杂度为 O(n^2)；空间复杂度为 O(1)。</p><hr><h3 id="4-归并排序"><a href="#4-归并排序" class="headerlink" title="4. 归并排序"></a>4. 归并排序</h3><p>归并排序是采用分治法的一个典型例子。这个排序的特点是把一个数组打散成小数组，然后再把小数组拼凑再排序，直到最终数组有序。</p><p><strong>步骤：</strong></p><ol><li>把当前数组分化成 n 个单位为 1 的子数组，然后两两比较合并单位为 2 的 n/2 个子数组；</li><li>继续进行这个过程，按照 2 的倍数进行子数组的比较合并，直到最终数组有序；</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">merge_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                               </span><br><span class="line">    _merge_sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);                                      </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="keyword">void</span> _merge_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> end)&#123;          </span><br><span class="line">    <span class="keyword">if</span> (begin &lt; end)&#123;                                                         </span><br><span class="line">        <span class="keyword">int</span> mid = (begin + end)/<span class="number">2</span>;                                            </span><br><span class="line">        _merge_sort(nums, begin, mid);                                        </span><br><span class="line">        _merge_sort(nums, mid+<span class="number">1</span>, end);                                        </span><br><span class="line">        _merge(nums, begin, mid, end);                                        </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="keyword">void</span> _merge(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> begin, <span class="keyword">int</span> mid, <span class="keyword">int</span> end)&#123;      </span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; tmp; <span class="comment">/* 非空间原址排序 */</span>                                     </span><br><span class="line">    <span class="keyword">int</span> i = begin, j = mid+<span class="number">1</span>;                                                 </span><br><span class="line">    <span class="keyword">while</span> ( (i != mid+<span class="number">1</span>) &amp;&amp; (j != end+<span class="number">1</span>) )&#123;                                   </span><br><span class="line">        <span class="keyword">if</span> (nums[i] &lt;= nums[j])                                               </span><br><span class="line">            tmp.push_back(nums[i++]);                                         </span><br><span class="line">        <span class="keyword">else</span>                                                                  </span><br><span class="line">            tmp.push_back(nums[j++]);                                         </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">while</span> ( i != mid+<span class="number">1</span> )                                                      </span><br><span class="line">        tmp.push_back(nums[i++]);                                             </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">while</span> ( j != end+<span class="number">1</span> )                                                      </span><br><span class="line">        tmp.push_back(nums[j++]);                                             </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; tmp.size(); i++)                                   </span><br><span class="line">        nums[begin+i] = tmp[i];                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>采用分治法，可以将循环的次数减少为 logn，所以总共的时间复杂度为 O(nlogn)；</p><p>因为在合并数组时需要申请一个临时数组，所以算法的空间复杂度为 O(n)。</p><hr><h3 id="5-快速排序"><a href="#5-快速排序" class="headerlink" title="5. 快速排序"></a>5. 快速排序</h3><p>快速排序算法也是利用分治法实现的一个排序算法。快速排序与归并排序不同，它不是一半一半的分子数组，而是选择一个主元，把比这个数小的挪到左边，把比这个数大的移到右边。然后不断对左右两部分也执行相同的步骤，直到整个数组有序。</p><p><strong>步骤：</strong></p><ol><li>选择一个主元，一般选择最后一个元素（或者随机选取，保证平均性能）；</li><li>将小于主元的移到左边，大于主元的移到右边；</li><li>递归的对子数组重复执行1,2，直到整个数组有序。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quick_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                               </span><br><span class="line">    _quick_sort(nums, <span class="number">0</span>, nums.size()<span class="number">-1</span>);                                      </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="keyword">void</span> _quick_sort(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> p, <span class="keyword">int</span> r)&#123;                </span><br><span class="line">    <span class="keyword">if</span> (p &lt; r)&#123;                                                               </span><br><span class="line">        <span class="keyword">int</span> q = _partition(nums, p, r);                                       </span><br><span class="line">        _quick_sort(nums, p, q<span class="number">-1</span>);                                            </span><br><span class="line">        _quick_sort(nums, q+<span class="number">1</span>, r);                                            </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="keyword">int</span> _partition(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> p, <span class="keyword">int</span> r)&#123;                  </span><br><span class="line">    <span class="keyword">int</span> x = nums[r];                                                          </span><br><span class="line">    <span class="keyword">int</span> i = p<span class="number">-1</span>;                                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = p; j &lt; r; j++)&#123;                                              </span><br><span class="line">        <span class="keyword">if</span> (nums[j] &lt;= x)&#123;                                                    </span><br><span class="line">            i = i+<span class="number">1</span>;                                                          </span><br><span class="line">            swap(nums[i], nums[j]);                                           </span><br><span class="line">        &#125;                                                                     </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">    swap(nums[i+<span class="number">1</span>], nums[r]);                                                 </span><br><span class="line">    <span class="keyword">return</span> i+<span class="number">1</span>;                                                               </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>快速排序算法的平均时间复杂度为 O(nlogn)，但存在一些情况使得其时间复杂度为 O(n^2)，如数组是已排序的情况；</p><p>时间复杂度为 O(1)。</p><hr><h3 id="6-堆排序"><a href="#6-堆排序" class="headerlink" title="6. 堆排序"></a>6. 堆排序</h3><p>堆排序常用于求一个数组中最大 k 个元素。因为堆实际上是一个完全二叉树，所以用它可以用一维数组来表示。因为最大堆的第一位总为单签堆中的最大值，所以每次将最大值移除后，调整堆即可获得下一个最大值，通过一遍一遍执行这个过程就可以得到前 k 大元素，或者使堆有序。（最小堆的概念与最大堆对应）</p><p><strong>步骤：</strong></p><ol><li>构造最大堆：首先将当前元素放入最大堆下一个位置，然后将此元素依次和它的父节点比较，如果大于父节点就和父节点交换，直到比较到根节点。重复执行到最后一个元素。</li><li>调整最大堆：即将根节点移除后重新整理堆。整理方法为将根节点和最后一个节点交换，然后把堆看做n-1长度，将当前根节点逐步移动到其应该在的位置。</li><li>堆排序：重复执行2，直到所有根节点都已移除。</li></ol><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heap_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                                 </span><br><span class="line">    build_heap(nums);                                                         </span><br><span class="line">    <span class="keyword">int</span> heap_size = nums.size();                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size()<span class="number">-1</span>; i &gt; <span class="number">0</span>; i--)&#123;                                  </span><br><span class="line">        swap(nums[<span class="number">0</span>], nums[i]);                                               </span><br><span class="line">        heap_size--;                                                          </span><br><span class="line">        heapify(nums, <span class="number">0</span>, heap_size);                                          </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">build_heap</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums)</span></span>&#123;                                </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size()/<span class="number">2</span> - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)                              </span><br><span class="line">        heapify(nums, i, nums.size()<span class="number">-1</span>);                                      </span><br><span class="line">&#125;                                                                             </span><br><span class="line">                                                                              </span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">heapify</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="keyword">int</span> root, <span class="keyword">int</span> heap_size)</span></span>&#123;          </span><br><span class="line">    <span class="keyword">int</span> left = <span class="number">2</span>*root, right = <span class="number">2</span>*root+<span class="number">1</span>;                                      </span><br><span class="line">    <span class="keyword">int</span> max_index = root;                                                     </span><br><span class="line">    <span class="keyword">if</span> ( left &lt; heap_size &amp;&amp; nums[left] &gt; nums[root] )                        </span><br><span class="line">        max_index = left;                                                     </span><br><span class="line">    <span class="keyword">if</span> ( right &lt; heap_size &amp;&amp; nums[right] &gt; nums[max_index] )                 </span><br><span class="line">        max_index = right;                                                    </span><br><span class="line">    <span class="keyword">if</span> ( max_index != root )&#123;                                                 </span><br><span class="line">        swap(nums[max_index], nums[root]);                                    </span><br><span class="line">        heapify(nums, max_index, heap_size);                                  </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>堆执行一次调整需要 O(logn) 的时间，在排序过程中需要遍历所有元素执行堆调整，所以最终时间复杂度为 O(nlogn)；空间复杂度为 O(1)。</p><h3 id="7-计数排序"><a href="#7-计数排序" class="headerlink" title="7. 计数排序"></a>7. 计数排序</h3><p>计数排序假设 n 个输入元素中的每一个都是在 0 到 k 区间内的一个整数，其中 k 为某个整数。当 k = O(n) 时，排序的运行时间为 O(n)。</p><p>计数排序的基本思想是：对每一个输入元素 x，确定小于 x 的元素个数。利用这一信息，就可以直接把 x 放到它在输出数组中的位置上了。</p><p>在计数排序算法的代码中，假设输入是一个数组 nums[0..n-1]，nums.size() = n。我们还需要两个数组： ans[0..n-1] 存放排序的输出，C[0..k] 提供临时存储空间。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">count_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;nums, <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; &amp;ans, <span class="keyword">int</span> k)</span></span>&#123;                  </span><br><span class="line">    <span class="function"><span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; <span class="title">C</span><span class="params">(k+<span class="number">1</span>, <span class="number">0</span>)</span></span>;                                                    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">size_t</span> i = <span class="number">0</span>; i &lt; nums.size(); i++)                                  </span><br><span class="line">        C[nums[i]] = C[nums[i]] + <span class="number">1</span>;                                          </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= k; j++)                                              </span><br><span class="line">        C[j] += C[j<span class="number">-1</span>];                                                       </span><br><span class="line">                                                                              </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums.size()<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)&#123;                                 </span><br><span class="line">        ans[C[nums[i]]<span class="number">-1</span>] = nums[i];                                          </span><br><span class="line">        C[nums[i]] -= <span class="number">1</span>;                                                      </span><br><span class="line">    &#125;                                                                         </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>时间复杂度为 O(n)，空间复杂度也为 O(n)。</p><hr><h3 id="8-希尔排序"><a href="#8-希尔排序" class="headerlink" title="8. 希尔排序"></a>8. 希尔排序</h3><p>希尔排序是希尔（Donald Shell）于1959年提出的一种排序算法。希尔排序也是一种插入排序，它是简单插入排序经过改进之后的一个更高效的版本，也称为缩小增量排序，同时该算法是冲破 O(n^2) 的第一批算法之一。</p><p>直接插入排序算法的算法时间复杂度为 O(n^2) ，但是，若待排记录序列为 “正序” 时，其时间复杂度可提高至 O(n)。另外一方面，当 n 值较小时，直接插入排序算法的效率也比较高。希尔排序算法正是从这两点分析出发对直接插入排序算法进行改进的。</p><p><strong>它的基本思想：先将整个待排序序列分割成为若干子序列分别进行直接插入排序，待整个序列中的记录“基本有序”时，再对整体序列进行一次直接插入排序。</strong></p><p>简单插入排序很循规蹈矩，不管数组分布是怎么样的，依然一步一步的对元素进行比较，移动，插入，比如[5,4,3,2,1,0]这种倒序序列，数组末端的0要回到首位置很是费劲，比较和移动元素均需n-1次。而希尔排序在数组中采用跳跃式分组的策略，通过某个增量将数组元素划分为若干组，然后分组进行插入排序，随后逐步缩小增量，继续按组进行插入排序操作，直至增量为1。希尔排序通过这种策略使得整个数组在初始阶段达到从宏观上看基本有序，小的基本在前，大的基本在后。然后缩小增量，到增量为1时，其实多数情况下只需微调即可，不会涉及过多的数据移动。</p><p><strong>基本步骤：</strong></p><p>在此我们选择增量gap=length/2，缩小增量继续以gap = gap/2的方式，这种增量选择我们可以用一个序列来表示，{n/2,(n/2)/2…1}，称为<strong>增量序列</strong>。希尔排序的增量序列的选择与证明是个数学难题，我们选择的这个增量序列是比较常用的，也是希尔建议的增量，称为希尔增量，但其实这个增量序列不是最优的。此处我们做示例使用希尔增量。</p><p><img src="https://images2015.cnblogs.com/blog/1024555/201611/1024555-20161128110416068-1421707828.png"></p><blockquote><p>以上希尔排序部分的内容摘自 <a href="https://www.cnblogs.com/chengxiao/p/6104371.html">图解排序算法（二）之希尔排序</a></p></blockquote><p><strong>代码实现：</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 针对有序序列在插入时采用交换法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = nums.size()/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)&#123;   </span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; nums.size(); i++)&#123;  </span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">while</span> (j-gap &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j-gap])&#123;</span><br><span class="line">                swap(nums[j], nums[j-gap]);   <span class="comment">//插入排序采用交换法</span></span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125; </span><br><span class="line">        &#125; </span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 针对有序序列在插入时采用移动法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">shell_sort</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&amp; nums)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> gap = nums.size()/<span class="number">2</span>;</span><br><span class="line">    <span class="comment">//增量gap，并逐步缩小增量</span></span><br><span class="line">    <span class="keyword">while</span> (gap &gt; <span class="number">0</span>)&#123;</span><br><span class="line">        <span class="comment">//从第gap个元素，逐个对其所在组进行直接插入排序操作</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = gap; i &lt; nums.size(); i++)&#123;</span><br><span class="line">            <span class="keyword">int</span> j = i;</span><br><span class="line">            <span class="keyword">int</span> tmp = nums[j];   <span class="comment">//记录nums[j]的值</span></span><br><span class="line">            <span class="keyword">while</span> (j-gap &gt;= <span class="number">0</span> &amp;&amp; nums[j] &lt; nums[j-gap])&#123;</span><br><span class="line">                nums[j] = nums[j-gap];   <span class="comment">//把前一个值直接往后移</span></span><br><span class="line">                j -= gap;</span><br><span class="line">            &#125;</span><br><span class="line">            nums[j] = tmp;   <span class="comment">//将记录的值放到该放的位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        gap /= <span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析：</strong></p><p>希尔排序中对于增量序列的选择十分重要，直接影响到希尔排序的性能。我们上面选择的增量序列{n/2, (n/2)/2 , …,1}(希尔增量)，其最坏时间复杂度依然为O(n^2^)，一些经过优化的增量序列如Hibbard经过复杂证明可使得最坏时间复杂度为O(n^3/2^)。</p><hr>]]></content>
      
      
      <categories>
          
          <category> algorithm </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 排序算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>leetcode-141-142</title>
      <link href="2018/10/21/leetcode-141-142/"/>
      <url>2018/10/21/leetcode-141-142/</url>
      
        <content type="html"><![CDATA[<h3 id="141-Linked-List-Cycle"><a href="#141-Linked-List-Cycle" class="headerlink" title="141. Linked List Cycle"></a>141. <a href="https://leetcode.com/problems/linked-list-cycle/description/">Linked List Cycle</a></h3><p>Given a linked list, determine if it has a cycle in it.</p><p>Follow up:<br>Can you solve it without using extra space?</p><a id="more"></a><hr><h4 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h4><p>给定一个链表，判断链表中是否有环。不要有额外的空间消耗。</p><hr><h4 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h4><p><strong>双指针法：</strong></p><p>最常用的方法，快慢指针，慢指针每次移动一步，快指针一次移动两步。如果链表中没有环，那么快指针将先到达链表结尾，并且指向 NULL；如果链表中有环，则快指针会在环中循环，直到慢指针进入环中，快指针将会追上慢指针，两者相等。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(fast-&gt;next != <span class="literal">NULL</span> &amp;&amp; fast-&gt;next-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> (slow == fast)</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度分析</strong></p><ul><li>时间复杂度：O(N)。如果链表中无环，则在快指针到达链表结尾时经过 N/2 步左右，所以复杂度为 O(N)；如果链表中有环，则最坏情况下，当慢指针几乎绕环一圈时快指针才追上它，所以是 N 步左右，所以复杂度为 O(N)。综上，时间复杂度为 O(N)。</li><li>空间复杂度：O(1)。只使用了两个指针。</li></ul><hr><h3 id="142-Linked-List-Cycle-II"><a href="#142-Linked-List-Cycle-II" class="headerlink" title="142. Linked List Cycle II"></a>142. <a href="https://leetcode.com/problems/linked-list-cycle-ii/description/">Linked List Cycle II</a></h3><p>Given a linked list, return the node where the cycle begins. If there is no cycle, return <code>null</code>.</p><p><strong>Note:</strong> Do not modify the linked list.</p><p><strong>Follow up</strong>:<br>Can you solve it without using extra space?</p><hr><h4 id="题意理解-1"><a href="#题意理解-1" class="headerlink" title="题意理解"></a>题意理解</h4><p>给定一个链表，如果链表中有环，返回环开始的节点；如果没有环，则返回 null。并且不能修改这个链表。</p><hr><h4 id="解法思路-1"><a href="#解法思路-1" class="headerlink" title="解法思路"></a>解法思路</h4><p>和上面那题一样，都是使用<strong>双指针法</strong>，但是要输出环开始的节点需要一些其他的计算。</p><p>假设经过 <strong>k</strong> 步，快慢指针相遇；假设<strong>环的长度</strong>是 <strong>r</strong>；所以有：<code>2k - k = nr</code>，即 <code>k = nr</code> （其中n表示快指针在环中循环的次数）。</p><p>假设<strong>链表表头</strong>到<strong>环的起点</strong>的距离为 s；假设<strong>环的起点</strong>到<strong>快慢指针相遇的节点</strong>的距离为 m；所以有：<code>s = k - m</code>。</p><p><code>s = nr - m = (n - 1) + (r - m)，n = 1,2,3,... </code></p><p>所以，可以再使用两个指针，慢指针从链表表头开始，每次移动一步；快指针从<strong>快慢指针相遇的节点</strong>开始，每次也移动一步，那么经过 s 步之后，快慢指针将会在<strong>环的起点</strong>相遇。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">NULL</span> || head-&gt;next == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode* slow = head;</span><br><span class="line">        ListNode* fast = head;</span><br><span class="line">        <span class="keyword">while</span> (fast != <span class="literal">NULL</span> &amp;&amp;fast-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            </span><br><span class="line">            <span class="keyword">if</span> (slow == fast)&#123;</span><br><span class="line">                slow = head;</span><br><span class="line">                fast = fast;</span><br><span class="line">                <span class="keyword">while</span> (slow != fast)&#123;</span><br><span class="line">                    slow = slow-&gt;next;</span><br><span class="line">                    fast = fast-&gt;next;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">return</span> slow;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度和上一题一样，都为 O(N).</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVM 从虚拟机磁盘镜像创建虚拟机</title>
      <link href="2018/10/19/%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/"/>
      <url>2018/10/19/%E4%BB%8E%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E9%95%9C%E5%83%8F%E5%88%9B%E5%BB%BA%E8%99%9A%E6%8B%9F%E6%9C%BA/</url>
      
        <content type="html"><![CDATA[<h2 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h2><p>作为教研室的网管，干了很多运维的工作，而一个高效的运维是必须少做重复性工作。教研室的网管做的最多的事就是在很多服务器上给很多同学分配很多虚拟机，由于同学们没法直接操作服务器，所以有时系统也是需要网管帮忙安装的，而安装系统的过程费时费力且没啥技术含量。所以最好的办法给各种系统保存一份模板镜像，如果同学需要一个虚拟机就给他复制一份，然后从镜像启动虚拟机，无需重复系统安装的过程，一人一个文件夹，方便管理。本文就将介绍如何在 KVM 环境下从磁盘镜像创建虚拟机。</p><a id="more"></a><hr><h2 id="实现过程"><a href="#实现过程" class="headerlink" title="实现过程"></a>实现过程</h2><p>这里假设保存的磁盘镜像格式为 qcow2 格式的，操作系统为 Linux ，并且后面的操作的磁盘名称为：ubuntu.qcow2。</p><h4 id="命令行实现："><a href="#命令行实现：" class="headerlink" title="命令行实现："></a>命令行实现：</h4><p>在命令行下，使用 virt-install 命令来安装虚拟机，这命令有很多选项，这里不详细介绍，可以通过 <code>man virt-install</code> 仔细查看。我们通常安装虚拟机都是通过系统 ISO 文件来安装系统，使用的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm --name ubuntu --ram 4096 --vcpus&#x3D;4 \</span><br><span class="line">    --cdrom&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu-16.04.4-desktop-amd64.iso \</span><br><span class="line">    --disk path&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,format&#x3D;qcow2 \</span><br><span class="line">    --network network&#x3D;br0,model&#x3D;virtio \</span><br><span class="line">    --graphics vnc,listen&#x3D;0.0.0.0, --noautoconsole \</span><br><span class="line">    --os-type&#x3D;linux</span><br></pre></td></tr></table></figure><p>但是以上方法每次都是重新安装系统，太麻烦。</p><p><strong>下面介绍从虚拟机磁盘文件创建虚拟机的命令</strong>，但是这和 virt-instal 工具的版本有关系（可能和KVM的版本也有关系），不同版本的选项略微有差别，使用如下命令查看版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ virt-install --version</span><br><span class="line">1.3.2  或  0.600.4 （我只接触过这两个版本）</span><br><span class="line"></span><br><span class="line">$ kvm -version</span><br><span class="line">QEMU emulator version 2.5.0 (Debian 1:2.5+dfsg-5ubuntu10.30), Copyright (c) 2003-2008 Fabrice Bellard</span><br><span class="line">或</span><br><span class="line"># kvm -version</span><br><span class="line">QEMU emulator version 2.0.0 (Debian 2.0.0+dfsg-2ubuntu1.33), Copyright (c) 2003-2008 Fabrice Bellard</span><br></pre></td></tr></table></figure><p><strong>一种兼容前后版本的命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm --name ubuntu --ram 4096 --vcpus&#x3D;4 \</span><br><span class="line">--import \</span><br><span class="line">--disk path&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,format&#x3D;qcow2 \</span><br><span class="line">--network bridge&#x3D;br0,model&#x3D;virtio \</span><br><span class="line">--graphics vnc,listen&#x3D;0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type&#x3D;linux</span><br></pre></td></tr></table></figure><p><strong>只适用于新版本的命令如下：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">virt-install --virt-type kvm --name docker-$1 --ram 4096 --vcpus&#x3D;4 \</span><br><span class="line">--cdrom&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2 \</span><br><span class="line">--disk path&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,format&#x3D;qcow2 \</span><br><span class="line">--network bridge&#x3D;br0,model&#x3D;virtio \</span><br><span class="line">--graphics vnc,listen&#x3D;0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type&#x3D;linux</span><br></pre></td></tr></table></figure><p>主要的区别就在于 –import 选项是兼容的，而使用 –cdrom 只适用于新版本。</p><hr><h4 id="图形界面实现："><a href="#图形界面实现：" class="headerlink" title="图形界面实现："></a>图形界面实现：</h4><p>对于图形界面就是通过 virt-manager 来实现，但是这种方法貌似只适用于较新版本KVM环境，步骤如下：</p><ol><li><p>打开 virtual machine mananger，-&gt; 点击右上角新建虚拟机</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%201.png?raw=true"></p></li><li><p>选择 Import existing disk image，-&gt; Forward</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%202.png?raw=true"></p></li><li><p>点击 Browse</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%203.png?raw=true"></p></li><li><p>点击 Browse Local，找到虚拟机磁盘镜像文件，-&gt;Choose Volume</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%204.png?raw=true"></p></li><li><p>点击 Forward</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%205.png?raw=true"></p></li><li><p>配置合适的内存和 CPU 个数，-&gt; Forward</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%206.png?raw=true"></p></li><li><p>给虚拟机命名（但注意这不是虚拟机里面的 hostname），-&gt; Finish</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/blog/kvm/virt-manager%207.png?raw=true"></p></li><li><p>最后就会进入虚拟机的系统启动过程</p></li></ol><hr><h2 id="遇到的问题"><a href="#遇到的问题" class="headerlink" title="遇到的问题"></a>遇到的问题</h2><p>由于教研室有一些服务器的使用年限较长，有一些服务器的系统和软件版本较低，在使用 KVM 时碰到一些很烦人的问题，所以才写下这篇博客记录一下。如果在旧版本的环境下使用新环境才支持的命令选项，就可能会出现一些问题，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ virt-install --virt-type kvm --name docker-$1 --ram 4096 --vcpus&#x3D;4 \</span><br><span class="line">--cdrom&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2 \</span><br><span class="line">--disk path&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,format&#x3D;qcow2 \</span><br><span class="line">--network bridge&#x3D;br0,model&#x3D;virtio \</span><br><span class="line">--graphics vnc,listen&#x3D;0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type&#x3D;linux</span><br><span class="line"></span><br><span class="line">Starting install...</span><br><span class="line">ERROR    internal error: process exited while connecting to monitor: qemu-system-x86_64: -drive file&#x3D;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2,if&#x3D;none,id&#x3D;drive-ide0-0-0,format&#x3D;qcow2: could not open disk image &#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2: Could not open &#39;&#x2F;home&#x2F;kb310&#x2F;test&#x2F;ubuntu.qcow2&#39;: Permission denied</span><br><span class="line"></span><br><span class="line">Domain installation does not appear to have been successful.</span><br><span class="line">If it was, you can restart your domain by running:</span><br><span class="line">  virsh --connect qemu:&#x2F;&#x2F;&#x2F;system start hgh</span><br><span class="line">otherwise, please restart your installation.</span><br></pre></td></tr></table></figure><p>上面出现的错误就是由于软件版本的不同导致的，所以最好使用兼容的命令选项。</p><hr>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> virt-install </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>110. Balanced Binary Tree</title>
      <link href="2018/10/18/leetcode-110/"/>
      <url>2018/10/18/leetcode-110/</url>
      
        <content type="html"><![CDATA[<h3 id="110-Balanced-Binary-Tree"><a href="#110-Balanced-Binary-Tree" class="headerlink" title="110. Balanced Binary Tree"></a>110. <a href="https://leetcode.com/problems/balanced-binary-tree/description/">Balanced Binary Tree</a></h3><p>Given a binary tree, determine if it is height-balanced.</p><p>For this problem, a height-balanced binary tree is defined as:</p><blockquote><p>a binary tree in which the depth of the two subtrees of <em>every</em> node never differ by more than 1.</p></blockquote><a id="more"></a><p><strong>Example 1:</strong></p><p>Given the following tree <code>[3,9,20,null,null,15,7]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>Return true.<br><strong>Example 2:</strong></p><p>Given the following tree <code>[1,2,2,3,3,null,null,4,4]</code>:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">      1</span><br><span class="line">     &#x2F; \</span><br><span class="line">    2   2</span><br><span class="line">   &#x2F; \</span><br><span class="line">  3   3</span><br><span class="line"> &#x2F; \</span><br><span class="line">4   4</span><br></pre></td></tr></table></figure><p>Return false.</p><hr><h3 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h3><hr><p>给定一个二叉树（是任意二叉树，而不是二叉搜索树），判断其是否是高度平衡的。高度平衡二叉树的定义就是：</p><blockquote><p>对于二叉树的每一个节点，其左右子树的高度相差最大不超过 1 。</p></blockquote><p>根据上面的定义，简单地认为只需要根节点的左右子树的高度相差不超过 1 是错误的，必须保证每一个节点都满足该条件。</p><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h3><hr><p><strong>初始思路：</strong></p><p>按照高度平衡二叉树的定义，可以想到通过遍历每一个节点，然后求每个节点的左右子树的高度，最后比较左右子树的高度差是否大于 1，当高度差大于时则返回 false，否则返回 true。实现如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">getHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span> + max(getHeight(root-&gt;left), getHeight(root-&gt;right));</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = getHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">int</span> right = getHeight(root-&gt;right);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; isBalanced(root-&gt;left) &amp;&amp; isBalanced(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析：求个节点的高度调用 getHeight() 花费的时间复杂度是 O(N)，遍历所有节点又需要 O(N)，因此总的时间复杂度是 O(N^2)。</p></blockquote><p><strong>改进思路：</strong></p><p>对于上面的方法，是从根往下，在求每一个节点的高度时都会遍历其子节点，这些操作有很多时重复的。如果可以每个节点的高度都保存下来就好了。对于这个题目，节点的值是没有用的，因此可以用节点的值来存放其高度，这样就没有额外的空间消耗。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">storeHeight</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        storeHeight(root-&gt;left);</span><br><span class="line">        storeHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span> &amp;&amp; root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;val = <span class="number">1</span> + max(root-&gt;left-&gt;val, root-&gt;right-&gt;val);</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;val = <span class="number">1</span> + root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">            root-&gt;val =<span class="number">1</span>+root-&gt;right-&gt;val;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            root-&gt;val = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">helper</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">int</span> left = root-&gt;left == <span class="literal">NULL</span>? <span class="number">0</span> : root-&gt;left-&gt;val;</span><br><span class="line">        <span class="keyword">int</span> right = root-&gt;right == <span class="literal">NULL</span>? <span class="number">0</span> : root-&gt;right-&gt;val;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">abs</span>(left - right) &lt;= <span class="number">1</span> &amp;&amp; helper(root-&gt;left) &amp;&amp; helper(root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        storeHeight(root);</span><br><span class="line">        <span class="keyword">return</span> helper(root);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析：算法首先求出二叉树各节点的高度，时间复杂度为 O(N)；然后再递归的计算每个节点左右子树的高度差是否小于等于 1，时间复杂度也为 O(N)。所以总的时间复杂度为 O(N) + O(N) = O(N)。</p></blockquote><p><strong>最终解法：</strong></p><p>在递归的计算二叉树中每个节点的高度时，如果两个子树的高度相差小于等于 1，则记录该节点真实的高度值，否则记录为 -1；并且在递归求某节点的高度时判断其左右孩子的高度值是否记录的是 -1，如果是，说明其左右子树中有非平衡树，则将该节点的高度值记为 -1。最后判断根节点的高度值是否为 -1，若为 -1，说明该二叉树不是高度平衡的；若不为 -1，说明该二叉树是高度平衡的。</p><p>代码如下：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="keyword">int</span> <span class="title">dfsHeight</span><span class="params">(TreeNode* root)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)   <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> left = dfsHeight(root-&gt;left);</span><br><span class="line">        <span class="keyword">if</span> (left == <span class="number">-1</span>) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">int</span> right = dfsHeight(root-&gt;right);</span><br><span class="line">        <span class="keyword">if</span> (right == <span class="number">-1</span>)    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">abs</span>(left - right) &gt; <span class="number">1</span>)  <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span> + max(left, right);</span><br><span class="line">        </span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">bool</span> <span class="title">isBalanced</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (dfsHeight(root) == <span class="number">-1</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>复杂度分析：只需要遍历一遍所有节点即可，时间复杂度为 O(N)。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>107. Binary Tree Level Order Traversal II</title>
      <link href="2018/10/17/leetcode-107/"/>
      <url>2018/10/17/leetcode-107/</url>
      
        <content type="html"><![CDATA[<h3 id="107-Binary-Tree-Level-Order-Traversal-II"><a href="#107-Binary-Tree-Level-Order-Traversal-II" class="headerlink" title="107. Binary Tree Level Order Traversal II"></a>107. <a href="https://leetcode.com/problems/binary-tree-level-order-traversal-ii/description/">Binary Tree Level Order Traversal II</a></h3><p>Given a binary tree, return the <em>bottom-up level order</em> traversal of its nodes’ values. (ie, from left to right, level by level from leaf to root).</p><p>For example:<br>Given binary tree <code>[3,9,20,null,null,15,7]</code>,</p><a id="more"></a><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">  3</span><br><span class="line"> &#x2F; \</span><br><span class="line">9  20</span><br><span class="line">  &#x2F;  \</span><br><span class="line"> 15   7</span><br></pre></td></tr></table></figure><p>return its bottom-up level order traversal as:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  [15,7],</span><br><span class="line">  [9,20],</span><br><span class="line">  [3]</span><br><span class="line">]</span><br></pre></td></tr></table></figure><hr><h3 id="题意理解"><a href="#题意理解" class="headerlink" title="题意理解"></a>题意理解</h3><p>给定一个二叉树，要求自底向上，自左向右的按层输出二叉树各节点的值。输出保存在一个二维数组中，也就是一个数组的数组，外层数组的元素是二叉树每一层节点的值的集合。</p><hr><h3 id="解法思路"><a href="#解法思路" class="headerlink" title="解法思路"></a>解法思路</h3><h5 id="解法一：DFS（Depth-First-Search）"><a href="#解法一：DFS（Depth-First-Search）" class="headerlink" title="解法一：DFS（Depth-First-Search）"></a>解法一：DFS（Depth-First-Search）</h5><p>可以知道的是，输出的二维数组中用一个数组来保存二叉树中的每一层的节点的值，且该内层数组在外层数组中的下标索引刚好与这些节点在树中的高度相反。所以可以利用 DFS 来遍历二叉树，根据节点在树中的高度，找到数组中保存该层元素的内层数组，将节点的值插入，最后只需将整个数组反转即可。对于二叉树的深度优先搜索，可以考虑用递归或者栈来实现。</p><p><strong>DFS with recursive：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        levelRecursive(res, root, <span class="number">0</span>);</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">void</span> <span class="title">levelRecursive</span><span class="params">(<span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; &amp;res, TreeNode* root, <span class="keyword">int</span> level)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        <span class="keyword">if</span> (res.size() &lt; level+<span class="number">1</span>)&#123;  <span class="comment">//判断是否已经有内层数组来存放该层节点的值</span></span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">            res.push_back(vec);</span><br><span class="line">        &#125;</span><br><span class="line">        res[level].push_back(root-&gt;val);</span><br><span class="line">        levelRecursive(res, root-&gt;left, level+<span class="number">1</span>);</span><br><span class="line">        levelRecursive(res, root-&gt;right, level+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>DFS with stack：</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">pair</span>&lt;TreeNode*, <span class="keyword">int</span>&gt;&gt; <span class="built_in">stack</span>;  <span class="comment">//用一个pair来存放节点和节点在书中的深度</span></span><br><span class="line">        <span class="built_in">stack</span>.push_back(&#123;root, <span class="number">0</span>&#125;);</span><br><span class="line">        <span class="keyword">while</span> (!<span class="built_in">stack</span>.empty())&#123;</span><br><span class="line">            <span class="built_in">pair</span>&lt;TreeNode*, <span class="keyword">int</span>&gt; p = <span class="built_in">stack</span>.back();</span><br><span class="line">            <span class="built_in">stack</span>.pop_back();</span><br><span class="line">            <span class="keyword">if</span> (res.size() &lt; p.second + <span class="number">1</span>)&#123;</span><br><span class="line">                <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; vec;</span><br><span class="line">                res.push_back(vec);</span><br><span class="line">            &#125;</span><br><span class="line">            res[p.second].push_back(p.first-&gt;val);</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push_back(&#123;p.first-&gt;right, p.second+<span class="number">1</span>&#125;);</span><br><span class="line">            <span class="keyword">if</span> (p.first-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                <span class="built_in">stack</span>.push_back(&#123;p.first-&gt;left, p.second+<span class="number">1</span>&#125;);</span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><h5 id="解法二：BFS（Breadth-First-Search）"><a href="#解法二：BFS（Breadth-First-Search）" class="headerlink" title="解法二：BFS（Breadth-First-Search）"></a>解法二：BFS（Breadth-First-Search）</h5><p>使用队列来存放每一层的节点，在 while 循环中又有一个 for 循环来遍历每一层的元素。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Solution</span> &#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; levelOrderBottom(TreeNode* root) &#123;</span><br><span class="line">        <span class="built_in">vector</span>&lt;<span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">queue</span>&lt;TreeNode* &gt; q;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        q.push(root);</span><br><span class="line">        <span class="keyword">while</span> (!q.empty())&#123;</span><br><span class="line">            <span class="built_in">vector</span>&lt;<span class="keyword">int</span>&gt; level;</span><br><span class="line">            <span class="keyword">int</span> len = q.size();</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; ++i)&#123;</span><br><span class="line">                level.push_back(q.front()-&gt;val);</span><br><span class="line">                TreeNode* p = q.front();</span><br><span class="line">                q.pop();</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;left != <span class="literal">NULL</span>)</span><br><span class="line">                    q.push(p-&gt;left);</span><br><span class="line">                <span class="keyword">if</span> (p-&gt;right != <span class="literal">NULL</span>)</span><br><span class="line">                    q.push(p-&gt;right);</span><br><span class="line">            &#125;</span><br><span class="line">            res.push_back(level);</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        reverse(res.begin(), res.end());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p><strong>复杂度：</strong>以上解法的时间复杂度及空间复杂度都为 O(N)。</p><hr>]]></content>
      
      
      <categories>
          
          <category> LeetCode </category>
          
      </categories>
      
      
        <tags>
            
            <tag> LeetCode </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程访问 Docker Daemon</title>
      <link href="2018/10/13/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEDocker/"/>
      <url>2018/10/13/%E8%BF%9C%E7%A8%8B%E8%AE%BF%E9%97%AEDocker/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>最近的项目中涉及到监控远程主机上的 Docker 容器的运行状况，即通过本地 docker 客户端访问远程主机的 docker 服务端，以此来监控远程主机上的 Docker 容器。但是 Docker Daemon 默认情况下是只允许本地访问的，不允许远程访问。本文将首先介绍 Docker Daemon 的连接方式，然后说明如何配置远程访问。</p><a id="more"></a><hr><h2 id="Docker-Daemon-的连接方式"><a href="#Docker-Daemon-的连接方式" class="headerlink" title="Docker Daemon 的连接方式"></a>Docker Daemon 的连接方式</h2><ol><li><p><strong>UNIX 域套接字</strong></p><p>默认就是这种方式, 会生成一个 <code>/var/run/docker.sock</code> 文件, <code>UNIX</code> 域套接字用于本地进程之间的通讯, 这种方式相比于网络套接字效率更高, 但局限性就是只能被本地的客户端访问。 </p></li><li><p><strong>tcp 端口监听</strong></p><p>服务端开启端口监听 <code>dockerd -H IP:PORT</code> , 客户端通过指定IP和端口访问服务端 <code>docker -H IP:PORT</code> 。通过这种方式, 任何人只要知道了你暴露的ip和端口就能随意访问你的docker服务了, 这是一件很危险的事, 因为docker的权限很高, 不法分子可以从这突破取得服务端宿主机的最高权限。 </p></li></ol><hr><h2 id="配置-Docker-远程访问"><a href="#配置-Docker-远程访问" class="headerlink" title="配置 Docker 远程访问"></a>配置 Docker 远程访问</h2><p>看到一些资料上面说可以通过修改 <code>/etc/default/docker</code> 文件来修改 Docker Daemon 的配置，也就是编辑docker的配置文件 <code>/etc/default/docker</code> 中的 <code>DOCKER_OPTS</code> 选项成同时监听本地 unix socket 和远程 http socket（2375）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">DOCKER_OPTS&#x3D;&quot;-H unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock -H tcp:&#x2F;&#x2F;0.0.0.0:2375&quot;</span><br></pre></td></tr></table></figure><p>但是通过这种方法修改完成重新启动 docker 守护进程之后，Docker Daemon 并没有在监听 2375 端口。然后发现其实在 <code>/etc/default/docker</code> 文件也有说到：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># THIS FILE DOES NOT APPLY TO SYSTEMD</span><br><span class="line">#</span><br><span class="line">#   Please see the documentation for &quot;systemd drop-ins&quot;:</span><br><span class="line">#   https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;admin&#x2F;systemd&#x2F;</span><br></pre></td></tr></table></figure><p>因为 Ubuntu 16.04 使用 systemd 来管理 docker 进程，<code>/etc/default/docker</code> 文件已经不再起作用了，该文件只对更老的系统起作用。正确的配置方式如下：</p><hr><p>主要参考该链接：<a href="https://wiki.ssdt-ohio.org/display/rtd/Install+Docker+and+Docker+tools+on+Ubuntu#InstallDockerandDockertoolsonUbuntu-Changestodefaultoptions">Adjustments to docker setting</a></p><h4 id="1-Changes-to-default-options"><a href="#1-Changes-to-default-options" class="headerlink" title="1. Changes to default options"></a>1. Changes to default options</h4><p>安装好 Docker 后可能有一些选项需要修改，就像我们这里想要配置 Docker Daemon 允许远程访问一样。有两种方法：</p><ul><li>修改 <code>/etc/default/docker </code> 和 <code>/lib/systemd/system/docker.service</code> 文件，但是这种方法对不同版本的 Docker 有不同的配置方法，不推荐。</li><li>创建 <code>/etc/docker/daemon.json</code> 来作为配置文件，Docker 推荐使用这种方法，这也是我们接下来介绍的。</li></ul><blockquote><p>注：这里使用的是 Ubuntu 16.04 LTS 系统，使用了 systemd 来管理 docker 进程。而更老版本的 Ubuntu 系统没有使用 systemd，所以只需要修改 <code>/etc/default/docker</code> 文件就够了。</p></blockquote><p>开始之前，先关闭 docker 进程：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo service docker stop</span><br></pre></td></tr></table></figure><blockquote><p>注意：在上面的原文链接的方法中，还会修改 docker 的默认目录，也就是将 <code>/var/lib/docker</code> 修改成了 <code>/data/docker</code> ，修改之后我们原来的容器镜像都会找不到的，所以我们就不修改默认目录，还是使用原来的  <code>/var/lib/docker</code>。可以使用以下命令查看 docker 默认目录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker info | grep &quot;Docker Root Dir&quot;</span><br><span class="line">Docker Root Dir: &#x2F;var&#x2F;lib&#x2F;docker</span><br></pre></td></tr></table></figure></blockquote><h4 id="2-Create-modify-files"><a href="#2-Create-modify-files" class="headerlink" title="2. Create/modify files"></a>2. Create/modify files</h4><p>创建 <code>/etc/docker/daemon.json</code> 文件（如果已经存在则修改），加入以下内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;hosts&quot; : [&quot;unix:&#x2F;&#x2F;&#x2F;var&#x2F;run&#x2F;docker.sock&quot;, &quot;tcp:&#x2F;&#x2F;0.0.0.0:2375&quot;]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>&quot;unix:///var/run/docker.sock&quot;</code>：unix socket，本地客户端将通过这个来连接 Docker Daemon。</li><li><code>&quot;tcp://0.0.0.0:2375&quot;</code>：tcp socket，表示允许任何远程客户端通过 2375 端口连接 Docker Daemon。</li></ul><blockquote><p>注意：这里也和原文链接有点不同。</p></blockquote><h4 id="3-Servers-using-systemd"><a href="#3-Servers-using-systemd" class="headerlink" title="3. Servers using systemd:"></a>3. Servers using systemd:</h4><p>可以使用 <code>systemctl edit docker</code> 来调用文本编辑器修改指定的单元或单元实例，ubuntu 默认调用的是 nano 编辑器，不是很好用，如果不熟悉 nano 编辑器的操作可以使用 vim 编辑器。</p><p>主要也就是新建或修改 <code>/etc/systemd/system/docker.service.d/override.conf </code>，其内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">##Add this to the file for the docker daemon to use different ExecStart parameters (more things can be added here)</span><br><span class="line">[Service]</span><br><span class="line">ExecStart&#x3D;</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;dockerd</span><br></pre></td></tr></table></figure><p>解释一下：</p><blockquote><p>默认情况下使用 systemd 时，docker.service 的设置为：<code>ExecStart=/usr/bin/dockerd -H fd:// </code>，这将覆盖写到 <u>daemon.json</u> 中的任何 hosts 。通过在 <u>override.conf</u>  文件中将 ExecStart 仅仅定义为：<code>ExecStart=/usr/bin/dockerd </code>，这将会使用在 <u>daemon.json</u> 中设置的 hosts 。这个文件中的第一行<code>ExecStart= </code> 必须要有，因为它将用于清楚默认的 ExecStart 参数。如果是修改 docker.service 的文件而不是创建 <u>override.conf</u>，那么下次 systemd 重启时，docker.service 文件也会被重新创建。</p></blockquote><p>重新加载 daemon 并重启 docker 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker.service</span><br></pre></td></tr></table></figure><p>检查端口监听：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># netstat -ntlp |grep dockerd</span><br><span class="line">tcp6       0      0 :::2375             :::*         LISTEN      6259&#x2F;dockerd</span><br></pre></td></tr></table></figure><blockquote><p>如果检查端口监听时出现下面的提示，则说明需要使用 root 权限。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(Not all processes could be identified, non-owned process info</span><br><span class="line"> will not be shown, you would have to be root to see it all.)</span><br></pre></td></tr></table></figure><p>在远程主机上面通过 tcp socket 来访问本机的 Docker Daemon 服务：</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ docker -H 192.168.1.130:2375 images</span><br><span class="line"></span><br><span class="line">$ docker -H 192.168.1.130:2375 ps</span><br></pre></td></tr></table></figure><blockquote><p>其中 192.168.1.130 是开放了远程访问的主机的 IP。</p><p>另外需要注意的是这种操作是不太安全的，仅用于测试使用。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Docker </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hyperledger caliper 安装记录</title>
      <link href="2018/10/10/caliper%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/"/>
      <url>2018/10/10/caliper%E5%AE%89%E8%A3%85%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h2 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h2><p>Caliper 是一个区块链性能测试框架，可用于测试不同的区块链实现，由华为公司开发并贡献给 Hyperledger。本文介绍如何在 ubuntu 系统下安装 caliper 并完成简单测试，最后会说明安装过程中的错误解决。</p><a id="more"></a><h2 id="Pre-requisites"><a href="#Pre-requisites" class="headerlink" title="Pre-requisites"></a>Pre-requisites</h2><p>需要安装的基础环境如下：</p><ul><li>make，g++</li><li>NodeJS 8.X</li><li>node-gyp</li><li>Docker</li><li>Docker-compose</li></ul><h3 id="1-安装-make，g-编译工具"><a href="#1-安装-make，g-编译工具" class="headerlink" title="1. 安装 make，g++ 编译工具"></a>1. 安装 make，g++ 编译工具</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install make g++</span><br></pre></td></tr></table></figure><h3 id="2-安装node-js"><a href="#2-安装node-js" class="headerlink" title="2. 安装node.js"></a>2. 安装node.js</h3><p>ubuntu 支持 nodesouce 的二进制安装脚本，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">curl -sL https:&#x2F;&#x2F;deb.nodesource.com&#x2F;setup_8.x | sudo -E bash -</span><br><span class="line">sudo apt-get install -y nodejs</span><br></pre></td></tr></table></figure><p>安装完成后查看 node 与 npm 的版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ node -v</span><br><span class="line">v8.12.0</span><br><span class="line">$ npm -v</span><br><span class="line">6.4.1</span><br></pre></td></tr></table></figure><h3 id="3-安装-node-gyp"><a href="#3-安装-node-gyp" class="headerlink" title="3. 安装 node-gyp"></a>3. 安装 node-gyp</h3><p>npm 全局安装 node-gyp：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g node-gyp</span><br></pre></td></tr></table></figure><h3 id="4-安装-Docker"><a href="#4-安装-Docker" class="headerlink" title="4. 安装 Docker"></a>4. 安装 Docker</h3><ul><li><p>由于 apt 源使用HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>为了确认所下载软件包的合法性，需要添加软件源的 GPG 秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>然后，我们需要向 sources.list 中添加 Docker 软件源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的Docker CE apt 镜像源。</p></blockquote></li><li><p>更新 apt 软件包缓存，并安装 docker-ce：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker -v</span><br><span class="line">Docker version 18.06.0-ce, build 0ffa825</span><br></pre></td></tr></table></figure></li><li><p>启动 Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>建立 docker 用户组</p><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><blockquote><p>其实一般按照上面的方法安装 Docker 后就已经创建好 docker 用户组了，可以使用 <code>$ cat /etc/group | grep docker</code> 命令来验证，所以就不需要再建立 docker 用户组了，再建立也会报错提示用户组已存在的。</p></blockquote></li><li><p>将当前用户加入 docker 用户组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><blockquote><p>下次登录时即可方便的使用 docker 命令。</p></blockquote></li><li><p>测试 Docker 是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">9db2ca6ccae0: Pull complete </span><br><span class="line">Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdc</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;hub.docker.com&#x2F;</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;userguide&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速器</p><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： </p><ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror">Docker 官方提供的中国 registry mirror <code>https://registry.docker-cn.com</code></a> </li><li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror">七牛云加速器 <code>https://reg-mirror.qiniu.com/</code></a> </li></ul><blockquote><p>当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。</p><p>国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</p></blockquote><p>我们以 Docker 官方加速器 <code>https://registry.docker-cn.com</code> 为例进行介绍。 </p><p>在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在则创建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重新启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="5-安装-Docker-compose"><a href="#5-安装-Docker-compose" class="headerlink" title="5. 安装 Docker-compose"></a>5. 安装 Docker-compose</h3></li><li><p>通过二进制包来安装，从 <a href="https://github.com/docker/compose/releases">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.22.0&#x2F;docker-compose-$(uname -s)-$(uname -m) -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker compose 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="Clone-caliper-repository"><a href="#Clone-caliper-repository" class="headerlink" title="Clone caliper repository"></a>Clone caliper repository</h2><p>从 GitHub 克隆 caliper 代码仓库：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git clone https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;caliper.git</span><br></pre></td></tr></table></figure><p>进入 caliper 目录并运行 <code>npm install</code> 安装依赖包：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd caliper&#x2F;</span><br><span class="line">npm install</span><br></pre></td></tr></table></figure><hr><h2 id="Install-fabric-SDKs"><a href="#Install-fabric-SDKs" class="headerlink" title="Install fabric SDKs"></a>Install fabric SDKs</h2><p>在 caliper 目录下本地安装 fabric SDKs：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install grpc@1.10.1 fabric-ca-client fabric-client</span><br></pre></td></tr></table></figure><p>以上命令默认安装 fabric 最新版本的 SDKs，但是由于 caliper 验证过的最新版本是 v1.1.0，所以我们最好安装 v1.1.0 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install fabric-ca-client@1.1.0 fabric-client@1.1.0</span><br></pre></td></tr></table></figure><hr><h2 id="Run-benchmark"><a href="#Run-benchmark" class="headerlink" title="Run benchmark"></a>Run benchmark</h2><p>性能测试示例在<code>benchmark</code>目录下，用法如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node benchmark&#x2F;simple&#x2F;main.js -c yourconfig.json -n yournetwork.json</span><br></pre></td></tr></table></figure><ul><li>-c 用于指定区块链的配置文件，不指定的话默认为<code>config.json</code>；</li><li>-n 用于指定区块链网络配置文件，不指定的话由-c指定的配置文件定义。</li></ul><p>运行一个 simple 的实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node benchmark&#x2F;simple&#x2F;main.js</span><br></pre></td></tr></table></figure><p>生成的报告如下：</p><p><img src="https://github.com/cao0507/My-Pictures-Repository/blob/master/Blockchain/caliper/simple-report-html.png?raw=true"></p><hr><h2 id="Bugs"><a href="#Bugs" class="headerlink" title="Bugs"></a>Bugs</h2><h3 id="运行测试遇到-REQUEST-TIMEOUT-的问题："><a href="#运行测试遇到-REQUEST-TIMEOUT-的问题：" class="headerlink" title="运行测试遇到 REQUEST_TIMEOUT 的问题："></a>运行测试遇到 <code>REQUEST_TIMEOUT</code> 的问题：</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br></pre></td><td class="code"><pre><span class="line">$ node benchmark&#x2F;simple&#x2F;main.js </span><br><span class="line">TAP version 13</span><br><span class="line"># #######Caliper Test######</span><br><span class="line">docker-compose -f network&#x2F;fabric&#x2F;simplenetwork&#x2F;docker-compose.yaml up -d</span><br><span class="line">Creating network &quot;simplenetwork_default&quot; with the default driver</span><br><span class="line">Creating ca_peerOrg1          ... done</span><br><span class="line">Creating simplenetwork_peer_1   ... done</span><br><span class="line">Creating orderer.example.com  ... done</span><br><span class="line">Creating ca_peerOrg2            ... done</span><br><span class="line">Creating simplenetwork_ca_1     ... done</span><br><span class="line">Creating peer1.org2.example.com ... done</span><br><span class="line">Creating peer0.org1.example.com ... done</span><br><span class="line">Creating peer1.org1.example.com ... done</span><br><span class="line">Creating peer0.org2.example.com ... done</span><br><span class="line"># create mychannel......</span><br><span class="line">ok 1 created mychannel successfully</span><br><span class="line"># Sleep 5s......</span><br><span class="line"># Join channel......</span><br><span class="line"># join mychannel</span><br><span class="line">ok 2 Successfully joined mychannel</span><br><span class="line"># install all chaincodes......</span><br><span class="line">info: [packager&#x2F;Golang.js]: packaging GOLANG from contract&#x2F;fabric&#x2F;simple&#x2F;go</span><br><span class="line">info: [packager&#x2F;Golang.js]: packaging GOLANG from contract&#x2F;fabric&#x2F;simple&#x2F;go</span><br><span class="line">ok 3 Installed chaincode simple successfully in all peers</span><br><span class="line"># Instantiate chaincode......</span><br><span class="line">error: [Peer.js]: sendProposal - timed out after:120000</span><br><span class="line">error: [Peer.js]: sendProposal - timed out after:120000</span><br><span class="line">error: [Peer.js]: sendProposal - timed out after:120000</span><br><span class="line">error: [Peer.js]: sendProposal - timed out after:120000</span><br><span class="line">error: [client-utils.js]: sendPeersProposal - Promise is rejected: Error: REQUEST_TIMEOUT</span><br><span class="line">    at Timeout._onTimeout (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Peer.js:124:19)</span><br><span class="line">    at ontimeout (timers.js:498:11)</span><br><span class="line">    at tryOnTimeout (timers.js:323:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:290:5)</span><br><span class="line">error: [client-utils.js]: sendPeersProposal - Promise is rejected: Error: REQUEST_TIMEOUT</span><br><span class="line">    at Timeout._onTimeout (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Peer.js:124:19)</span><br><span class="line">    at ontimeout (timers.js:498:11)</span><br><span class="line">    at tryOnTimeout (timers.js:323:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:290:5)</span><br><span class="line">error: [client-utils.js]: sendPeersProposal - Promise is rejected: Error: REQUEST_TIMEOUT</span><br><span class="line">    at Timeout._onTimeout (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Peer.js:124:19)</span><br><span class="line">    at ontimeout (timers.js:498:11)</span><br><span class="line">    at tryOnTimeout (timers.js:323:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:290:5)</span><br><span class="line">error: [client-utils.js]: sendPeersProposal - Promise is rejected: Error: REQUEST_TIMEOUT</span><br><span class="line">    at Timeout._onTimeout (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;node_modules&#x2F;fabric-client&#x2F;lib&#x2F;Peer.js:124:19)</span><br><span class="line">    at ontimeout (timers.js:498:11)</span><br><span class="line">    at tryOnTimeout (timers.js:323:5)</span><br><span class="line">    at Timer.listOnTimeout (timers.js:290:5)</span><br><span class="line">not ok 4 Failed to instantiate chaincodes, Error: Failed to send instantiate due to error: Error: Failed to send instantiate Proposal or receive valid response. Response null or status is not 200. exiting... at Client.newDefaultKeyValueStore.then.then.then.then (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;e2eUtils.js:372:19) at &lt;anonymous&gt; at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7) at Client.newDefaultKeyValueStore.then.then.then.then.then (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;e2eUtils.js:385:15) at &lt;anonymous&gt; at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">  ---</span><br><span class="line">    operator: fail</span><br><span class="line">    at: chaincodes.reduce.then.catch (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;instantiate-chaincode.js:60:19)</span><br><span class="line">    stack: |-</span><br><span class="line">      Error: Failed to instantiate chaincodes, Error: Failed to send instantiate due to error: Error: Failed to send instantiate Proposal or receive valid response. Response null or status is not 200. exiting...</span><br><span class="line">          at Client.newDefaultKeyValueStore.then.then.then.then (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;e2eUtils.js:372:19)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">          at Client.newDefaultKeyValueStore.then.then.then.then.then (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;e2eUtils.js:385:15)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">          at Test.assert [as _assert] (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:224:54)</span><br><span class="line">          at Test.bound [as _assert] (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:76:32)</span><br><span class="line">          at Test.fail (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:317:10)</span><br><span class="line">          at Test.bound [as fail] (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;node_modules&#x2F;tape&#x2F;lib&#x2F;test.js:76:32)</span><br><span class="line">          at chaincodes.reduce.then.catch (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;instantiate-chaincode.js:60:19)</span><br><span class="line">          at &lt;anonymous&gt;</span><br><span class="line">          at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">  ...</span><br><span class="line">fabric.installSmartContract() failed, Error: Fabric: instantiate chaincodes failed</span><br><span class="line">    at chaincodes.reduce.then.catch (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;instantiate-chaincode.js:61:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">[Transaction Info] - Submitted: 0 Succ: 0 Fail:0 Unfinished:0</span><br><span class="line">unexpected error, Error: Fabric: instantiate chaincodes failed</span><br><span class="line">    at chaincodes.reduce.then.catch (&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper&#x2F;src&#x2F;fabric&#x2F;instantiate-chaincode.js:61:31)</span><br><span class="line">    at &lt;anonymous&gt;</span><br><span class="line">    at process._tickCallback (internal&#x2F;process&#x2F;next_tick.js:189:7)</span><br><span class="line">docker-compose -f network&#x2F;fabric&#x2F;simplenetwork&#x2F;docker-compose.yaml down;docker rm $(docker ps -aq);docker rmi $(docker images dev* -q)</span><br><span class="line">Stopping peer0.org1.example.com ... done</span><br><span class="line">Stopping peer0.org2.example.com ... done</span><br><span class="line">Stopping peer1.org1.example.com ... done</span><br><span class="line">Stopping peer1.org2.example.com ... done</span><br><span class="line">Stopping simplenetwork_ca_1     ... done</span><br><span class="line">Stopping ca_peerOrg2            ... done</span><br><span class="line">Stopping orderer.example.com    ... done</span><br><span class="line">Stopping ca_peerOrg1            ... done</span><br><span class="line">Removing peer0.org1.example.com ... done</span><br><span class="line">Removing peer0.org2.example.com ... done</span><br><span class="line">Removing peer1.org1.example.com ... done</span><br><span class="line">Removing peer1.org2.example.com ... done</span><br><span class="line">Removing simplenetwork_ca_1     ... done</span><br><span class="line">Removing ca_peerOrg2            ... done</span><br><span class="line">Removing simplenetwork_peer_1   ... done</span><br><span class="line">Removing orderer.example.com    ... done</span><br><span class="line">Removing ca_peerOrg1            ... done</span><br><span class="line">Removing network simplenetwork_default</span><br><span class="line">&quot;docker rm&quot; requires at least 1 argument.</span><br><span class="line">See &#39;docker rm --help&#39;.</span><br><span class="line"></span><br><span class="line">Usage:  docker rm [OPTIONS] CONTAINER [CONTAINER...]</span><br><span class="line"></span><br><span class="line">Remove one or more containers</span><br><span class="line">&quot;docker rmi&quot; requires at least 1 argument.</span><br><span class="line">See &#39;docker rmi --help&#39;.</span><br><span class="line"></span><br><span class="line">Usage:  docker rmi [OPTIONS] IMAGE [IMAGE...]</span><br><span class="line"></span><br><span class="line">Remove one or more images</span><br><span class="line"></span><br><span class="line">1..4</span><br><span class="line"># tests 4</span><br><span class="line"># pass  3</span><br><span class="line"># fail  1</span><br></pre></td></tr></table></figure><p>问题解决：</p><ol><li><p>首先需要检查环境依赖是否正确安装，尤其是 node-gyp 包。</p></li><li><p>然后查看 npm 包版本信息及 docker 镜像信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ npm ls fabric-client</span><br><span class="line">caliper@0.1.0 &#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper</span><br><span class="line">└── fabric-client@1.1.0</span><br><span class="line"></span><br><span class="line">$ npm ls fabric-ca-client</span><br><span class="line">caliper@0.1.0 &#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper</span><br><span class="line">└── fabric-ca-client@1.1.0</span><br><span class="line"></span><br><span class="line">$ npm ls grpc</span><br><span class="line">caliper@0.1.0 &#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;caliper</span><br><span class="line">├─┬ fabric-client@1.1.0</span><br><span class="line">│ └── grpc@1.10.1  deduped</span><br><span class="line">└── grpc@1.10.1</span><br></pre></td></tr></table></figure><p>需确认无误。因为 caliper 在创建 fabric 网络时默认是使用的 fabric v1.1.0 版本，docker 下载的 peer、Orderer、ca 镜像也是 x86_64-v1.1.0 版本，所以 fabric SDKs 的 版本必须一致。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                   TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hyperledger&#x2F;fabric-ca        x86_64-1.1.0        72617b4fa9b4        6 months ago        299MB</span><br><span class="line">hyperledger&#x2F;fabric-orderer   x86_64-1.1.0        ce0c810df36a        6 months ago        180MB</span><br><span class="line">hyperledger&#x2F;fabric-peer      x86_64-1.1.0        b023f9be0771        6 months ago        187MB</span><br></pre></td></tr></table></figure></li><li><p>修改请求超时时间</p><p>在一台虚拟机里面安装的测试环境，搭建的 fabric 网络将会运行有7个 nodes/containers（1 orderer，2 CAs，4 peers），可能由于虚拟机性能的原因，原本 2 分钟的请求超时时间可能不足以 instantiate chaincode（需要构建一个 docker 镜像，并在每个 peer 中运行 chaincode Init 函数）。所以应该尝试增加 timeout 的值。修改 src/fabric/e2eUtils.js 第211行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Client.setConfigSetting(&#39;request-timeout&#39;, 120000);</span><br></pre></td></tr></table></figure><p>将 120000 增加到 480000。</p><blockquote><p>参考链接：</p><p><a href="https://github.com/hyperledger/caliper/issues/118">Instantiate chaincode…… #118</a></p><p><a href="https://github.com/hyperledger/caliper/issues/137">instantiate chaincodes Error #137</a></p></blockquote></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> Hyperledger caliper </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>阿里云服务器实现 frp 内网穿透</title>
      <link href="2018/09/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/"/>
      <url>2018/09/18/%E9%98%BF%E9%87%8C%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%AE%9E%E7%8E%B0frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/</url>
      
        <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>前几天在一台具有公网IP的 vultr 云服务器上实现了 frp 内网穿透<a href="https://cao0507.github.io/2018/09/14/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0ssh%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8/">（参考链接）</a>，可以从寝室 ssh 登录到教研室的服务器，但是由于 vultr 的云服务器位于国外的节点，连接速度太慢了，导致连接 ssh 登录的体验很差。今天又弄了一台阿里云的云服务器 ECS，所以现在来介绍如何在阿里云上实现 frp 内网穿透。</p><a id="more"></a><h2 id="配置-ssh-访问内网机器"><a href="#配置-ssh-访问内网机器" class="headerlink" title="配置 ssh 访问内网机器"></a>配置 ssh 访问内网机器</h2><p>之前使用的 vultr 的VPS是 CentOS 系统的，这次阿里云服务器是 Ubuntu 的操作系统，但其实不同操作系统的云服务器在使用 frp 时操作都是一样的，就是<strong>下载</strong>，<strong>配置</strong>，<strong>运行</strong>。可能有区别的地方就是防火墙相关的配置，不同云服务厂商的镜像不同可能也有一些差别。下面来说明在阿里云的公网服务器的 frp 实现步骤：</p><h4 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h4><p>在阿里云的公网服务器和内网机器上都要下载安装包并解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.21.0&#x2F;frp_0.21.0_linux_amd64.tar.gz</span><br><span class="line">$ tar -xzvf frp_0.21.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压之后的文件夹中既包含了服务端的文件又包括客户端的文件，所以可以分别在两个机器上删除掉不必要的文件，也可以不删，都没有影响。强迫症还是来删一下，在解压后的文件夹中： </p><ul><li><p>在公网服务器上删除客户端相关的文件，只保留一下两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frps  frps.ini</span><br></pre></td></tr></table></figure></li><li><p>在内网机器上删除服务端相关的文件，只保留以下两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc   frpc.ini</span><br></pre></td></tr></table></figure><h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4></li></ul><p>就是需要修改配置文件 <code>frps.ini</code> 及 <code>frpc.ini</code>。</p><ul><li><p>修改公网服务器上的服务端配置文件 <code>frps.ini</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000  #frp服务端端口（必须）</span><br></pre></td></tr></table></figure></li><li><p>修改内网目标主机的客户端配置文件 <code>frpc.ini</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; xxx.xxx.xxx.xxx   #frp服务端地址，必须是公网ip或者域名，这里假设为xxx.xxx.xxx.xxx</span><br><span class="line">server_port &#x3D; 7000      #frp服务端端口，即填写服务端配置中的 bind_port</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp              #连接类型，填tcp或udp</span><br><span class="line">local_ip &#x3D; 127.0.0.1    #填127.0.0.1或内网ip都可以</span><br><span class="line">local_port &#x3D; 22         #需要转发到的端口，ssh端口是22</span><br><span class="line">remote_port &#x3D; 6000      #frp服务端的远程监听端口，即你访问服务端的remote_port就相当于访</span><br><span class="line">                        #问客户端的 local_port，如果填0则会随机分配一个端口</span><br></pre></td></tr></table></figure><h4 id="运行"><a href="#运行" class="headerlink" title="运行"></a>运行</h4></li><li><p>在公网服务器上运行服务端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup .&#x2F;frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>查看 nohup.out 的信息，success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f nohup.out</span><br><span class="line">2018&#x2F;09&#x2F;17 21:34:01 [I] [service.go:130] frps tcp listen on 0.0.0.0:7000</span><br><span class="line">2018&#x2F;09&#x2F;17 21:34:01 [I] [root.go:207] Start frps success</span><br><span class="line">2018&#x2F;09&#x2F;17 22:06:02 [I] [service.go:319] client login info: ip [125.71.229.32:60516] version [0.21.0] hostname [] os [linux] arch [amd64]</span><br><span class="line">2018&#x2F;09&#x2F;17 22:06:02 [I] [proxy.go:217] [7940291c148c2fca] [ssh] tcp proxy listen port [6000]</span><br><span class="line">2018&#x2F;09&#x2F;17 22:06:02 [I] [control.go:335] [7940291c148c2fca] new proxy [ssh] success</span><br></pre></td></tr></table></figure></li><li><p>在内网目标主机上运行客户端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup .&#x2F;frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>查看 nohup.out 的信息，success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f nohup.out</span><br><span class="line">2018&#x2F;09&#x2F;17 22:42:22 [I] [proxy_manager.go:300] proxy removed: []</span><br><span class="line">2018&#x2F;09&#x2F;17 22:42:22 [I] [proxy_manager.go:310] proxy added: [ssh1]</span><br><span class="line">2018&#x2F;09&#x2F;17 22:42:22 [I] [proxy_manager.go:333] visitor removed: []</span><br><span class="line">2018&#x2F;09&#x2F;17 22:42:22 [I] [proxy_manager.go:342] visitor added: []</span><br><span class="line">2018&#x2F;09&#x2F;17 22:42:23 [I] [control.go:246] [0624b332c3465118] login to server success, get run id [0624b332c3465118], server udp port [0]</span><br><span class="line">2018&#x2F;09&#x2F;17 22:42:23 [I] [control.go:169] [0624b332c3465118] [ssh1] start proxy success</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="配置多个内网主机"><a href="#配置多个内网主机" class="headerlink" title="配置多个内网主机"></a>配置多个内网主机</h2><h4 id="错误的多客户端配置"><a href="#错误的多客户端配置" class="headerlink" title="错误的多客户端配置"></a>错误的多客户端配置</h4><p>使用一台阿里云的公网服务器，我们可以配置很多内网机器的 frp 内网穿透，公网服务器上只需要按照上述的配置一次即可，但是内网机器的配置稍有不同，如果使用了一样的配置则后添加的内网机器是无法连接上公网服务器的。这里假设另一台内网机器2的 frpc.ini 配置如下，来说明会遇到的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ vi frpc.ini</span><br><span class="line">[common]</span><br><span class="line">server_addr &#x3D; xxx.xxx.xxx.xxx  &lt;&#x3D;&#x3D;这里还是按照上面的假设，公网服务器的ip为xxx.xxx.xxx.xxx</span><br><span class="line">server_port &#x3D; 7000</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp </span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6001     &lt;&#x3D;&#x3D;remote_port设置为另一个值</span><br></pre></td></tr></table></figure><p>两个内网主机的配置除了 remote_port 不一样之外，都是一样的。但是在内网机器2上运行 frpc 后，公网服务器的 nohup.out 中会记录一下的错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[W] [control.go:332] [280d36891a6ae0c7] new proxy [ssh] error: proxy name [ssh] is already in use</span><br></pre></td></tr></table></figure><p>后来发现，frp 中是通过 [ssh] 这个名字来区分不同客户端的，所以不同的客户端要配置成不同的名字。</p><h4 id="正确的多客户端配置"><a href="#正确的多客户端配置" class="headerlink" title="正确的多客户端配置"></a>正确的多客户端配置</h4><p>内网机器1和内网机器2的配置应该区分如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">内网机器1：</span><br><span class="line">[ssh]                      &lt;&#x3D;&#x3D;不同点</span><br><span class="line">type &#x3D; tcp </span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6000         &lt;&#x3D;&#x3D;不同点</span><br><span class="line"></span><br><span class="line">内网机器2：</span><br><span class="line">[ssh1]                     &lt;&#x3D;&#x3D;不同点</span><br><span class="line">type &#x3D; tcp </span><br><span class="line">local_ip &#x3D; 127.0.0.1</span><br><span class="line">local_port &#x3D; 22</span><br><span class="line">remote_port &#x3D; 6001         &lt;&#x3D;&#x3D;不同点</span><br></pre></td></tr></table></figure><p>在两个内网机器上分别运行 frpc 客户端程序后，一般就可以通过以下的方法 ssh 登录：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">内网机器1：</span><br><span class="line">$ ssh -p 6000 user_name1@server_addr</span><br><span class="line"></span><br><span class="line">内网机器2：</span><br><span class="line">$ ssh -p 6001 user_name2@server_addr</span><br></pre></td></tr></table></figure><blockquote><p>以上参数中，server_addr是公网服务器的公网ip；user_name1、user_name2 分别是内网机器1、2的用户名，之后分别使用登录密码就可以登录。</p></blockquote><hr><h2 id="connection-timed-out-解决"><a href="#connection-timed-out-解决" class="headerlink" title="connection timed out 解决"></a>connection timed out 解决</h2><p>但是有时候会发现按照以上的配置还是使 frp 的服务端与客户端建立连接，在客户端上会出现以下错误：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">2018&#x2F;09&#x2F;17 22:02:23 [W] [control.go:113] login to server failed: dial tcp xxx.xxx.xxx.xxx:7000: connect: connection timed out</span><br><span class="line">dial tcp xxx.xxx.xxx.xxx:7000: connect: connection timed out</span><br></pre></td></tr></table></figure><p>仔细检查了一下云服务器上面的防火墙设置，发现并没有任何过滤规则，那应该不是防火墙的问题</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># iptables -vnL</span><br><span class="line">Chain INPUT (policy ACCEPT 46165 packets, 28M bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain FORWARD (policy ACCEPT 0 packets, 0 bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination         </span><br><span class="line"></span><br><span class="line">Chain OUTPUT (policy ACCEPT 42223 packets, 3001K bytes)</span><br><span class="line"> pkts bytes target     prot opt in     out     source               destination </span><br></pre></td></tr></table></figure><p>然后又仔细想了一下我以前在做关于 OpenStack 的项目中也碰到了类似的问题，就是创建了云实例，发现无法通过 ssh 来登录，就是因为 OpenStack 有安全组规则相关的设置。</p><blockquote><p>想到了这里就有一种熟悉的感觉，还是原来的配方，hahaha。。。</p></blockquote><p>登录到阿里云对应云服务器的管理控制台，如下找到左上方的本实例安全组：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/aliyun%20instance%20info.jpg" alt="aliyun"></p><p>然后点击右上角的配置规则：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/aliyun%20group%20rules.jpg"></p><p>再点击右上角的添加安全组规则：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/aliyun%20groups%20rules%20setting.jpg" alt="aliyun"></p><p>最后在添加安全组规则的界面添加相应的规则：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/aliyun%20group%20rules%20adding.jpg" alt="阿里云"></p><blockquote><p>主要有两个配置项，端口范围和授权对象</p><ul><li>端口范围就是你要开放的端口的范围，需要将 <code>server_port</code> 和 <code>remote_port</code> 都添加进去，可以分成两条规则分别添加；</li><li>授权对象是你要授权的对象，一般设为 <code>0.0.0.0/0</code>  表示允许所有IP的访问。</li></ul></blockquote><p>以上就是针对阿里云的云服务器的安全组设置，其他厂商如果有安全组规则也应该是类似的。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> frp </tag>
            
            <tag> 内网穿透 </tag>
            
            <tag> aliyun </tag>
            
            <tag> 安全组规则 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于 SSH 的个人总结</title>
      <link href="2018/09/15/%E5%85%B3%E4%BA%8ESSH%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/"/>
      <url>2018/09/15/%E5%85%B3%E4%BA%8ESSH%E7%9A%84%E4%B8%AA%E4%BA%BA%E6%80%BB%E7%BB%93/</url>
      
        <content type="html"><![CDATA[<h2 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h2><p>在日常学习工作中，早已离不开远程的 Linux 服务器或虚拟机，每次都是借助 Xshell 中保存的用户密码方便的 ssh 登录，偶尔在配置环境中的时候用到了秘钥登录，但是从来没有总结一下相关的内容，每次有问题都是上网查，所以写下这篇个人经验总结的文章。本文将主要介绍 <u>ssh 的安装</u>， <u>ssh 免密登录</u>，<u>允许 root 登录</u>，<u>ssh 登录的一些选项</u>，<u>ssh 登录本机</u>等问题。</p><a id="more"></a><hr><h2 id="安装-ssh"><a href="#安装-ssh" class="headerlink" title="安装 ssh"></a>安装 ssh</h2><h5 id="基于-Debian-Ubuntu-系统"><a href="#基于-Debian-Ubuntu-系统" class="headerlink" title="基于 Debian/Ubuntu 系统"></a>基于 Debian/Ubuntu 系统</h5><ul><li><p>安装客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-client</span><br></pre></td></tr></table></figure></li><li><p>安装服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt-get install openssh-server</span><br></pre></td></tr></table></figure><h5 id="基于-RedHat-CentOS-系统"><a href="#基于-RedHat-CentOS-系统" class="headerlink" title="基于 RedHat/CentOS 系统"></a>基于 RedHat/CentOS 系统</h5></li><li><p>安装客户端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-clients</span><br></pre></td></tr></table></figure></li><li><p>安装服务端</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">yum install openssh-server</span><br></pre></td></tr></table></figure><blockquote><p> 关于客户端与服务端的区别就是：客户端用于你去登录别人，而服务端则是别人来登录你。</p></blockquote></li></ul><hr><h2 id="ssh-免密登录"><a href="#ssh-免密登录" class="headerlink" title="ssh 免密登录"></a>ssh 免密登录</h2><h5 id="快速实现步骤："><a href="#快速实现步骤：" class="headerlink" title="快速实现步骤："></a>快速实现步骤：</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">$ ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub username@xxx.xxx.xxx.xxx</span><br></pre></td></tr></table></figure><h5 id="说明如下："><a href="#说明如下：" class="headerlink" title="说明如下："></a>说明如下：</h5><p>Linux系统有一个钥匙环(keyring)的管理程序。钥匙环受到用户登录密码的保护。当你登录Linux系统时，会自动解开钥匙环的密码，从而可访问钥匙环。SSH的密钥和公钥也存储在钥匙环。所以初次使用SSH密钥登录远程Linux服务器时需要输入一次SSH密钥的密码。而将来使用SSH密钥登录时不再输入密码。Ubuntu的钥匙环程序是seahorse。</p><p>SSH密钥就好比是你的身份证明。远程Linux服务器用你生成的SSH公钥来加密一条消息，而只有你的SSH密钥可以解开这条消息。所以其他人如果没有你的SSH密钥，是无法解开加密消息的，从而也就无法登录你的Linux服务器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-keygen -t rsa</span><br><span class="line">Generating public&#x2F;private rsa key pair.</span><br><span class="line">Enter file in which to save the key (&#x2F;home&#x2F;user1&#x2F;.ssh&#x2F;id_rsa): </span><br><span class="line">Enter passphrase (empty for no passphrase): </span><br><span class="line">Enter same passphrase again: </span><br><span class="line">Your identification has been saved in &#x2F;home&#x2F;user1&#x2F;.ssh&#x2F;id_rsa.</span><br><span class="line">Your public key has been saved in &#x2F;home&#x2F;user1&#x2F;.ssh&#x2F;id_rsa.pub.</span><br><span class="line">The key fingerprint is:</span><br><span class="line">SHA256:BQeyB4pwfE1L7NAi7hjrTl5X814QW5Gu4dOZx0gIdng user1@ubuntu</span><br><span class="line">The key&#39;s randomart image is:</span><br><span class="line">+---[RSA 2048]----+</span><br><span class="line">|...  &#x3D;&#x3D; +....    |</span><br><span class="line">| oo.+o+O E ..    |</span><br><span class="line">| ..o.++ &#x3D;.+.     |</span><br><span class="line">|. .   .. ++o     |</span><br><span class="line">| &#x3D;     oSo&#x3D; &#x3D;    |</span><br><span class="line">|o .   . o+.&#x3D; o   |</span><br><span class="line">|.. . .   ....    |</span><br><span class="line">|o.. .   . .      |</span><br><span class="line">|.o       .       |</span><br><span class="line">+----[SHA256]-----+</span><br><span class="line"></span><br><span class="line">$ cd ~&#x2F;.ssh&#x2F;</span><br><span class="line">$ ls</span><br><span class="line">id_rsa  id_rsa.pub</span><br></pre></td></tr></table></figure><p><code>ssh-copy-id</code> 工具可以把本地主机的公钥复制到远程主机的 authorized_keys 文件上，<code>ssh-copy-id</code> 命令也会给远程主机的用户主目录（home）和<code>~/.ssh</code>, 和<code>~/.ssh/authorized_keys</code>设置合适的权限。 </p><ul><li><p>语法</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-copy-id [-i [identity_file]] [user@]machine</span><br></pre></td></tr></table></figure></li><li><p>选项</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i：指定公钥文件</span><br></pre></td></tr></table></figure></li><li><p>实例</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">$ ssh-copy-id -i ~&#x2F;.ssh&#x2F;id_rsa.pub user1@192.168.1.158</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: Source of key(s) to be installed: &quot;&#x2F;home&#x2F;user1&#x2F;.ssh&#x2F;id_rsa.pub&quot;</span><br><span class="line">The authenticity of host &#39;192.168.1.158 (192.168.1.158)&#39; can&#39;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:Gx0RFwV4EiROc6ymV&#x2F;BmSLE2zNT9AswZvzq9pc6Srwo.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)? yes</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">user1@192.168.1.158&#39;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#39;user1@192.168.1.158&#39;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure></li></ul><hr><h2 id="root-用户登录"><a href="#root-用户登录" class="headerlink" title="root 用户登录"></a>root 用户登录</h2><p>在一些系统上，比如 ubuntu，root 用户是默认禁用的，也就是说通常不允许 root 账号通过网络登录。但是通过适当的配置可以允许 root 用户登录。</p><ol><li><p>设置 root 用户密码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo passwd root</span><br></pre></td></tr></table></figure></li><li><p>允许 root 用户远程登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;ssh&#x2F;sshd_config</span><br><span class="line">...</span><br><span class="line">PermitRootLogin yes   #取消注释</span><br><span class="line"></span><br><span class="line"># service sshd restart   #重启ssh服务</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="ssh-登录选项"><a href="#ssh-登录选项" class="headerlink" title="ssh 登录选项"></a>ssh 登录选项</h2><h5 id="1-无选项参数运行-ssh"><a href="#1-无选项参数运行-ssh" class="headerlink" title="1. 无选项参数运行 ssh"></a>1. 无选项参数运行 ssh</h5><p>如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh 192.168.1.156</span><br></pre></td></tr></table></figure><p>这会用你的用户名去 <code>192.168.1.156</code> 这台主机，相当于省略了。如果目标主机上没有和你的用户名同名的，则每次输入密码都是显示密码错误。</p><h5 id="2-指定登录用户"><a href="#2-指定登录用户" class="headerlink" title="2. 指定登录用户"></a>2. 指定登录用户</h5><p>有如下两种方式指定用户名：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -l user1 192.168.1.156</span><br><span class="line"></span><br><span class="line">ssh user1@192.168.1.156</span><br></pre></td></tr></table></figure><h5 id="3-指定端口"><a href="#3-指定端口" class="headerlink" title="3. 指定端口"></a>3. 指定端口</h5><p>ssh 默认使用的端口号是 22。大多现代的 Linux 系统 22 端口都是开放的。如果你运行 ssh 程序而没有指定端口号，它直接就是通过 22 端口发送请求的。 当然也可以改变 ssh 的默认端口号，只需要修改 <code>/etc/ssh/sshd_config</code> 文件，找到此行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Port 22</span><br></pre></td></tr></table></figure><p>修改成你想要的端口，如 1234。然后重启 ssh 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo service sshd restart</span><br></pre></td></tr></table></figure><p>使用新的端口来访问 ssh 服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -p 1234 user1@192.168.1.156</span><br><span class="line">或</span><br><span class="line">ssh -oPort&#x3D;1234 user1@192.168.1.156</span><br></pre></td></tr></table></figure><h5 id="4-绑定源地址"><a href="#4-绑定源地址" class="headerlink" title="4. 绑定源地址"></a>4. 绑定源地址</h5><p>如果你的主机有多个 IP，如：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr d0:94:66:52:07:57  </span><br><span class="line">          inet addr:192.168.1.10  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::d294:66ff:fe52:757&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:3217625896 errors:0 dropped:1996 overruns:0 frame:0</span><br><span class="line">          TX packets:3417264542 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:2364841876835 (2.3 TB)  TX bytes:2940832952714 (2.9 TB)</span><br><span class="line">          Memory:93300000-933fffff </span><br><span class="line"></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr d0:94:66:52:07:58  </span><br><span class="line">          inet addr:192.168.1.20  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::d294:66ff:fe52:758&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:2387702 errors:0 dropped:2071 overruns:0 frame:0</span><br><span class="line">          TX packets:1052 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000 </span><br><span class="line">          RX bytes:275109861 (275.1 MB)  TX bytes:100254 (100.2 KB)</span><br><span class="line">          Memory:93200000-932fffff</span><br></pre></td></tr></table></figure><p>有时，你可能想指定以某个 IP 来登录别的 Linux 主机，则可以使用 -b 选项来指定一个 IP地址。这个 IP 将会用作建立连接的源地址。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -b 192.168.1.20 user1@192.168.1.156</span><br></pre></td></tr></table></figure><p>在服务端，可以使用 netstat 命令来检查 ssh 服务的连接建立情况。可以看到 IP 为 192.168.1.20 的连接已经建立。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ netstat |grep ssh</span><br><span class="line">tcp        0      0 192.168.1.156:ssh       192.168.1.20:43838      ESTABLISHED</span><br></pre></td></tr></table></figure><h5 id="5-公钥检查"><a href="#5-公钥检查" class="headerlink" title="5. 公钥检查"></a>5. 公钥检查</h5><p><strong>什么是公钥检查：</strong></p><p>ssh 连接远程主机时，会检查主机的公钥。如果是第一次该主机，会显示该主机的公钥摘要，提示用户是否信任该主机： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ssh user1@192.168.1.57</span><br><span class="line">The authenticity of host &#39;192.168.1.57 (192.168.1.57)&#39; can&#39;t be established.</span><br><span class="line">ECDSA key fingerprint is SHA256:Gx0RFwV4EiROc6ymV&#x2F;BmSLE2zNT9AswZvzq9pc6Srwo.</span><br><span class="line">Are you sure you want to continue connecting (yes&#x2F;no)?</span><br></pre></td></tr></table></figure><p>当选择接受，就会将该主机的公钥追加到文件 ~/.ssh/known_hosts 中。当再次连接该主机时，就不会再提示该问题了。  如果因为某种原因（服务器系统重装，服务器间IP地址交换，DHCP，虚拟机重建，中间人劫持），该IP地址的公钥改变了，当使用 SSH  连接的时候，会报错： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">@    WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED!     @</span><br><span class="line">@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@</span><br><span class="line">IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY!</span><br><span class="line">Someone could be eavesdropping on you right now (man-in-the-middle attack)!</span><br><span class="line">It is also possible that the RSA host key has just been changed.</span><br><span class="line">The fingerprint for the RSA key sent by the remote host is</span><br><span class="line">e9:0c:36:89:7f:3c:07:71:09:5a:9f:28:8c:44:e9:05.</span><br><span class="line">Please contact your system administrator.</span><br><span class="line">Add correct host key in &#x2F;home&#x2F;jiangxin&#x2F;.ssh&#x2F;known_hosts to get rid of this message.</span><br><span class="line">Offending key in &#x2F;home&#x2F;jiangxin&#x2F;.ssh&#x2F;known_hosts:81</span><br><span class="line">RSA host key for 192.168.0.110 has changed and you have requested strict checking.</span><br><span class="line">Host key verification failed.</span><br></pre></td></tr></table></figure><p>上面的警告信息说的是：</p><ul><li>服务器公钥已经改变，新的公钥的摘要是：e9:0c:36:89:7f:3c:07:71:09:5a:9f:28:8c:44:e9:05.</li><li>该服务器原来的公钥记录在文件 <code>~/.ssh/known_hosts</code> 中第 81 行。</li></ul><p>如果确认不是中间人劫持，需要连接到该服务器，怎么办呢？最简单的就是用 vi 打开 <code>~/.ssh/known_hosts</code> 文件，定位到 81 行，将该行删除。之后就可以使用 ssh 连接了。 </p><blockquote><p>我之前在项目中，基于 OpenStack 来搭建 SDN 网络时经常碰到上面的错误，因为经常会将一些云主机给删掉而将他们的 IP 分给新起的云主机。再用这个 IP 来登录新的主机时就会碰到这个问题，以前还不太明白咋回事，现在有种恍然大悟的感觉。</p></blockquote><p><strong>如何不进行公钥检查：</strong></p><p>在首次连接服务器时，会弹出公钥确认的提示。这会导致某些自动化任务，由于初次连接服务器而导致自动化任务中断。或者由于  <code>~/.ssh/known_hosts</code> 文件内容清空，导致自动化任务中断。 SSH 客户端的 StrictHostKeyChecking  配置指令，可以实现当第一次连接服务器时，自动接受新的公钥。只需要修改 <code>/etc/ssh/ssh_config</code> 文件，包含下列语句： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Host *</span><br><span class="line">   StrictHostKeyChecking no</span><br></pre></td></tr></table></figure><p>或者在 ssh 命令行中用 -o 参数：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh -o StrictHostKeyChecking&#x3D;no  user1@192.168.1.110</span><br></pre></td></tr></table></figure><blockquote><p>公钥检查确实很烦人，我以前在写自动化登录脚本时就觉得很棘手，导致自动化登录脚本经常出错。早知道是这个问题就好办多了，感觉写博客总结一下这些内容对于自己挺有帮助的。</p></blockquote><hr><h2 id="ssh-登录本机的问题"><a href="#ssh-登录本机的问题" class="headerlink" title="ssh 登录本机的问题"></a>ssh 登录本机的问题</h2><p>不试不知道，一试才知道 ssh 登录本机其实和登录其他的主机是一样的，也需要输入密码验证，免密登录也需要将自己的公钥记录在 <code>~/.ssh/authorized_keys</code> 文件中。ssh 登录本机可以使用本机的任意一个 IP 或者也可以用回环地址 <code>127.0.0.1</code> 。</p><hr><p>完结。。以上内容就是个人在学习工作中关于 ssh 的一些总结，感觉里面的学问真的是太大了，写了这么多其实还有很多很多相关的知识是我不知道不清楚的，不过学习就是这样的，总是由浅入深，不可能一下子就把所有的弄明白，剩下的就以后再慢慢总结啦！</p>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>frp 内网穿透实现 ssh 访问内网主机</title>
      <link href="2018/09/14/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0ssh%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8/"/>
      <url>2018/09/14/frp%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F%E5%AE%9E%E7%8E%B0ssh%E8%AE%BF%E9%97%AE%E5%86%85%E7%BD%91%E6%9C%BA%E5%99%A8/</url>
      
        <content type="html"><![CDATA[<h2 id="本文目的"><a href="#本文目的" class="headerlink" title="本文目的"></a>本文目的</h2><p>frp 是一个可用于内网穿透的高性能的反向代理应用，支持 tcp, udp, http, https 协议。 本文将基于 frp 来实现内网穿透，从而实现从外网 ssh 登录内网主机，而不对 frp 其他的应用做过多的说明。</p><a id="more"></a><hr><h2 id="frp-的作用"><a href="#frp-的作用" class="headerlink" title="frp 的作用"></a>frp 的作用</h2><ul><li>利用处于内网或防火墙后的机器，对外网环境提供 http 或 https 服务。</li><li>对于 http, https 服务支持基于域名的虚拟主机，支持自定义域名绑定，使多个域名可以共用一个80端口。</li><li>利用处于内网或防火墙后的机器，对外网环境提供 tcp 和 udp 服务，例如在家里通过 ssh 访问处于公司内网环境内的主机。</li></ul><h2 id="架构"><a href="#架构" class="headerlink" title="架构"></a>架构</h2><p><img src="https://raw.githubusercontent.com/fatedier/frp/master/doc/pic/architecture.png" alt="架构"></p><p>在具有公网IP的服务器或VPS上安装运行 frp 的服务端程序frps，并在处于内网的目标主机上面安装运行 frp 的客户端程序 frpc ，然后 User 就可以通过公网服务器来实现内网穿透从而访问内网主机。</p><hr><h2 id="配置-ssh-访问内网机器"><a href="#配置-ssh-访问内网机器" class="headerlink" title="配置 ssh 访问内网机器"></a>配置 ssh 访问内网机器</h2><p>根据不同的系统架构选择不同的安装包，从 <a href="https://github.com/fatedier/frp/releases">frp下载链接</a> 上下载合适的安装包。由于本人的公网服务器是 vultr 上面的一台 VPS，操作系统是 CentOS 7；内网机器也是一台 Linux 服务器，操作系统是 Ubuntu 16.04，所以我使用的安装包是 <code>frp_0.21.0_linux_amd64.tar.gz</code> 。配置步骤如下：</p><ol><li><p>下载安装包</p><p>在公网服务器和内网机器上都要下载安装包并解压：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;github.com&#x2F;fatedier&#x2F;frp&#x2F;releases&#x2F;download&#x2F;v0.21.0&#x2F;frp_0.21.0_linux_amd64.tar.gz</span><br><span class="line">$ tar -xzvf frp_0.21.0_linux_amd64.tar.gz</span><br></pre></td></tr></table></figure><p>解压之后的文件夹中既包含了服务端的文件又包括客户端的文件，所以可以分别在两个机器上删除掉不必要的文件，也可以不删，都没有影响。强迫症还是来删一下，在解压后的文件夹中：</p><ul><li><p>在公网服务器上删除客户端相关的文件，只保留一下两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frps  frps.ini</span><br></pre></td></tr></table></figure></li><li><p>在内网机器上删除服务端相关的文件，只保留以下两个文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">frpc   frpc.ini</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在公网服务器上配置并启动</p><p>修改配置文件 <code>$ vi frps.ini</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">bind_port &#x3D; 7000  #frp服务端端口（必须）</span><br></pre></td></tr></table></figure><p>配置很简单，然后启动：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup .&#x2F;frps -c frps.ini &amp;</span><br></pre></td></tr></table></figure><p>查看 nohup.out 的信息，success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"># tail -f nohup.out </span><br><span class="line">2018&#x2F;09&#x2F;14 05:33:15 [I] [service.go:130] frps tcp listen on 0.0.0.0:7000</span><br><span class="line">2018&#x2F;09&#x2F;14 05:33:15 [I] [root.go:207] Start frps success</span><br><span class="line">2018&#x2F;09&#x2F;14 05:49:47 [I] [service.go:130] frps tcp listen on 0.0.0.0:7000</span><br><span class="line">2018&#x2F;09&#x2F;14 05:49:47 [I] [root.go:207] Start frps success</span><br><span class="line">2018&#x2F;09&#x2F;14 06:28:59 [I] [service.go:319] client login info: ip [125.71.219.33:37092] version [0.21.0] hostname [] os [linux] arch [amd64]</span><br><span class="line">2018&#x2F;09&#x2F;14 06:28:59 [I] [proxy.go:217] [93eec0dde173fc68] [ssh] tcp proxy listen port [6000]</span><br><span class="line">2018&#x2F;09&#x2F;14 06:28:59 [I] [control.go:335] [93eec0dde173fc68] new proxy [ssh] success</span><br></pre></td></tr></table></figure></li><li><p>在内网机器上配置并启动</p><p>修改配置文件 <code>$ vi frpc.ini</code>，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">[common]</span><br><span class="line">server_addr &#x3D; 0.0.0.0   #frp服务端地址，可以填ip或者域名，这里假设为0.0.0.0</span><br><span class="line">server_port &#x3D; 7000      #frp服务端端口，即填写服务端配置中的 bind_port</span><br><span class="line"></span><br><span class="line">[ssh]</span><br><span class="line">type &#x3D; tcp              #连接类型，填tcp或udp</span><br><span class="line">local_ip &#x3D; 127.0.0.1    #填127.0.0.1或内网ip都可以</span><br><span class="line">local_port &#x3D; 22         #需要转发到的端口，ssh端口是22</span><br><span class="line">remote_port &#x3D; 6000      #frp服务端的远程监听端口，即你访问服务端的remote_port就相当于访</span><br><span class="line">                        #问客户端的 local_port，如果填0则会随机分配一个端口</span><br></pre></td></tr></table></figure><p>启动客户端程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ nohup .&#x2F;frpc -c frpc.ini &amp;</span><br></pre></td></tr></table></figure><p>查看 nohup.out 的信息，success</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f nohup.out</span><br><span class="line">2018&#x2F;09&#x2F;14 14:28:58 [I] [proxy_manager.go:300] proxy removed: []</span><br><span class="line">2018&#x2F;09&#x2F;14 14:28:58 [I] [proxy_manager.go:310] proxy added: [ssh]</span><br><span class="line">2018&#x2F;09&#x2F;14 14:28:58 [I] [proxy_manager.go:333] visitor removed: []</span><br><span class="line">2018&#x2F;09&#x2F;14 14:28:58 [I] [proxy_manager.go:342] visitor added: []</span><br><span class="line">2018&#x2F;09&#x2F;14 14:28:59 [I] [control.go:246] [93eec0dde173fc68] login to server success, get run id [93eec0dde173fc68], server udp port [0]</span><br><span class="line">2018&#x2F;09&#x2F;14 14:29:00 [I] [control.go:169] [93eec0dde173fc68] [ssh] start proxy success</span><br></pre></td></tr></table></figure></li><li><p>登录</p><p>完成前面三步的配置就可以登录对应的内网机器了，执行 ssh 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ssh -oPort&#x3D;6000 username@server_addr</span><br><span class="line">或者</span><br><span class="line">ssh -p 6000 username@server_addr</span><br></pre></td></tr></table></figure><blockquote><p>上面登录使用的 username 是<strong>内网机器的用户名</strong>，server_addr是<strong>公网服务器的IP</strong>，port 6000就是设置的 remote_port，最后的登录密码是<strong>内网机器的密码</strong>，而不是公网机器的密码，这一点一定要注意。</p></blockquote></li></ol><hr><h2 id="问题解决"><a href="#问题解决" class="headerlink" title="问题解决"></a>问题解决</h2><p>在启动服务端和客户端程序之后，可能发现还是无法登录到内网内网机器，在内网机器上面执行 <code>tail -f nohup.out</code> 查看启动命令的执行结果，可以发现以下的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ tail -f nohup.out </span><br><span class="line">2018&#x2F;09&#x2F;14 14:11:02 [I] [proxy_manager.go:333] visitor removed: []</span><br><span class="line">2018&#x2F;09&#x2F;14 14:11:02 [I] [proxy_manager.go:342] visitor added: []</span><br><span class="line">2018&#x2F;09&#x2F;14 14:13:09 [W] [control.go:113] login to server failed: dial tcp xxx.xxx.xxx.xxx:7000: connect: connection timed out</span><br><span class="line">dial tcp xxx.xxx.xxx.xxx:7000: connect: connection timed out</span><br></pre></td></tr></table></figure><p>仔细检查了一下，发现是我公网服务器防火墙的原因，没有允许对应端口的流量通过，所以需要配置防火墙：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --zone&#x3D;public --add-port&#x3D;7000&#x2F;tcp --permanent</span><br><span class="line"># firewall-cmd --zone&#x3D;public --add-port&#x3D;6000&#x2F;tcp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><blockquote><p>上面配置防火墙的命令是针对 CentOS 的，如果是别的系统不太一样，如 Ubuntu 通过<code>iptables</code>命令来配置。</p></blockquote><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> SSH </tag>
            
            <tag> frp </tag>
            
            <tag> 内网穿透 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell中set指令的用法</title>
      <link href="2018/09/13/shell%E4%B8%ADset%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/"/>
      <url>2018/09/13/shell%E4%B8%ADset%E6%8C%87%E4%BB%A4%E7%9A%84%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h4 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">set [-可选参数] [-o 选项]</span><br></pre></td></tr></table></figure><h4 id="功能说明"><a href="#功能说明" class="headerlink" title="功能说明"></a>功能说明</h4><p>set 指令可根据不同的需求来设置当前所使用 shell 的执行方式，同时也可以用来设置或显示 shell 变量的值。当指定某个单一的选项时将设置 shell 的常用特性，如果在选项后使用 -o 参数将打开特殊特性，若是 +o 将关闭相应的特殊特性。而不带任何参数的 set 指令将显示当前 shell 中的全部变量，且总是返回 true，除非遇到非法的选项。</p><a id="more"></a><hr><h4 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h4><p>可选参数及其说明如下：</p><table><thead><tr><th align="center">参数</th><th align="left">说明</th></tr></thead><tbody><tr><td align="center">-a</td><td align="left">标示已修改的变量，以供输出至环境变量</td></tr><tr><td align="center">-b</td><td align="left">使被中止的后台程序立刻回报执行状态</td></tr><tr><td align="center">-d</td><td align="left">Shell预设会用杂凑表记忆使用过的指令，以加速指令的执行。使用-d参数可取消</td></tr><tr><td align="center"><strong>-e</strong></td><td align="left">若指令传回值不等于0，则立即退出shell</td></tr><tr><td align="center">-f</td><td align="left">取消使用通配符</td></tr><tr><td align="center">-h</td><td align="left">自动记录函数的所在位置</td></tr><tr><td align="center">-k</td><td align="left">指令所给的参数都会被视为此指令的环境变量</td></tr><tr><td align="center">-l</td><td align="left">记录for循环的变量名称</td></tr><tr><td align="center">-m</td><td align="left">使用监视模式</td></tr><tr><td align="center">-n</td><td align="left">测试模式，只读取指令，而不实际执行</td></tr><tr><td align="center">-p</td><td align="left">启动优先顺序模式</td></tr><tr><td align="center">-P</td><td align="left">启动-P参数后，执行指令时，会以实际的文件或目录来取代符号连接</td></tr><tr><td align="center">-t</td><td align="left">执行完随后的指令，即退出shell</td></tr><tr><td align="center">-u</td><td align="left">当执行时使用到未定义过的变量，则显示错误信息</td></tr><tr><td align="center">-v</td><td align="left">显示shell所读取的输入值</td></tr><tr><td align="center">-H shell</td><td align="left">可利用”!”加&lt;指令编号&gt;的方式来执行 history 中记录的指令</td></tr><tr><td align="center"><strong>-x</strong></td><td align="left">执行指令后，会先显示该指令及所下的参数</td></tr><tr><td align="center">+&lt;参数&gt;</td><td align="left">取消某个set曾启动的参数。与-&lt;参数&gt;相反</td></tr><tr><td align="center">-o option</td><td align="left">特殊属性有很多，大部分与上面的可选参数功能相同，这里就不列了</td></tr></tbody></table><hr><h4 id="重点参数"><a href="#重点参数" class="headerlink" title="重点参数"></a>重点参数</h4><p>最常用的两个参数就是 <strong>-e</strong> 与 <strong>-x</strong> ，一般写在 shell 代码逻辑之前，这两个组合在一起用，可以在 debug 的时候替你节省许多时间 。</p><ul><li><p><code>set -x</code> 会在执行每一行 shell 脚本时，把执行的内容输出来。它可以让你看到当前执行的情况，里面涉及的变量也会被替换成实际的值。 </p></li><li><p><code>set -e</code> 会在执行出错时结束程序，就像其他语言中的“抛出异常”一样。（准确说，不是所有出错的时候都会结束程序，见下面的注） </p><blockquote><p>注：set -e结束程序的条件比较复杂，在man bash里面，足足用了一段话描述各种情景。大多数执行都会在出错时退出，除非 shell 命令位于以下情况：</p><ol><li>一个 pipeline 的非结尾部分，比如error | ok</li><li>一个组合语句的非结尾部分，比如ok &amp;&amp; error || other</li><li>一连串语句的非结尾部分，比如error; ok</li><li>位于判断语句内，包括test、if、while等等。</li></ol></blockquote></li></ul><hr><h4 id="其他用法"><a href="#其他用法" class="headerlink" title="其他用法"></a>其他用法</h4><ul><li><p><strong>set：初始化位置参数</strong></p><p>调用 set 是接一个或多个参数时，set 会把参数的值赋予位置参数，从 $1 开始赋值。如下例子：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ cat set-it.sh</span><br><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">set first second third</span><br><span class="line">echo $3 $2 $1</span><br><span class="line"></span><br><span class="line">$ .&#x2F;set-it.sh</span><br><span class="line">third second first</span><br></pre></td></tr></table></figure><p>如上，在执行 <code>set-it.sh</code> 脚本时并没有输入参数，但是使用 set 指令后会对位置参数进行赋值。</p></li><li><p><strong>set：显示 shell 变量</strong></p><p>如果不带任何参数的使用 set 命令，set 指令就会显示一列已设置的 shell 变量，包括用户定义的变量和关键字变量。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ set </span><br><span class="line">BASH_VERSION&#x3D;&#39;4.2.24(1)-release&#39;</span><br><span class="line">COLORS&#x3D;&#x2F;etc&#x2F;DIR_COLORS</span><br><span class="line">MAIL&#x3D;&#x2F;var&#x2F;spool&#x2F;mail&#x2F;username</span><br><span class="line">...</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> set </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hyperledger Fabric 多机环境部署</title>
      <link href="2018/09/12/Fabric%E5%A4%9A%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
      <url>2018/09/12/Fabric%E5%A4%9A%E6%9C%BA%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要基于 Hyperledger Fabric v1.0 的<a href="https://cao0507.github.io/2018/08/26/Fabric%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/">单机环境部署文档</a>来搭建多机环境。其中对于Fabric 的基础环境的配置都是一样的，也就是前 6 步都是一样的。配置好基础环境之后将配置好的虚拟机镜像复制 4 份，作为其他节点的镜像，该环境包括 5 个节点，是 4 Peer + 1 Orderer的架构，如下表：</p><a id="more"></a><table><thead><tr><th align="center">主机名</th><th align="center">IP地址</th></tr></thead><tbody><tr><td align="center">orderer.example.com</td><td align="center">192.168.1.130</td></tr><tr><td align="center">peer0.org1.example.com</td><td align="center">192.168.1.188</td></tr><tr><td align="center">peer1.org1.example.com</td><td align="center">192.168.1.186</td></tr><tr><td align="center">peer0.org2.example.com</td><td align="center">192.168.1.193</td></tr><tr><td align="center">peer1.org2.example.com</td><td align="center">192.168.1.112</td></tr></tbody></table><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><h3 id="1-更换-apt-源"><a href="#1-更换-apt-源" class="headerlink" title="1. 更换 apt 源"></a>1. 更换 apt 源</h3><p>先备份 sources.list 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak</span><br></pre></td></tr></table></figure><p>再修改 sources.list 文件，换成阿里云的国内源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security multiverse</span><br></pre></td></tr></table></figure><p>最后更新一下源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="2-安装-curl"><a href="#2-安装-curl" class="headerlink" title="2. 安装 curl"></a>2. 安装 curl</h3><p>Ubuntu 16.04 一般默认是安装了 curl 的，可以通过以下命令验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -V</span><br><span class="line">curl 7.47.0 (x86_64-pc-linux-gnu) libcurl&#x2F;7.47.0 GnuTLS&#x2F;3.4.10 zlib&#x2F;1.2.8 libidn&#x2F;1.32 librtmp&#x2F;2.3</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp </span><br><span class="line">Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP UnixSockets</span><br></pre></td></tr></table></figure><p>如果没有安装，则通过 apt-get 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install curl</span><br></pre></td></tr></table></figure><h3 id="3-安装-Docker"><a href="#3-安装-Docker" class="headerlink" title="3. 安装 Docker"></a>3. 安装 Docker</h3><ul><li><p>由于 apt 源使用HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>为了确认所下载软件包的合法性，需要添加软件源的 GPG 秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>然后，我们需要向 sources.list 中添加 Docker 软件源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的Docker CE apt 镜像源。</p></blockquote></li><li><p>更新 apt 软件包缓存，并安装 docker-ce：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker -v</span><br><span class="line">Docker version 18.06.0-ce, build 0ffa825</span><br></pre></td></tr></table></figure><p>满足官方文档中 <em>Docker version 17.06.2-ce or greater is required</em> 的要求。</p></li><li><p>启动 Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>建立 docker 用户组</p><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><blockquote><p>其实一般按照上面的方法安装 Docker 后就已经创建好 docker 用户组了，可以使用 <code>$ cat /etc/group | grep docker</code> 命令来验证，所以就不需要再建立 docker 用户组了，再建立也会报错提示用户组已存在的。</p></blockquote></li><li><p>将当前用户加入 docker 用户组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><blockquote><p>下次登录时即可方便的使用 docker 命令。</p></blockquote></li><li><p>测试 Docker 是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">9db2ca6ccae0: Pull complete </span><br><span class="line">Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdc</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;hub.docker.com&#x2F;</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;userguide&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速器</p><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： </p><ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror">Docker 官方提供的中国 registry mirror <code>https://registry.docker-cn.com</code></a> </li><li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror">七牛云加速器 <code>https://reg-mirror.qiniu.com/</code></a> </li></ul><blockquote><p>当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。</p><p>国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</p></blockquote><p>我们以 Docker 官方加速器 <code>https://registry.docker-cn.com</code> 为例进行介绍。 </p><p>在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在则创建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重新启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="4-安装-Docker-Compose"><a href="#4-安装-Docker-Compose" class="headerlink" title="4. 安装 Docker Compose"></a>4. 安装 Docker Compose</h3></li><li><p>通过二进制包来安装，从 <a href="https://github.com/docker/compose/releases">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.22.0&#x2F;docker-compose-$(uname -s)-$(uname -m) -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker compose 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure><blockquote><p>满足官方文档中 <em>Docker Compose version 1.14.0 or greater</em>  的要求。</p></blockquote></li></ul><h3 id="5-安装-Go-语言环境"><a href="#5-安装-Go-语言环境" class="headerlink" title="5. 安装 Go 语言环境"></a>5. 安装 Go 语言环境</h3><p>Hyperledger Fabric 在很多组件中使用了 Go 语言，并且 <code>Hyperledger fabric 1.2.0</code> 要求使用的是 <code>GO version 1.10.x</code> ，所以需要在我们的环境中安装对应的 Go 语言。</p><ul><li><p>从官网下载 <code>1.10.x</code> 版本的 Linux 平台的源码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.10.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压到指定目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar zxvf go1.10.3.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>先创建 Go 的工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~&#x2F;go</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~&#x2F;.bashrc</span><br><span class="line">添加</span><br><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go</span><br><span class="line">export GOPATH&#x3D;&#x2F;home&#x2F;user1&#x2F;go</span><br><span class="line">export PATH&#x3D;$PATH:$GOROOT&#x2F;bin:$GOPATH&#x2F;bin</span><br></pre></td></tr></table></figure><p>保存并使生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li><li><p>测试 Go 的 demo 程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;go</span><br><span class="line"></span><br><span class="line">$ vi hello.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;hello world\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ go build hello.go</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">hello  hello.go</span><br><span class="line"></span><br><span class="line">$ .&#x2F;hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="6-Fabric-源码下载"><a href="#6-Fabric-源码下载" class="headerlink" title="6. Fabric 源码下载"></a>6. Fabric 源码下载</h3></li><li><p>首先创建存放源码的文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger</span><br></pre></td></tr></table></figure></li><li><p>使用 Git 下载完整源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric.git</span><br></pre></td></tr></table></figure></li><li><p>进入 fabric 目录查看版本分支并切换分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd fabric</span><br><span class="line">$ git branch</span><br><span class="line">* release-1.2</span><br><span class="line">$ git checkout v1.0.0</span><br></pre></td></tr></table></figure></li><li><p>最后再解决 <code>examples/e2e_cli/base/peer-base.yaml</code> 文件中的一个小 bug：</p><p>将 <code>CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE</code> 环境变量的值修改为 <code>e2e_cli_default</code>，而不是原来的 <code>e2ecli_default</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">- CORE_VM_DOCKER_HOSTCONFIG_NETWORKMODE&#x3D;e2e_cli_default</span><br></pre></td></tr></table></figure><p>不然在启动 Fabric 网络时会出现问题。</p></li></ul><h3 id="7-启动其他节点"><a href="#7-启动其他节点" class="headerlink" title="7. 启动其他节点"></a>7. 启动其他节点</h3><p>将刚才配置好的虚拟机镜像拷贝四份，并基于这些镜像启动 5 台虚拟机，主机名分别设置为：</p><ul><li><code>orderer.example.com</code> </li><li><code>peer0.org1.example.com</code> </li><li><code>peer1.org1.example.com</code> </li><li><code>peer0.org2.example.com</code> </li><li><code>peer1.org2.example.com</code> </li></ul><h3 id="8-docker-compose-配置文件准备"><a href="#8-docker-compose-配置文件准备" class="headerlink" title="8. docker-compose 配置文件准备"></a>8. docker-compose 配置文件准备</h3><p>在 fabric 的源码中，提供了单机部署的 4 Peer+1 Orderer的示例，在 example/e2e_cli 文件夹下。我们将登录到 <code>orderer.example.com</code> 节点，生成公私钥，修改 docker-compose 配置文件，然后将 e2e_cli 整个文件夹分发到 Peer 节点，再分别登录到不同的 Peer 节点完成少部分的个性化配置工作。</p><h4 id="8-1-生成公私钥、证书、创世区块等"><a href="#8-1-生成公私钥、证书、创世区块等" class="headerlink" title="8.1 生成公私钥、证书、创世区块等"></a>8.1 生成公私钥、证书、创世区块等</h4><p>公私钥和证书是用于 Server 和 Server 之间的安全通信，另外要创建 Channel 并让其他节点加入 Channel 就需要创世区块，这些必备文件都可以一个命令生成，官方已经给出了脚本： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;generateArtifacts.sh mychannel</span><br></pre></td></tr></table></figure><p>运行这个命令后，系统会创建 channel-artifacts 文件夹，里面包含了 mychannel 这个通道相关的文件，另外还有一个 crypto-config 文件夹，里面包含了各个节点的公私钥和证书的信息。 </p><h4 id="8-2-设置-Peer-节点的-docker-compose-文件"><a href="#8-2-设置-Peer-节点的-docker-compose-文件" class="headerlink" title="8.2 设置 Peer 节点的 docker-compose 文件"></a>8.2 设置 Peer 节点的 docker-compose 文件</h4><p>e2e_cli 中提供了多个yaml文件，我们可以基于docker-compose-cli.yaml文件创建： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp docker-compose-cli.yaml docker-compose-peer.yaml</span><br></pre></td></tr></table></figure><p>然后修改 docker-compose-peer.yaml，去掉 orderer 的配置，只保留一个 peer 和 cli，因为我们要多机部署，节点与节点之前又是通过主机名通讯，所以需要修改容器中的host文件，也就是 extra_hosts 设置，修改后的peer配置如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">peer0.org1.example.com:</span><br><span class="line">  container_name: peer0.org1.example.com</span><br><span class="line">  extends:</span><br><span class="line">    file:  base&#x2F;docker-compose-base.yaml</span><br><span class="line">    service: peer0.org1.example.com</span><br><span class="line">  extra_hosts:</span><br><span class="line">   - &quot;orderer.example.com:192.168.1.130&quot;</span><br></pre></td></tr></table></figure><p>同样，cli也需要能够和各个节点通讯，所以cli下面也需要添加 extra_hosts 设置，去掉无效的依赖，并且去掉command 这一行，因为我们是每个 peer 都会有个对应的客户端，也就是 cli，所以我只需要去手动执行一次命令，而不是自动运行。修改后的cli配置如下： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">cli:</span><br><span class="line">  container_name: cli</span><br><span class="line">  image: hyperledger&#x2F;fabric-tools</span><br><span class="line">  tty: true</span><br><span class="line">  environment:</span><br><span class="line">    - GOPATH&#x3D;&#x2F;opt&#x2F;gopath</span><br><span class="line">    - CORE_VM_ENDPOINT&#x3D;unix:&#x2F;&#x2F;&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">    - CORE_LOGGING_LEVEL&#x3D;DEBUG</span><br><span class="line">    - CORE_PEER_ID&#x3D;cli</span><br><span class="line">    - CORE_PEER_ADDRESS&#x3D;peer0.org1.example.com:7051</span><br><span class="line">    - CORE_PEER_LOCALMSPID&#x3D;Org1MSP</span><br><span class="line">    - CORE_PEER_TLS_ENABLED&#x3D;true</span><br><span class="line">    - CORE_PEER_TLS_CERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;server.crt</span><br><span class="line">    - CORE_PEER_TLS_KEY_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;server.key</span><br><span class="line">    - CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;ca.crt</span><br><span class="line">    - CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp</span><br><span class="line">  working_dir: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer</span><br><span class="line">  volumes:</span><br><span class="line">      - &#x2F;var&#x2F;run&#x2F;:&#x2F;host&#x2F;var&#x2F;run&#x2F;</span><br><span class="line">      - ..&#x2F;chaincode&#x2F;go&#x2F;:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;examples&#x2F;chaincode&#x2F;go</span><br><span class="line">      - .&#x2F;crypto-config:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;</span><br><span class="line">      - .&#x2F;scripts:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;scripts&#x2F;</span><br><span class="line">      - .&#x2F;channel-artifacts:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;channel-artifacts</span><br><span class="line">  depends_on:</span><br><span class="line">    - peer0.org1.example.com</span><br><span class="line">  extra_hosts:</span><br><span class="line">   - &quot;orderer.example.com:192.168.1.130&quot;</span><br><span class="line">   - &quot;peer0.org1.example.com:192.168.1.188&quot;</span><br><span class="line">   - &quot;peer1.org1.example.com:192.168.1.186&quot;</span><br><span class="line">   - &quot;peer0.org2.example.com:192.168.1.193&quot;</span><br><span class="line">   - &quot;peer1.org2.example.com:192.168.1.112&quot;</span><br></pre></td></tr></table></figure><p>在单机模式下，4个peer会映射主机不同的端口，但是我们在多机部署的时候是不需要映射不同端口的，所以需要修改 base/docker-compose-base.yaml 文件，将所有 peer 的端口映射都改为相同的： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ports: </span><br><span class="line">  - 7051:7051 </span><br><span class="line">  - 7052:7052 </span><br><span class="line">  - 7053:7053</span><br></pre></td></tr></table></figure><h4 id="8-3-设置-Orderer-节点的-docker-compose-文件"><a href="#8-3-设置-Orderer-节点的-docker-compose-文件" class="headerlink" title="8.3 设置 Orderer 节点的 docker-compose 文件"></a>8.3 设置 Orderer 节点的 docker-compose 文件</h4><p>与创建peer的配置文件类似，我们也复制一个yaml文件出来进行修改： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ cp docker-compose-cli.yaml docker-compose-orderer.yaml</span><br></pre></td></tr></table></figure><p>orderer 服务器上我们只需要保留 order 设置，其他 peer 和 cli 设置都可以删除。orderer 可以不设置 extra_hosts。 </p><h4 id="8-4-分发配置文件"><a href="#8-4-分发配置文件" class="headerlink" title="8.4 分发配置文件"></a>8.4 分发配置文件</h4><p>前面 3 步操作，都是在 <code>orderer.example.com</code>上完成的，接下来我们需要将这些文件分发到另外4台服务器上。Linux 之间的文件传输，我们可以使用 scp 命令。 peer 节点上已经存在了 e2e_cli 文件夹，使用 scp 命令发送时会直接覆盖。在 <code>orderer.example.com</code> 节点的 fabric 的根目录下的 examples 目录下执行以下命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ scp -r e2e_cli&#x2F; user1@192.168.1.188:&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;examples</span><br><span class="line">$ scp -r e2e_cli&#x2F; user1@192.168.1.186:&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;examples</span><br><span class="line">$ scp -r e2e_cli&#x2F; user1@192.168.1.193:&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;examples</span><br><span class="line">$ scp -r e2e_cli&#x2F; user1@192.168.1.112:&#x2F;home&#x2F;user1&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;examples</span><br></pre></td></tr></table></figure><h4 id="8-5-Peer-节点的个性化配置"><a href="#8-5-Peer-节点的个性化配置" class="headerlink" title="8.5 Peer 节点的个性化配置"></a>8.5 Peer 节点的个性化配置</h4><p>因为之前配置的就是<code>peer0.org1.example.com</code> 节点，所以复制到<code>peer0.org1.example.com</code> 后不需要做任何修改。</p><p>复制到 <code>peer1.org1.example.com</code> 上，我们需要对 docker-compose-peer.yaml 做一个小小的修改，将启动的容器改为 <code>peer1.org1.example.com</code>，并且添加 <code>peer0.org1.example.com</code> 的 IP 映射，对应的 cli 中也改成对 <code>peer1.org1.example.com</code> 的依赖。这是修改后的 <code>peer1.org1.example.com</code> 上的配置文件： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">version: &#39;2&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  peer1.org1.example.com:</span><br><span class="line">    container_name: peer1.org1.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base&#x2F;docker-compose-base.yaml</span><br><span class="line">      service: peer1.org1.example.com</span><br><span class="line">    extra_hosts:</span><br><span class="line">     - &quot;orderer.example.com:192.168.1.130&quot;</span><br><span class="line">     - &quot;peer0.org1.example.com:192.168.1.188&quot;</span><br><span class="line"></span><br><span class="line">  cli:</span><br><span class="line">    container_name: cli</span><br><span class="line">    image: hyperledger&#x2F;fabric-tools</span><br><span class="line">    tty: true</span><br><span class="line">    environment:</span><br><span class="line">      - GOPATH&#x3D;&#x2F;opt&#x2F;gopath</span><br><span class="line">      - CORE_VM_ENDPOINT&#x3D;unix:&#x2F;&#x2F;&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">      - CORE_LOGGING_LEVEL&#x3D;DEBUG</span><br><span class="line">      - CORE_PEER_ID&#x3D;cli</span><br><span class="line">      - CORE_PEER_ADDRESS&#x3D;peer1.org1.example.com:7051</span><br><span class="line">      - CORE_PEER_LOCALMSPID&#x3D;Org1MSP</span><br><span class="line">      - CORE_PEER_TLS_ENABLED&#x3D;true</span><br><span class="line">      - CORE_PEER_TLS_CERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer1.org1.example.com&#x2F;tls&#x2F;server.crt</span><br><span class="line">      - CORE_PEER_TLS_KEY_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer1.org1.example.com&#x2F;tls&#x2F;server.key</span><br><span class="line">      - CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer1.org1.example.com&#x2F;tls&#x2F;ca.crt</span><br><span class="line">      - CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp</span><br><span class="line">    working_dir: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer</span><br><span class="line">    volumes:</span><br><span class="line">        - &#x2F;var&#x2F;run&#x2F;:&#x2F;host&#x2F;var&#x2F;run&#x2F;</span><br><span class="line">        - ..&#x2F;chaincode&#x2F;go&#x2F;:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;examples&#x2F;chaincode&#x2F;go</span><br><span class="line">        - .&#x2F;crypto-config:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;</span><br><span class="line">        - .&#x2F;scripts:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;scripts&#x2F;</span><br><span class="line">        - .&#x2F;channel-artifacts:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;channel-artifacts</span><br><span class="line">    depends_on:</span><br><span class="line">      - peer1.org1.example.com</span><br><span class="line">    extra_hosts:</span><br><span class="line">     - &quot;orderer.example.com:192.168.1.130&quot;</span><br><span class="line">     - &quot;peer0.org1.example.com:192.168.1.188&quot;</span><br><span class="line">     - &quot;peer1.org1.example.com:192.168.1.186&quot;</span><br><span class="line">     - &quot;peer0.org2.example.com:192.168.1.193&quot;</span><br><span class="line">     - &quot;peer1.org2.example.com:192.168.1.112&quot;</span><br></pre></td></tr></table></figure><p><code>peer0.org2.example.com</code> 和 <code>peer0.org2.example.com</code>  节点上面的 docker-compose-peer.yaml 也是同理修改。</p><blockquote><p>注意需要修改组织相关的信息。</p></blockquote><hr><h3 id="9-启动-Fabric"><a href="#9-启动-Fabric" class="headerlink" title="9. 启动 Fabric"></a>9. 启动 Fabric</h3><p>现在所有文件都已经准备完毕，我们可以启动我们的Fabric网络了。 </p><h4 id="9-1-启动-Orderer"><a href="#9-1-启动-Orderer" class="headerlink" title="9.1 启动 Orderer"></a>9.1 启动 Orderer</h4><p>让我们首先来启动orderer节点，在orderer服务器上运行： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f docker-compose-orderer.yaml up –d</span><br></pre></td></tr></table></figure><p>运行完毕后我们可以使用 <code>docker ps</code> 看到运行了一个名字为 <code>orderer.example.com</code> 的节点。 </p><h4 id="9-2-启动-peer"><a href="#9-2-启动-peer" class="headerlink" title="9.2 启动 peer"></a>9.2 启动 peer</h4><p>然后我们切换到 <code>peer0.org1.example.com</code> 服务器，启动本服务器的 peer 节点和 cli，命令为： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose -f docker-compose-peer.yaml up –d</span><br></pre></td></tr></table></figure><p>运行完毕后我们使用docker ps应该可以看到2个正在运行的容器。 </p><p>接下来依次在另外 3 台服务器运行启动peer节点容器的命令。</p><p>现在我们整个Fabric4+1服务器网络已经成型，接下来是创建channel和运行ChainCode。 </p><h4 id="9-3-创建-Channel-测试-Chaincode"><a href="#9-3-创建-Channel-测试-Chaincode" class="headerlink" title="9.3 创建 Channel 测试 Chaincode"></a>9.3 创建 Channel 测试 Chaincode</h4><p>我们切换到 <code>peer0.org1.example.com</code> 服务器上，使用该服务器上的 cli 来运行创建 Channel 和运行 ChainCode 的操作。首先进入cli 容器： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ docker exec -it cli bash</span><br></pre></td></tr></table></figure><p>进入容器后我们可以看到命令提示变为： </p><p><u>root@ad739321be2a:/opt/gopath/src/github.com/hyperledger/fabric/peer#</u></p><p>说明我们已经以 root 的身份进入到 cli 容器内部。官方已经提供了完整的创建 Channel 和测试 ChainCode 的脚本，并且已经映射到 cli 容器内部，所以我们只需要在 cli 内运行如下命令： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">.&#x2F;scripts&#x2F;script.sh mychannel</span><br></pre></td></tr></table></figure><p>那么该脚本就可以一步一步的完成创建通道，将其他节点加入通道，更新锚节点，创建 ChainCode，初始化账户，查询，转账，再次查询等链上代码的各个操作都可以自动化实现。直到最后，系统提示： </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; All GOOD, End-2-End execution completed &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p>说明我们的 4+1 的 Fabric 多机部署成功了。 </p><hr>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> Docker </tag>
            
            <tag> Docker Compose </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Fabric e2e_cli 案例流程分析</title>
      <link href="2018/08/30/Fabric%E6%A1%88%E4%BE%8B%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/"/>
      <url>2018/08/30/Fabric%E6%A1%88%E4%BE%8B%E6%B5%81%E7%A8%8B%E5%88%86%E6%9E%90/</url>
      
        <content type="html"><![CDATA[<h1 id="0-Fabric-e2e-cli-案例的运行流程"><a href="#0-Fabric-e2e-cli-案例的运行流程" class="headerlink" title="0. Fabric e2e_cli 案例的运行流程"></a>0. Fabric e2e_cli 案例的运行流程</h1><p>在部署好 Hyperledger Fabric v1.0.0 的环境之后，我们通常会运行其 e2e_cli 的案例。在 <code>fabric/examples/e2e_cli</code> 目录下有一个 shell 脚本：<code>network_setup.sh</code>，这就是 e2e_cli 项目的入口，运行 <code>./network_setup.sh up</code> 即可启动 fabric 的网络并完成相关的测试，然后运行 <code>./network_setup.sh down</code> 可以删除相关的容器以及文件来结束测试。下面我们就来分析 e2e_cli 案例的运行流程。</p><a id="more"></a><p>首先看看 network_setup.sh 的具体内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash</span><br><span class="line">#</span><br><span class="line"># Copyright IBM Corp. All Rights Reserved.</span><br><span class="line">#</span><br><span class="line"># SPDX-License-Identifier: Apache-2.0</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">UP_DOWN&#x3D;&quot;$1&quot;</span><br><span class="line">CH_NAME&#x3D;&quot;$2&quot;</span><br><span class="line">CLI_TIMEOUT&#x3D;&quot;$3&quot;</span><br><span class="line">IF_COUCHDB&#x3D;&quot;$4&quot;</span><br><span class="line"></span><br><span class="line">: $&#123;CLI_TIMEOUT:&#x3D;&quot;10000&quot;&#125;</span><br><span class="line"></span><br><span class="line">COMPOSE_FILE&#x3D;docker-compose-cli.yaml</span><br><span class="line">COMPOSE_FILE_COUCH&#x3D;docker-compose-couch.yaml</span><br><span class="line">#COMPOSE_FILE&#x3D;docker-compose-e2e.yaml</span><br><span class="line"></span><br><span class="line">function printHelp () &#123;</span><br><span class="line">echo &quot;Usage: .&#x2F;network_setup &lt;up|down&gt; &lt;\$channel-name&gt; &lt;\$cli_timeout&gt; &lt;couchdb&gt;.\nThe arguments must be in order.&quot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function validateArgs () &#123;</span><br><span class="line">if [ -z &quot;$&#123;UP_DOWN&#125;&quot; ]; then</span><br><span class="line">echo &quot;Option up &#x2F; down &#x2F; restart not mentioned&quot;</span><br><span class="line">printHelp</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br><span class="line">if [ -z &quot;$&#123;CH_NAME&#125;&quot; ]; then</span><br><span class="line">echo &quot;setting to default channel &#39;mychannel&#39;&quot;</span><br><span class="line">CH_NAME&#x3D;mychannel</span><br><span class="line">fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function clearContainers () &#123;</span><br><span class="line">        CONTAINER_IDS&#x3D;$(docker ps -aq)</span><br><span class="line">        if [ -z &quot;$CONTAINER_IDS&quot; -o &quot;$CONTAINER_IDS&quot; &#x3D; &quot; &quot; ]; then</span><br><span class="line">                echo &quot;---- No containers available for deletion ----&quot;</span><br><span class="line">        else</span><br><span class="line">                docker rm -f $CONTAINER_IDS</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeUnwantedImages() &#123;</span><br><span class="line">        DOCKER_IMAGE_IDS&#x3D;$(docker images | grep &quot;dev\|none\|test-vp\|peer[0-9]-&quot; | awk &#39;&#123;print $3&#125;&#39;)</span><br><span class="line">        if [ -z &quot;$DOCKER_IMAGE_IDS&quot; -o &quot;$DOCKER_IMAGE_IDS&quot; &#x3D; &quot; &quot; ]; then</span><br><span class="line">                echo &quot;---- No images available for deletion ----&quot;</span><br><span class="line">        else</span><br><span class="line">                docker rmi -f $DOCKER_IMAGE_IDS</span><br><span class="line">        fi</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function networkUp () &#123;</span><br><span class="line">    if [ -f &quot;.&#x2F;crypto-config&quot; ]; then</span><br><span class="line">      echo &quot;crypto-config directory already exists.&quot;</span><br><span class="line">    else</span><br><span class="line">      #Generate all the artifacts that includes org certs, orderer genesis block,</span><br><span class="line">      # channel configuration transaction</span><br><span class="line">      source generateArtifacts.sh $CH_NAME</span><br><span class="line">    fi</span><br><span class="line"></span><br><span class="line">    if [ &quot;$&#123;IF_COUCHDB&#125;&quot; &#x3D;&#x3D; &quot;couchdb&quot; ]; then</span><br><span class="line">      CHANNEL_NAME&#x3D;$CH_NAME TIMEOUT&#x3D;$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE -f $COMPOSE_FILE_COUCH up -d 2&gt;&amp;1</span><br><span class="line">    else</span><br><span class="line">      CHANNEL_NAME&#x3D;$CH_NAME TIMEOUT&#x3D;$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE up -d 2&gt;&amp;1</span><br><span class="line">    fi</span><br><span class="line">    if [ $? -ne 0 ]; then</span><br><span class="line">echo &quot;ERROR !!!! Unable to pull the images &quot;</span><br><span class="line">exit 1</span><br><span class="line">    fi</span><br><span class="line">    docker logs -f cli</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function networkDown () &#123;</span><br><span class="line">    docker-compose -f $COMPOSE_FILE down</span><br><span class="line"></span><br><span class="line">    #Cleanup the chaincode containers</span><br><span class="line">    clearContainers</span><br><span class="line"></span><br><span class="line">    #Cleanup images</span><br><span class="line">    removeUnwantedImages</span><br><span class="line"></span><br><span class="line">    # remove orderer block and other channel configuration transactions and certs</span><br><span class="line">    rm -rf channel-artifacts&#x2F;*.block channel-artifacts&#x2F;*.tx crypto-config</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">validateArgs</span><br><span class="line"></span><br><span class="line">#Create the network using docker compose</span><br><span class="line">if [ &quot;$&#123;UP_DOWN&#125;&quot; &#x3D;&#x3D; &quot;up&quot; ]; then</span><br><span class="line">networkUp</span><br><span class="line">elif [ &quot;$&#123;UP_DOWN&#125;&quot; &#x3D;&#x3D; &quot;down&quot; ]; then ## Clear the network</span><br><span class="line">networkDown</span><br><span class="line">elif [ &quot;$&#123;UP_DOWN&#125;&quot; &#x3D;&#x3D; &quot;restart&quot; ]; then ## Restart the network</span><br><span class="line">networkDown</span><br><span class="line">networkUp</span><br><span class="line">else</span><br><span class="line">printHelp</span><br><span class="line">exit 1</span><br><span class="line">fi</span><br></pre></td></tr></table></figure><hr><h1 id="1-启动过程"><a href="#1-启动过程" class="headerlink" title="1. 启动过程"></a>1. 启动过程</h1><h2 id="1-1-network-setup-sh-参数设置"><a href="#1-1-network-setup-sh-参数设置" class="headerlink" title="1.1  network_setup.sh 参数设置"></a>1.1  network_setup.sh 参数设置</h2><ol><li><p>传入参数</p><p>在运行 <code>./network_setup.sh up</code> 启动的时候，我们传入了 <code>up</code> 这个参数，使得内置的 <strong>UP_DOWN</strong> 参数设置成了 up，也就是确定执行类型为启动 fabric 网络，但其实该脚本还允许传入 3 个参数，分别是 <strong>CH_NAME</strong>（通道名称，默认设为 ”mychannel“）、<strong>CLI_TIMEOUT</strong>（客户端超时设置，默认设为 10000）和 <strong>IF_COUCHDB</strong>（是否启动 CouchDB 版本 yaml 文件，默认为不启用）。</p></li><li><p>验证参数：<strong>validateArgs</strong></p><p>在 <code>network_setup.sh</code> 脚本 88 行左右，调用了 <code>validateArgs</code> 函数来验证参数是否合法，如果不合法，也就是没有指定 <code>up/down/restart</code>，会打印帮助信息并退出脚本；如果合法，<code>$UP_DOWN</code> 设置合法，则判断是否指定 <code>$CH_NAME</code>，没有指定则设置为默认的 <code>mychannel</code>。</p></li></ol><hr><h2 id="1-2-启动网络：networkUp"><a href="#1-2-启动网络：networkUp" class="headerlink" title="1.2 启动网络：networkUp"></a>1.2 启动网络：networkUp</h2><ol><li><p>判断 crypto-config 目录是否存在</p><p>如果该目录不存在，会调用 generateArtifacts.sh 脚本创建 crypto-config 目录及所需的区块链网络整数等文件，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source generateArtifacts.sh $CH_NAME</span><br></pre></td></tr></table></figure><blockquote><p>详细请看 1.3 节</p></blockquote></li><li><p>判断是否启用 CouchDB</p><p>如果启用了 CouchDB，会执行以下 docker-compose 命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL_NAME&#x3D;$CH_NAME TIMEOUT&#x3D;$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE -f $COMPOSE_FILE_COUCH up -d 2&gt;&amp;1</span><br></pre></td></tr></table></figure><p>否则执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL_NAME&#x3D;$CH_NAME TIMEOUT&#x3D;$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE up -d 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p>详细请看 1.4 节</p></blockquote><p>最后会查看 cli 容器的日志：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker logs -f cli</span><br></pre></td></tr></table></figure><blockquote><p>详细请看 1.5 节</p></blockquote></li></ol><hr><h2 id="1-3-调用-generateArtifacts-sh"><a href="#1-3-调用-generateArtifacts-sh" class="headerlink" title="1.3 调用 generateArtifacts.sh"></a>1.3 调用 generateArtifacts.sh</h2><p>先看看 generateArtifacts.sh 脚本的内容：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;bin&#x2F;bash +x</span><br><span class="line">#</span><br><span class="line"># Copyright IBM Corp. All Rights Reserved.</span><br><span class="line">#</span><br><span class="line"># SPDX-License-Identifier: Apache-2.0</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">#set -e</span><br><span class="line"></span><br><span class="line">CHANNEL_NAME&#x3D;$1</span><br><span class="line">: $&#123;CHANNEL_NAME:&#x3D;&quot;mychannel&quot;&#125;</span><br><span class="line">echo $CHANNEL_NAME</span><br><span class="line"></span><br><span class="line">export FABRIC_ROOT&#x3D;$PWD&#x2F;..&#x2F;..</span><br><span class="line">export FABRIC_CFG_PATH&#x3D;$PWD</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">OS_ARCH&#x3D;$(echo &quot;$(uname -s|tr &#39;[:upper:]&#39; &#39;[:lower:]&#39;|sed &#39;s&#x2F;mingw64_nt.*&#x2F;windows&#x2F;&#39;)-$(uname -m | sed &#39;s&#x2F;x86_64&#x2F;amd64&#x2F;g&#39;)&quot; | awk &#39;&#123;print tolower($0)&#125;&#39;)</span><br><span class="line"></span><br><span class="line">## Using docker-compose template replace private key file names with constants</span><br><span class="line">function replacePrivateKey () &#123;</span><br><span class="line">ARCH&#x3D;&#96;uname -s | grep Darwin&#96;</span><br><span class="line">if [ &quot;$ARCH&quot; &#x3D;&#x3D; &quot;Darwin&quot; ]; then</span><br><span class="line">OPTS&#x3D;&quot;-it&quot;</span><br><span class="line">else</span><br><span class="line">OPTS&#x3D;&quot;-i&quot;</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">cp docker-compose-e2e-template.yaml docker-compose-e2e.yaml</span><br><span class="line"></span><br><span class="line">        CURRENT_DIR&#x3D;$PWD</span><br><span class="line">        cd crypto-config&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;ca&#x2F;</span><br><span class="line">        PRIV_KEY&#x3D;$(ls *_sk)</span><br><span class="line">        cd $CURRENT_DIR</span><br><span class="line">        sed $OPTS &quot;s&#x2F;CA1_PRIVATE_KEY&#x2F;$&#123;PRIV_KEY&#125;&#x2F;g&quot; docker-compose-e2e.yaml</span><br><span class="line">        cd crypto-config&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;ca&#x2F;</span><br><span class="line">        PRIV_KEY&#x3D;$(ls *_sk)</span><br><span class="line">        cd $CURRENT_DIR</span><br><span class="line">        sed $OPTS &quot;s&#x2F;CA2_PRIVATE_KEY&#x2F;$&#123;PRIV_KEY&#125;&#x2F;g&quot; docker-compose-e2e.yaml</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## Generates Org certs using cryptogen tool</span><br><span class="line">function generateCerts ()&#123;</span><br><span class="line">CRYPTOGEN&#x3D;$FABRIC_ROOT&#x2F;release&#x2F;$OS_ARCH&#x2F;bin&#x2F;cryptogen</span><br><span class="line"></span><br><span class="line">if [ -f &quot;$CRYPTOGEN&quot; ]; then</span><br><span class="line">            echo &quot;Using cryptogen -&gt; $CRYPTOGEN&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Building cryptogen&quot;</span><br><span class="line">    make -C $FABRIC_ROOT release</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;##########################################################&quot;</span><br><span class="line">echo &quot;##### Generate certificates using cryptogen tool #########&quot;</span><br><span class="line">echo &quot;##########################################################&quot;</span><br><span class="line">$CRYPTOGEN generate --config&#x3D;.&#x2F;crypto-config.yaml</span><br><span class="line">echo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">## Generate orderer genesis block , channel configuration transaction and anchor peer update transactions</span><br><span class="line">function generateChannelArtifacts() &#123;</span><br><span class="line"></span><br><span class="line">CONFIGTXGEN&#x3D;$FABRIC_ROOT&#x2F;release&#x2F;$OS_ARCH&#x2F;bin&#x2F;configtxgen</span><br><span class="line">if [ -f &quot;$CONFIGTXGEN&quot; ]; then</span><br><span class="line">            echo &quot;Using configtxgen -&gt; $CONFIGTXGEN&quot;</span><br><span class="line">else</span><br><span class="line">    echo &quot;Building configtxgen&quot;</span><br><span class="line">    make -C $FABRIC_ROOT release</span><br><span class="line">fi</span><br><span class="line"></span><br><span class="line">echo &quot;##########################################################&quot;</span><br><span class="line">echo &quot;#########  Generating Orderer Genesis block ##############&quot;</span><br><span class="line">echo &quot;##########################################################&quot;</span><br><span class="line"># Note: For some unknown reason (at least for now) the block file can&#39;t be</span><br><span class="line"># named orderer.genesis.block or the orderer will fail to launch!</span><br><span class="line">$CONFIGTXGEN -profile TwoOrgsOrdererGenesis -outputBlock .&#x2F;channel-artifacts&#x2F;genesis.block</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">echo &quot;### Generating channel configuration transaction &#39;channel.tx&#39; ###&quot;</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">$CONFIGTXGEN -profile TwoOrgsChannel -outputCreateChannelTx .&#x2F;channel-artifacts&#x2F;channel.tx -channelID $CHANNEL_NAME</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">echo &quot;#######    Generating anchor peer update for Org1MSP   ##########&quot;</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">$CONFIGTXGEN -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org1MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org1MSP</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">echo &quot;#######    Generating anchor peer update for Org2MSP   ##########&quot;</span><br><span class="line">echo &quot;#################################################################&quot;</span><br><span class="line">$CONFIGTXGEN -profile TwoOrgsChannel -outputAnchorPeersUpdate .&#x2F;channel-artifacts&#x2F;Org2MSPanchors.tx -channelID $CHANNEL_NAME -asOrg Org2MSP</span><br><span class="line">echo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">generateCerts</span><br><span class="line">replacePrivateKey</span><br><span class="line">generateChannelArtifacts</span><br></pre></td></tr></table></figure><p>脚本最后调用了三个函数：</p><ol><li><p><strong>generateCerts</strong></p><p>该函数首先判断 <code>fabric/release/linux-amd64/bin/cryptogen</code> 是否存在，如果不存在则先编译生成，这个是 Fabric 基于 Go 语言的 crypto 库提供的工具，通过 cryptogen 可以快速地根据配置自动批量生成所需要的密钥和证书文件。cryptogen 根据 crypto-config.yaml 文件读入网络的拓扑结构，执行的命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fabric&#x2F;release&#x2F;linux-amd64&#x2F;bin&#x2F;cryptogen generate --config&#x3D;.&#x2F;crypto-config.yaml</span><br></pre></td></tr></table></figure><p>crypto-config.yaml 配置文件可以指定两类组织的信息：</p><ul><li>OrdererOrgs：构成 Orderer 集群的节点所属组织；</li><li>PeerOrgs：构成 Peer 集群的节点所属的组织</li></ul><p>每个组织拥有：</p><ul><li>名称（name）：组织的名称；</li><li>组织域（Domain）：组织的命名域；</li><li>CA：组织的 CA 地址，包括 Hostname 域；</li><li>若干节点（Node）：一个节点包括 Hostname、CommonName、SANS 等域，可以用 Specs 字段指定一组节点，或者用 Template 字段指定自动生成节点的个数；</li><li>用户（User）模板：自动生成除 admin 外的用户个数。</li></ul><p>示例如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">OrdererOrgs:</span><br><span class="line">  - Name: Orderer</span><br><span class="line">    Domain: example.com</span><br><span class="line">    Specs:</span><br><span class="line">      - Hostname: orderer</span><br><span class="line">PeerOrgs:</span><br><span class="line">  - Name: Org1</span><br><span class="line">    Domain: org1.example.com</span><br><span class="line">    Template:</span><br><span class="line">      Count: 2</span><br><span class="line">    Users:</span><br><span class="line">      Count: 1</span><br><span class="line">  - Name: Org2</span><br><span class="line">    Domain: org2.example.com</span><br><span class="line">    Template:</span><br><span class="line">      Count: 2</span><br><span class="line">    Users:</span><br><span class="line">      Count: 1</span><br></pre></td></tr></table></figure><p>上面的示例配置中，Orderer 组织通过 Specs 字段指定了一个主机 order.example.com；而两个 Peer 组织则采用 Template 来自动生成了 Count 个数的主机。</p><p>同样，Users 字段下的 Count 字段值会让 cryptogen 工具以自动顺序生成指定个数的普通用户（除默认的 Admin 用户外）。</p></li><li><p><strong>replacePrivatekey</strong></p><p>在这个函数中，会替换 docker-compose-e2e-template.yaml 文件中的 CA1_PRIVATE_KEY 为当前目录 crypto-config/peerOrganizationsorg1.example.com/ca/ 下的以 <code>_sk</code> 结尾的文件名，同时替换 CA2_PRIVATE_KEY 为当前目录crypto-config/peerOrganizationsorg2.example.com/ca/ 下的以 <code>_sk</code> 结尾的文件名。</p><p>最终生成的新文件被创建在当前文件夹下并命名为 docker-compose-e2e.yaml，在该文件中定义了 CA 的 CERTFILE 及 KEYFILE，同时也通过 command 内置参数显示启动了 Fabric-CA 服务端。</p><blockquote><p>其实在后续的过程中并没有使用这里生成的这个 docker-compose-e2e.yaml 配置文件，而使用的是 docker-compose-cli.yaml，在 network_setup.sh 脚本中的 COMPOSE_FILE 变量指定了要使用的配置文件，代码如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">COMPOSE_FILE&#x3D;docker-compose-cli.yaml</span><br><span class="line">#COMPOSE_FILE&#x3D;docker-compose-e2e.yaml</span><br></pre></td></tr></table></figure></blockquote></li><li><p><strong>generateChannelArtifacts</strong></p><p>这个函数首先判断 <code>fabric/release/linux-amd64/bin/configtxgen</code> 是否存在，如果不存在则先编译生成。configtxgen 可以配合 cryptogen 生成的组织结构身份文件使用，离线生成跟通道有关的配置信息，<strong>其主要功能有如下三个：</strong></p><ul><li>生成启动 Orderer 需要的初始化区块，并支持检查区块内容；</li><li>生成创建应用通道需要的配置交易，并支持检查交易内容；</li><li>生成 2 个锚节点 Peer 的更新配置交易。</li></ul><p>configtxgen 调用的配置文件为 configtx.yaml ，<strong>该配置文件一般包括四个部分：</strong></p><ul><li>Profiles：一系列通道配置模板，包括 Orderer 系统通道模板和应用通道类型模板；</li><li>Organization：一系列组织结构定义，被其他部分引用；</li><li>Orderer：Orderer 系统通道相关配置，包括 Orderer 服务配置和参与 Ordering 服务的可用组织信息；</li><li>Application：应用通道相关配置，主要包括参与应用网络的可用组织信息。</li></ul><p>调用该函数最终在 channel-artifacts 目录下<strong>生成了四个文件</strong>，对应于上述的三个功能：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">channel.tx    genesis.block    Org1MSPanchors.tx    Org2MSPanchors.tx</span><br></pre></td></tr></table></figure></li></ol><hr><h2 id="1-4-docker-compose-启动容器服务"><a href="#1-4-docker-compose-启动容器服务" class="headerlink" title="1.4 docker-compose 启动容器服务"></a>1.4 docker-compose 启动容器服务</h2><p>如 1.2 节所述，默认情况下，会执行以下命令<strong>启动容器服务：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CHANNEL_NAME&#x3D;$CH_NAME TIMEOUT&#x3D;$CLI_TIMEOUT docker-compose -f $COMPOSE_FILE up -d 2&gt;&amp;1</span><br></pre></td></tr></table></figure><blockquote><p>其中变量的值为： CHANNEL_NAME=mychannel，TIMEOUT=10000，COMPOSE_FILE=docker-compose-cli.yaml。</p><p>-d：指定在后台运行容器；</p><p>2&gt;&amp;1：指定同时重定向标准输出（stdout）与标准错误（stderr）</p></blockquote><p>容器启动配置文件 docker-compose-cli.yaml 的内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"># Copyright IBM Corp. All Rights Reserved.</span><br><span class="line">#</span><br><span class="line"># SPDX-License-Identifier: Apache-2.0</span><br><span class="line">#</span><br><span class="line"></span><br><span class="line">version: &#39;2&#39;</span><br><span class="line"></span><br><span class="line">services:</span><br><span class="line"></span><br><span class="line">  orderer.example.com:</span><br><span class="line">    extends:</span><br><span class="line">      file:   base&#x2F;docker-compose-base.yaml</span><br><span class="line">      service: orderer.example.com</span><br><span class="line">    container_name: orderer.example.com</span><br><span class="line"></span><br><span class="line">  peer0.org1.example.com:</span><br><span class="line">    container_name: peer0.org1.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base&#x2F;docker-compose-base.yaml</span><br><span class="line">      service: peer0.org1.example.com</span><br><span class="line"></span><br><span class="line">  peer1.org1.example.com:</span><br><span class="line">    container_name: peer1.org1.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base&#x2F;docker-compose-base.yaml</span><br><span class="line">      service: peer1.org1.example.com</span><br><span class="line"></span><br><span class="line">  peer0.org2.example.com:</span><br><span class="line">    container_name: peer0.org2.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base&#x2F;docker-compose-base.yaml</span><br><span class="line">      service: peer0.org2.example.com</span><br><span class="line"></span><br><span class="line">  peer1.org2.example.com:</span><br><span class="line">    container_name: peer1.org2.example.com</span><br><span class="line">    extends:</span><br><span class="line">      file:  base&#x2F;docker-compose-base.yaml</span><br><span class="line">      service: peer1.org2.example.com</span><br><span class="line"></span><br><span class="line">  cli:</span><br><span class="line">    container_name: cli</span><br><span class="line">    image: hyperledger&#x2F;fabric-tools</span><br><span class="line">    tty: true</span><br><span class="line">    environment:</span><br><span class="line">      - GOPATH&#x3D;&#x2F;opt&#x2F;gopath</span><br><span class="line">      - CORE_VM_ENDPOINT&#x3D;unix:&#x2F;&#x2F;&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">      - CORE_LOGGING_LEVEL&#x3D;DEBUG</span><br><span class="line">      - CORE_PEER_ID&#x3D;cli</span><br><span class="line">      - CORE_PEER_ADDRESS&#x3D;peer0.org1.example.com:7051</span><br><span class="line">      - CORE_PEER_LOCALMSPID&#x3D;Org1MSP</span><br><span class="line">      - CORE_PEER_TLS_ENABLED&#x3D;true</span><br><span class="line">      - CORE_PEER_TLS_CERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;server.crt</span><br><span class="line">      - CORE_PEER_TLS_KEY_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;server.key</span><br><span class="line">      - CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;ca.crt</span><br><span class="line">      - CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;users&#x2F;Admin@org1.example.com&#x2F;msp</span><br><span class="line">    working_dir: &#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer</span><br><span class="line">    command: &#x2F;bin&#x2F;bash -c &#39;.&#x2F;scripts&#x2F;script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#39;</span><br><span class="line">    volumes:</span><br><span class="line">        - &#x2F;var&#x2F;run&#x2F;:&#x2F;host&#x2F;var&#x2F;run&#x2F;</span><br><span class="line">        - ..&#x2F;chaincode&#x2F;go&#x2F;:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;examples&#x2F;chaincode&#x2F;go</span><br><span class="line">        - .&#x2F;crypto-config:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;</span><br><span class="line">        - .&#x2F;scripts:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;scripts&#x2F;</span><br><span class="line">        - .&#x2F;channel-artifacts:&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;channel-artifacts</span><br><span class="line">    depends_on:</span><br><span class="line">      - orderer.example.com</span><br><span class="line">      - peer0.org1.example.com</span><br><span class="line">      - peer1.org1.example.com</span><br><span class="line">      - peer0.org2.example.com</span><br><span class="line">      - peer1.org2.example.com</span><br></pre></td></tr></table></figure><p>从配置文件不难看出，排序服务节点继承了 base/docker-compose-base.yaml 中的 order.example.com 属性；而其他四个 Peer 节点继承了 base/docker-compose-base.yaml 中的与之容器名称对应的属性，并又都继承了 base/peer-base.yaml 中的属性。</p><p>在上述文件所继承的文件属性中，关键属性如下：</p><ul><li>environment：当前所配置的外界的环境变量</li><li>working_dir：当前容器启动后的工作路径</li><li>volumes：外界物理机路径挂载或指引到容器内的路径</li><li>ports：指定当前容器启动后映射到物理机上的端口号</li><li>depends_on：指定当前容器启动所依赖的启动容器对象</li></ul><p>在 docker-compose-cli.yaml 文件中，官方的节点配置信息基本已经满足实际生产应用，而真正使用这些服务节点进行数据维护和管理的则是交由客户端或 SDK 来执行。这里也就是配置文件中的 cli 客户端容器。cli 容器的 command 属性指定当 cli 容器启动后会执行当前目录中的 scripts 目录下的 script.sh 脚本，也就是：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin&#x2F;bash -c &#39;.&#x2F;scripts&#x2F;script.sh $&#123;CHANNEL_NAME&#125;; sleep $TIMEOUT&#39;</span><br></pre></td></tr></table></figure><blockquote><p>在 1.5 节中将会分析 cli 容器执行上述脚本的日志记录。</p></blockquote><hr><h2 id="1-5-docker-logs-f-cli-查看容器日志"><a href="#1-5-docker-logs-f-cli-查看容器日志" class="headerlink" title="1.5 docker logs -f cli 查看容器日志"></a>1.5 docker logs -f cli 查看容器日志</h2><p>script.sh 脚本的执行则是 e2e_cli 中真正地对 Peer 节点、频道以及合约的集合操作演示，先来看看该脚本内的函数执行顺序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">## Create channel</span><br><span class="line">echo &quot;Creating channel...&quot;</span><br><span class="line">createChannel</span><br><span class="line"></span><br><span class="line">## Join all the peers to the channel</span><br><span class="line">echo &quot;Having all peers join the channel...&quot;</span><br><span class="line">joinChannel</span><br><span class="line"></span><br><span class="line">## Set the anchor peers for each org in the channel</span><br><span class="line">echo &quot;Updating anchor peers for org1...&quot;</span><br><span class="line">updateAnchorPeers 0</span><br><span class="line">echo &quot;Updating anchor peers for org2...&quot;</span><br><span class="line">updateAnchorPeers 2</span><br><span class="line"></span><br><span class="line">## Install chaincode on Peer0&#x2F;Org1 and Peer2&#x2F;Org2</span><br><span class="line">echo &quot;Installing chaincode on org1&#x2F;peer0...&quot;</span><br><span class="line">installChaincode 0</span><br><span class="line">echo &quot;Install chaincode on org2&#x2F;peer2...&quot;</span><br><span class="line">installChaincode 2</span><br><span class="line"></span><br><span class="line">#Instantiate chaincode on Peer2&#x2F;Org2</span><br><span class="line">echo &quot;Instantiating chaincode on org2&#x2F;peer2...&quot;</span><br><span class="line">instantiateChaincode 2</span><br><span class="line"></span><br><span class="line">#Query on chaincode on Peer0&#x2F;Org1</span><br><span class="line">echo &quot;Querying chaincode on org1&#x2F;peer0...&quot;</span><br><span class="line">chaincodeQuery 0 100</span><br><span class="line"></span><br><span class="line">#Invoke on chaincode on Peer0&#x2F;Org1</span><br><span class="line">echo &quot;Sending invoke transaction on org1&#x2F;peer0...&quot;</span><br><span class="line">chaincodeInvoke 0</span><br><span class="line"></span><br><span class="line">## Install chaincode on Peer2&#x2F;Org2</span><br><span class="line">echo &quot;Installing chaincode on org2&#x2F;peer3...&quot;</span><br><span class="line">installChaincode 3</span><br><span class="line"></span><br><span class="line">#Query on chaincode on Peer2&#x2F;Org2, check if the result is 90</span><br><span class="line">echo &quot;Querying chaincode on org2&#x2F;peer3...&quot;</span><br><span class="line">chaincodeQuery 3 90</span><br></pre></td></tr></table></figure><p>该脚本设计 Peer 节点及排序服务节点的操作分别有如下九个步骤：</p><ol><li><strong>createChannel</strong>：根据之前在 generateArtifacts.sh 脚本中通过 configtx.yaml 配置文件生成的频道文件创建频道；</li><li><strong>joinChannel</strong>：Peer 节点加入指定频道；</li><li><strong>updateAnchorPeers 0/2</strong>：为频道中的每个组织设置 Peer 节点；</li><li><strong>installChaincode 0/2</strong>：在 Peer0/Org1 和 Peer0/Org2 上安装智能合约；</li><li><strong>instantiateChaincode 2</strong>：在 Peer0/Org2 上对智能合约进行实例化操作；</li><li><strong>chaincodeQuery 0 100</strong>：在 Peer0/Org1 上执行智能合约中的查询方法，判断是否等于 100；</li><li><strong>chaincodeInvoke 0</strong>：在 Peer0/Org1 上执行智能合约中的交易方法；</li><li><strong>installChaincode 3</strong>：在 Peer1/Org2 上安装智能合约；</li><li><strong>chaincodeQuery 3 90</strong>：在 Peer1/Org2 上执行智能合约中的查询方法，判断是否等于 90； </li></ol><blockquote><p><strong>注：</strong>这里需要说明的是脚本中最后两步的注释以及回显命令中的内容都有点小问题，”Peer2/Org2” 和 “org2/peer3” 都是不存在的，“3” 其实对应的节点是 Peer1/Org2。看到有的资料在分析这部分内容的时候也是按照错误的注释来解释的，让人很困惑。</p></blockquote><p>上面的脚本会在 cli 客户端容器启动之后执行，在 network_setup.sh 脚本的最后会执行 <code>docker logs -f cli</code> 来查看 cli 容器的日志信息，在开始时会出现如下的字符图：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">echo</span><br><span class="line">echo &quot; ____    _____      _      ____    _____           _____   ____    _____ &quot;</span><br><span class="line">echo &quot;&#x2F; ___|  |_   _|    &#x2F; \    |  _ \  |_   _|         | ____| |___ \  | ____|&quot;</span><br><span class="line">echo &quot;\___ \    | |     &#x2F; _ \   | |_) |   | |    _____  |  _|     __) | |  _|  &quot;</span><br><span class="line">echo &quot; ___) |   | |    &#x2F; ___ \  |  _ &lt;    | |   |_____| | |___   &#x2F; __&#x2F;  | |___ &quot;</span><br><span class="line">echo &quot;|____&#x2F;    |_|   &#x2F;_&#x2F;   \_\ |_| \_\   |_|           |_____| |_____| |_____|&quot;</span><br><span class="line">echo</span><br></pre></td></tr></table></figure><p>在结束时显示的字符图如下，并提示执行完成：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">echo</span><br><span class="line">echo &quot;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; All GOOD, End-2-End execution completed &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; &quot;</span><br><span class="line">echo</span><br><span class="line"></span><br><span class="line">echo</span><br><span class="line">echo &quot; _____   _   _   ____            _____   ____    _____ &quot;</span><br><span class="line">echo &quot;| ____| | \ | | |  _ \          | ____| |___ \  | ____|&quot;</span><br><span class="line">echo &quot;|  _|   |  \| | | | | |  _____  |  _|     __) | |  _|  &quot;</span><br><span class="line">echo &quot;| |___  | |\  | | |_| | |_____| | |___   &#x2F; __&#x2F;  | |___ &quot;</span><br><span class="line">echo &quot;|_____| |_| \_| |____&#x2F;          |_____| |_____| |_____|&quot;</span><br><span class="line">echo</span><br></pre></td></tr></table></figure><p>以上就是e2e_cli 案例启动 fabric 网络的流程分析，接下来分析关闭 fabric 网络的流程。</p><hr><h1 id="2-关闭过程"><a href="#2-关闭过程" class="headerlink" title="2. 关闭过程"></a>2. 关闭过程</h1><h2 id="2-1-network-setup-sh-参数设置"><a href="#2-1-network-setup-sh-参数设置" class="headerlink" title="2.1 network_setup.sh 参数设置"></a>2.1 network_setup.sh 参数设置</h2><p>当执行 <code>./network_setup.sh down</code> 命令时，down 参数传入脚本作为变量 UP_DOWN 的值，表示关闭 fabric 网络的操作。脚本中判断 $UP_DOWN=down 后将执行 networkDown 函数，如 2.2 节。</p><hr><h2 id="2-2-关闭网络：networkDown"><a href="#2-2-关闭网络：networkDown" class="headerlink" title="2.2 关闭网络：networkDown"></a>2.2 关闭网络：networkDown</h2><p>在 networkDown 函数中，首先会执行 docker-compose 相关的命令来关闭容器服务，然后调用 clearContainers 和 removeUnwantedImages 函数删除相应的容器及镜像，最后会删除 generateArtifacts.sh 脚本创建的 crypto-config 目录和区块链网络证书等文件。如后面 3 节。</p><hr><h2 id="2-3-docker-compose-关闭容器服务"><a href="#2-3-docker-compose-关闭容器服务" class="headerlink" title="2.3 docker-compose 关闭容器服务"></a>2.3 docker-compose 关闭容器服务</h2><p>执行的命令为：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker-compose -f $COMPOSE_FILE down</span><br></pre></td></tr></table></figure><blockquote><p>$COMPOSE_FILE 就是 docker-compose-cli.yaml 文件。</p></blockquote><p>该命令会将由 docker-compose-cli.yaml 文件创建的容器服务全部关闭。</p><hr><h2 id="2-4-删除容器及镜像"><a href="#2-4-删除容器及镜像" class="headerlink" title="2.4 删除容器及镜像"></a>2.4 删除容器及镜像</h2><p>在运行 e2e_cli  案例之后，环境中会启动总共 9 个容器，使用 <code>docker ps -a</code> 命令查看，这里只列出容器的名字：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">orderer.example.com                   &lt;&#x3D;&#x3D;Orderer排序节点</span><br><span class="line">peer0.org1.example.com                &lt;&#x3D;&#x3D;Peer0&#x2F;Org1</span><br><span class="line">peer1.org1.example.com                &lt;&#x3D;&#x3D;Peer1&#x2F;Org2</span><br><span class="line">peer0.org2.example.com                &lt;&#x3D;&#x3D;Peer0&#x2F;Org2</span><br><span class="line">peer1.org2.example.com                &lt;&#x3D;&#x3D;Peer1&#x2F;Org2</span><br><span class="line">cli                                   &lt;&#x3D;&#x3D;客户端容器</span><br><span class="line">dev-peer0.org1.example.com-mycc-1.0   &lt;&#x3D;&#x3D;运行智能合约的容器，基于Peer0&#x2F;Org1安装智能合约后生成</span><br><span class="line">dev-peer0.org2.example.com-mycc-1.0   &lt;&#x3D;&#x3D;运行智能合约的容器，基于Peer0&#x2F;Org2安装智能合约后生成</span><br><span class="line">dev-peer1.org2.example.com-mycc-1.0   &lt;&#x3D;&#x3D;运行智能合约的容器，基于Peer1&#x2F;Org2安装智能合约后生成</span><br></pre></td></tr></table></figure><p>另外也会生成上面运行智能合约的容器对应的镜像，使用 <code>docker image ls</code> 列出如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ docker image ls</span><br><span class="line">REPOSITORY                            TAG        IMAGE ID           CREATED         SIZE</span><br><span class="line">dev-peer1.org2.example.com-mycc-1.0   latest    8c03b3cb4f3f      36 hours ago      173MB</span><br><span class="line">dev-peer0.org1.example.com-mycc-1.0   latest    9aa4e69a149f      36 hours ago      173MB</span><br><span class="line">dev-peer0.org2.example.com-mycc-1.0   latest    f3fef07f5dcc      36 hours ago      173MB</span><br></pre></td></tr></table></figure><p>以上的容器和镜像就是要被删除的，这里调用了两个函数：clearContainers 和 removeUnwantedImages 分别来删除，函数内容如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">function clearContainers () &#123;</span><br><span class="line">        CONTAINER_IDS&#x3D;$(docker ps -aq)</span><br><span class="line">        if [ -z &quot;$CONTAINER_IDS&quot; -o &quot;$CONTAINER_IDS&quot; &#x3D; &quot; &quot; ]; then</span><br><span class="line">                echo &quot;---- No containers available for deletion ----&quot;</span><br><span class="line">        else</span><br><span class="line">                docker rm -f $CONTAINER_IDS</span><br><span class="line">        fi  </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">function removeUnwantedImages() &#123;</span><br><span class="line">        DOCKER_IMAGE_IDS&#x3D;$(docker images | grep &quot;dev\|none\|test-vp\|peer[0-9]-&quot; | awk &#39;&#123;print $3&#125;&#39;)</span><br><span class="line">        if [ -z &quot;$DOCKER_IMAGE_IDS&quot; -o &quot;$DOCKER_IMAGE_IDS&quot; &#x3D; &quot; &quot; ]; then</span><br><span class="line">                echo &quot;---- No images available for deletion ----&quot;</span><br><span class="line">        else</span><br><span class="line">                docker rmi -f $DOCKER_IMAGE_IDS</span><br><span class="line">        fi  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><hr><h2 id="2-5-删除相关目录文件"><a href="#2-5-删除相关目录文件" class="headerlink" title="2.5 删除相关目录文件"></a>2.5 删除相关目录文件</h2><p>在 networkDown 函数的最后就是要删除由 generateArtifacts.sh 脚本创建的 crypto-config 目录和区块链网络证书等文件，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># remove orderer block and other channel configuration transactions and certs</span><br><span class="line">rm -rf channel-artifacts&#x2F;*.block channel-artifacts&#x2F;*.tx crypto-config</span><br></pre></td></tr></table></figure><p>结束以上步骤之后就完成了关闭 fabric 网络的操作。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> e2e_cli </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hyperledger fabric v1.0.0 环境部署过程</title>
      <link href="2018/08/26/Fabric%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/"/>
      <url>2018/08/26/Fabric%E7%8E%AF%E5%A2%83%E9%83%A8%E7%BD%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>本文主要基于 Hyperledger fabric 的官方文档来搭建其实验环境，但官方文档对于很多步骤都有省略，所以本文将比较详细的在一台新安装的 Ubuntu 16.04 虚拟机上来介绍 fabric 的环境部署流程步骤。</p><a id="more"></a><h1 id="环境部署"><a href="#环境部署" class="headerlink" title="环境部署"></a>环境部署</h1><h3 id="1-更换-apt-源"><a href="#1-更换-apt-源" class="headerlink" title="1. 更换 apt 源"></a>1. 更换 apt 源</h3><p>先备份 sources.list 文件：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo cp &#x2F;etc&#x2F;apt&#x2F;sources.list &#x2F;etc&#x2F;apt&#x2F;sources.list.bak</span><br></pre></td></tr></table></figure><p>再修改 sources.list 文件，换成阿里云的国内源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vim &#x2F;etc&#x2F;apt&#x2F;sources.list</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.ubuntu.com&#x2F;ubuntu xenial main restricted #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-updates multiverse</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-backports main restricted universe multiverse #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb-src http:&#x2F;&#x2F;archive.canonical.com&#x2F;ubuntu xenial partner</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted</span><br><span class="line">deb-src http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security main restricted multiverse universe #Added by software-properties</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security universe</span><br><span class="line">deb http:&#x2F;&#x2F;mirrors.aliyun.com&#x2F;ubuntu&#x2F; xenial-security multiverse</span><br></pre></td></tr></table></figure><p>最后更新一下源：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br></pre></td></tr></table></figure><h3 id="2-安装-curl"><a href="#2-安装-curl" class="headerlink" title="2. 安装 curl"></a>2. 安装 curl</h3><p>Ubuntu 16.04 一般默认是安装了 curl 的，可以通过以下命令验证：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ curl -V</span><br><span class="line">curl 7.47.0 (x86_64-pc-linux-gnu) libcurl&#x2F;7.47.0 GnuTLS&#x2F;3.4.10 zlib&#x2F;1.2.8 libidn&#x2F;1.32 librtmp&#x2F;2.3</span><br><span class="line">Protocols: dict file ftp ftps gopher http https imap imaps ldap ldaps pop3 pop3s rtmp rtsp smb smbs smtp smtps telnet tftp </span><br><span class="line">Features: AsynchDNS IDN IPv6 Largefile GSS-API Kerberos SPNEGO NTLM NTLM_WB SSL libz TLS-SRP UnixSockets</span><br></pre></td></tr></table></figure><p>如果没有安装，则通过 apt-get 安装：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install curl</span><br></pre></td></tr></table></figure><h3 id="3-安装-Docker"><a href="#3-安装-Docker" class="headerlink" title="3. 安装 Docker"></a>3. 安装 Docker</h3><ul><li><p>由于 apt 源使用HTTPS以确保软件下载过程中不被篡改。因此，我们首先需要添加使用HTTPS传输的软件包以及CA证书。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get install \</span><br><span class="line">    apt-transport-https \</span><br><span class="line">    ca-certificates \</span><br><span class="line">    curl \</span><br><span class="line">    software-properties-common</span><br></pre></td></tr></table></figure></li><li><p>为了确认所下载软件包的合法性，需要添加软件源的 GPG 秘钥</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ curl -fsSL https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu&#x2F;gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure></li><li><p>然后，我们需要向 sources.list 中添加 Docker 软件源</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo add-apt-repository \</span><br><span class="line">    &quot;deb [arch&#x3D;amd64] https:&#x2F;&#x2F;mirrors.ustc.edu.cn&#x2F;docker-ce&#x2F;linux&#x2F;ubuntu \</span><br><span class="line">    $(lsb_release -cs) \</span><br><span class="line">    stable&quot;</span><br></pre></td></tr></table></figure><blockquote><p>以上命令会添加稳定版本的Docker CE apt 镜像源。</p></blockquote></li><li><p>更新 apt 软件包缓存，并安装 docker-ce：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt-get update</span><br><span class="line"></span><br><span class="line">$ sudo apt-get install docker-ce</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker 版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker -v</span><br><span class="line">Docker version 18.06.0-ce, build 0ffa825</span><br></pre></td></tr></table></figure><p>满足官方文档中 <em>Docker version 17.06.2-ce or greater is required</em> 的要求。</p></li><li><p>启动 Docker CE</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl enable docker</span><br><span class="line">$ sudo systemctl start docker</span><br></pre></td></tr></table></figure></li><li><p>建立 docker 用户组</p><p>默认情况下，<code>docker</code> 命令会使用 <a href="https://en.wikipedia.org/wiki/Unix_domain_socket">Unix socket</a> 与 Docker 引擎通讯。而只有 <code>root</code> 用户和 <code>docker</code> 组的用户才可以访问 Docker 引擎的 Unix socket。出于安全考虑，一般 Linux 系统上不会直接使用 <code>root</code> 用户。因此，更好地做法是将需要使用 <code>docker</code> 的用户加入 <code>docker</code> 用户组。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo groupadd docker</span><br></pre></td></tr></table></figure><blockquote><p>其实一般按照上面的方法安装 Docker 后就已经创建好 docker 用户组了，可以使用 <code>$ cat /etc/group | grep docker</code> 命令来验证，所以就不需要再建立 docker 用户组了，再建立也会报错提示用户组已存在的。</p></blockquote></li><li><p>将当前用户加入 docker 用户组：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo usermod -aG docker $USER</span><br></pre></td></tr></table></figure><blockquote><p>下次登录时即可方便的使用 docker 命令。</p></blockquote></li><li><p>测试 Docker 是否安装正确</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ docker run hello-world</span><br><span class="line">Unable to find image &#39;hello-world:latest&#39; locally</span><br><span class="line">latest: Pulling from library&#x2F;hello-world</span><br><span class="line">9db2ca6ccae0: Pull complete </span><br><span class="line">Digest: sha256:4b8ff392a12ed9ea17784bd3c9a8b1fa3299cac44aca35a85c90c5e3c7afacdc</span><br><span class="line">Status: Downloaded newer image for hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello from Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line"></span><br><span class="line">To generate this message, Docker took the following steps:</span><br><span class="line"> 1. The Docker client contacted the Docker daemon.</span><br><span class="line"> 2. The Docker daemon pulled the &quot;hello-world&quot; image from the Docker Hub.</span><br><span class="line">    (amd64)</span><br><span class="line"> 3. The Docker daemon created a new container from that image which runs the</span><br><span class="line">    executable that produces the output you are currently reading.</span><br><span class="line"> 4. The Docker daemon streamed that output to the Docker client, which sent it</span><br><span class="line">    to your terminal.</span><br><span class="line"></span><br><span class="line">To try something more ambitious, you can run an Ubuntu container with:</span><br><span class="line"> $ docker run -it ubuntu bash</span><br><span class="line"></span><br><span class="line">Share images, automate workflows, and more with a free Docker ID:</span><br><span class="line"> https:&#x2F;&#x2F;hub.docker.com&#x2F;</span><br><span class="line"></span><br><span class="line">For more examples and ideas, visit:</span><br><span class="line"> https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;userguide&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>配置镜像加速器</p><p>国内从 Docker Hub 拉取镜像有时会遇到困难，此时可以配置镜像加速器。Docker 官方和国内很多云服务商都提供了国内加速器服务，例如： </p><ul><li><a href="https://docs.docker.com/registry/recipes/mirror/#use-case-the-china-registry-mirror">Docker 官方提供的中国 registry mirror <code>https://registry.docker-cn.com</code></a> </li><li><a href="https://kirk-enterprise.github.io/hub-docs/#/user-guide/mirror">七牛云加速器 <code>https://reg-mirror.qiniu.com/</code></a> </li></ul><blockquote><p>当配置某一个加速器地址之后，若发现拉取不到镜像，请切换到另一个加速器地址。</p><p>国内各大云服务商均提供了 Docker 镜像加速服务，建议根据运行 Docker 的云平台选择对应的镜像加速服务。</p></blockquote><p>我们以 Docker 官方加速器 <code>https://registry.docker-cn.com</code> 为例进行介绍。 </p><p>在 <code>/etc/docker/daemon.json</code> 中写入如下内容（如果文件不存在则创建）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  &quot;registry-mirrors&quot;: [</span><br><span class="line">    &quot;https:&#x2F;&#x2F;registry.docker-cn.com&quot;</span><br><span class="line">  ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后重新启动服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo systemctl daemon-reload</span><br><span class="line">$ sudo systemctl restart docker</span><br></pre></td></tr></table></figure><h3 id="4-安装-Docker-Compose"><a href="#4-安装-Docker-Compose" class="headerlink" title="4. 安装 Docker Compose"></a>4. 安装 Docker Compose</h3></li><li><p>通过二进制包来安装，从 <a href="https://github.com/docker/compose/releases">官方 GitHub Release</a> 处直接下载编译好的二进制文件即可。 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ sudo curl -L https:&#x2F;&#x2F;github.com&#x2F;docker&#x2F;compose&#x2F;releases&#x2F;download&#x2F;1.22.0&#x2F;docker-compose-$(uname -s)-$(uname -m) -o &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br><span class="line"></span><br><span class="line">$ sudo chmod +x &#x2F;usr&#x2F;local&#x2F;bin&#x2F;docker-compose</span><br></pre></td></tr></table></figure></li><li><p>查看 Docker compose 版本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ docker-compose --version</span><br><span class="line">docker-compose version 1.22.0, build f46880fe</span><br></pre></td></tr></table></figure><blockquote><p> 满足官方文档中 <em>Docker Compose version 1.14.0 or greater</em>  的要求。</p></blockquote></li></ul><h3 id="5-安装-Go-语言环境"><a href="#5-安装-Go-语言环境" class="headerlink" title="5. 安装 Go 语言环境"></a>5. 安装 Go 语言环境</h3><p>Hyperledger Fabric 在很多组件中使用了 Go 语言，并且 <code>Hyperledger fabric 1.2.0</code> 要求使用的是 <code>GO version 1.10.x</code> ，所以需要在我们的环境中安装对应的 Go 语言。</p><ul><li><p>从官网下载 <code>1.10.x</code> 版本的 Linux 平台的源码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.10.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压到指定目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo tar zxvf go1.10.3.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>先创建 Go 的工作目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~&#x2F;go</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~&#x2F;.bashrc</span><br><span class="line">添加</span><br><span class="line">export GOROOT&#x3D;&#x2F;usr&#x2F;local&#x2F;go</span><br><span class="line">export GOPATH&#x3D;&#x2F;home&#x2F;user1&#x2F;go</span><br><span class="line">export PATH&#x3D;$PATH:$GOROOT&#x2F;bin:$GOPATH&#x2F;bin</span><br></pre></td></tr></table></figure><p>保存并使生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ source ~&#x2F;.bashrc</span><br></pre></td></tr></table></figure></li><li><p>测试 Go 的 demo 程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;go</span><br><span class="line"></span><br><span class="line">$ vi hello.go</span><br><span class="line">package main</span><br><span class="line"></span><br><span class="line">import &quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">fmt.Printf(&quot;hello world\n&quot;)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">$ go build hello.go</span><br><span class="line"></span><br><span class="line">$ ls</span><br><span class="line">hello  hello.go</span><br><span class="line"></span><br><span class="line">$ .&#x2F;hello</span><br><span class="line">hello world</span><br></pre></td></tr></table></figure><h3 id="6-Fabric-源码下载"><a href="#6-Fabric-源码下载" class="headerlink" title="6. Fabric 源码下载"></a>6. Fabric 源码下载</h3></li><li><p>首先创建存放源码的文件夹：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir -p ~&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger</span><br></pre></td></tr></table></figure></li><li><p>使用 Git 下载完整源码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https:&#x2F;&#x2F;github.com&#x2F;hyperledger&#x2F;fabric.git</span><br></pre></td></tr></table></figure></li><li><p>进入 fabric 目录查看版本分支并切换分支：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ cd fabric</span><br><span class="line">$ git branch</span><br><span class="line">* release-1.2</span><br><span class="line">$ git checkout v1.0.0</span><br></pre></td></tr></table></figure><p>由于在 release-1.2 版本中碰到没有解决的问题，所以先切换到 v1.0.0 来完成搭建并测试的过程。</p></li></ul><h3 id="7-Fabric-Docker-镜像下载"><a href="#7-Fabric-Docker-镜像下载" class="headerlink" title="7. Fabric Docker 镜像下载"></a>7. Fabric Docker 镜像下载</h3><p>进入 <code>~/go/src/github.com/hyperledger/fabrci/examples/e2e_cli/</code> 目录，完成镜像下载，执行命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;go&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabrci&#x2F;examples&#x2F;e2e_cli&#x2F;</span><br><span class="line">$ ls</span><br><span class="line">base                docker-compose-cli.yaml           download-dockerimages.sh  scripts</span><br><span class="line">channel-artifacts   docker-compose-couch.yaml         end-to-end.rst</span><br><span class="line">configtx.yaml       docker-compose-e2e-template.yaml  generateArtifacts.sh</span><br><span class="line">crypto-config.yaml  docker-compose-e2e.yaml           network_setup.sh</span><br><span class="line">$ source download-dockerimages.sh -c x86_64-1.0.0 -f x86_64-1.0.0</span><br><span class="line">$ docker image list</span><br><span class="line">REPOSITORY                     TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">hyperledger&#x2F;fabric-tools       latest              0403fd1c72c7        13 months ago       1.32GB</span><br><span class="line">hyperledger&#x2F;fabric-tools       x86_64-1.0.0        0403fd1c72c7        13 months ago       1.32GB</span><br><span class="line">hyperledger&#x2F;fabric-couchdb     latest              2fbdbf3ab945        13 months ago       1.48GB</span><br><span class="line">hyperledger&#x2F;fabric-couchdb     x86_64-1.0.0        2fbdbf3ab945        13 months ago       1.48GB</span><br><span class="line">hyperledger&#x2F;fabric-kafka       latest              dbd3f94de4b5        13 months ago       1.3GB</span><br><span class="line">hyperledger&#x2F;fabric-kafka       x86_64-1.0.0        dbd3f94de4b5        13 months ago       1.3GB</span><br><span class="line">hyperledger&#x2F;fabric-zookeeper   latest              e545dbf1c6af        13 months ago       1.31GB</span><br><span class="line">hyperledger&#x2F;fabric-zookeeper   x86_64-1.0.0        e545dbf1c6af        13 months ago       1.31GB</span><br><span class="line">hyperledger&#x2F;fabric-orderer     latest              e317ca5638ba        13 months ago       179MB</span><br><span class="line">hyperledger&#x2F;fabric-orderer     x86_64-1.0.0        e317ca5638ba        13 months ago       179MB</span><br><span class="line">hyperledger&#x2F;fabric-peer        latest              6830dcd7b9b5        13 months ago       182MB</span><br><span class="line">hyperledger&#x2F;fabric-peer        x86_64-1.0.0        6830dcd7b9b5        13 months ago       182MB</span><br><span class="line">hyperledger&#x2F;fabric-javaenv     latest              8948126f0935        13 months ago       1.42GB</span><br><span class="line">hyperledger&#x2F;fabric-javaenv     x86_64-1.0.0        8948126f0935        13 months ago       1.42GB</span><br><span class="line">hyperledger&#x2F;fabric-ccenv       latest              7182c260a5ca        13 months ago       1.29GB</span><br><span class="line">hyperledger&#x2F;fabric-ccenv       x86_64-1.0.0        7182c260a5ca        13 months ago       1.29GB</span><br><span class="line">hyperledger&#x2F;fabric-ca          latest              a15c59ecda5b        13 months ago       238MB</span><br><span class="line">hyperledger&#x2F;fabric-ca          x86_64-1.0.0        a15c59ecda5b        13 months ago       238MB</span><br><span class="line">hyperledger&#x2F;fabric-baseos      x86_64-0.3.1        4b0cab202084        15 months ago       157MB</span><br></pre></td></tr></table></figure><h3 id="8-启动-fabric-网络并完成-chaincode-测试"><a href="#8-启动-fabric-网络并完成-chaincode-测试" class="headerlink" title="8. 启动 fabric 网络并完成 chaincode 测试"></a>8. 启动 fabric 网络并完成 chaincode 测试</h3><p>还是在刚刚的 e2e_cli 文件加下，执行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ .&#x2F;network_setup.sh up</span><br><span class="line">......</span><br><span class="line">......</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; All GOOD, End-2-End execution completed &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line"> _____   _   _   ____            _____   ____    _____ </span><br><span class="line">| ____| | \ | | |  _ \          | ____| |___ \  | ____|</span><br><span class="line">|  _|   |  \| | | | | |  _____  |  _|     __) | |  _|  </span><br><span class="line">| |___  | |\  | | |_| | |_____| | |___   &#x2F; __&#x2F;  | |___ </span><br><span class="line">|_____| |_| \_| |____&#x2F;          |_____| |_____| |_____|</span><br></pre></td></tr></table></figure><p>最后出现上面字符说明 fabric 网络已经启动并完成了 chaincode 的测试。</p><hr><h1 id="搭建过程中碰到的问题："><a href="#搭建过程中碰到的问题：" class="headerlink" title="搭建过程中碰到的问题："></a>搭建过程中碰到的问题：</h1><p>v1.0.0 版本搭建过程中会碰到的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; Chaincode is installed on remote peer PEER2 &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; </span><br><span class="line"></span><br><span class="line">Instantiating chaincode on org2&#x2F;peer2...</span><br><span class="line">CORE_PEER_TLS_ROOTCERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;peers&#x2F;peer0.org2.example.com&#x2F;tls&#x2F;ca.crt</span><br><span class="line">CORE_PEER_TLS_KEY_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;server.key</span><br><span class="line">CORE_PEER_LOCALMSPID&#x3D;Org2MSP</span><br><span class="line">CORE_VM_ENDPOINT&#x3D;unix:&#x2F;&#x2F;&#x2F;host&#x2F;var&#x2F;run&#x2F;docker.sock</span><br><span class="line">CORE_PEER_TLS_CERT_FILE&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org1.example.com&#x2F;peers&#x2F;peer0.org1.example.com&#x2F;tls&#x2F;server.crt</span><br><span class="line">CORE_PEER_TLS_ENABLED&#x3D;true</span><br><span class="line">CORE_PEER_MSPCONFIGPATH&#x3D;&#x2F;opt&#x2F;gopath&#x2F;src&#x2F;github.com&#x2F;hyperledger&#x2F;fabric&#x2F;peer&#x2F;crypto&#x2F;peerOrganizations&#x2F;org2.example.com&#x2F;users&#x2F;Admin@org2.example.com&#x2F;msp</span><br><span class="line">CORE_PEER_ID&#x3D;cli</span><br><span class="line">CORE_LOGGING_LEVEL&#x3D;DEBUG</span><br><span class="line">CORE_PEER_ADDRESS&#x3D;peer0.org2.example.com:7051</span><br><span class="line">2018-08-21 13:24:09.596 UTC [msp] GetLocalMSP -&gt; DEBU 001 Returning existing local MSP</span><br><span class="line">2018-08-21 13:24:09.596 UTC [msp] GetDefaultSigningIdentity -&gt; DEBU 002 Obtaining default signing identity</span><br><span class="line">2018-08-21 13:24:09.602 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 003 Using default escc</span><br><span class="line">2018-08-21 13:24:09.602 UTC [chaincodeCmd] checkChaincodeCmdParams -&gt; INFO 004 Using default vscc</span><br><span class="line">2018-08-21 13:24:09.603 UTC [msp&#x2F;identity] Sign -&gt; DEBU 005 Sign: plaintext: 0A95070A6708031A0C08F9A4F0DB0510...324D53500A04657363630A0476736363 </span><br><span class="line">2018-08-21 13:24:09.603 UTC [msp&#x2F;identity] Sign -&gt; DEBU 006 Sign: digest: D73172E2164A0DD4FA9B64DBAFE980C3ABC412EB3CD32FEBF6EF7A7AFE3B6431 </span><br><span class="line">Error: Error endorsing chaincode: rpc error: code &#x3D; Unknown desc &#x3D; Error starting container: API error (404): &#123;&quot;message&quot;:&quot;network e2ecli_default not found&quot;&#125;</span><br><span class="line"></span><br><span class="line">Usage:</span><br><span class="line">  peer chaincode instantiate [flags]</span><br><span class="line"></span><br><span class="line">Flags:</span><br><span class="line">  -C, --channelID string   The channel on which this command should be executed (default &quot;testchainid&quot;)</span><br><span class="line">  -c, --ctor string        Constructor message for the chaincode in JSON format (default &quot;&#123;&#125;&quot;)</span><br><span class="line">  -E, --escc string        The name of the endorsement system chaincode to be used for this chaincode</span><br><span class="line">  -l, --lang string        Language the chaincode is written in (default &quot;golang&quot;)</span><br><span class="line">  -n, --name string        Name of the chaincode</span><br><span class="line">  -P, --policy string      The endorsement policy associated to this chaincode</span><br><span class="line">  -v, --version string     Version of the chaincode specified in install&#x2F;instantiate&#x2F;upgrade commands</span><br><span class="line">  -V, --vscc string        The name of the verification system chaincode to be used for this chaincode</span><br><span class="line"></span><br><span class="line">Global Flags:</span><br><span class="line">      --cafile string              Path to file containing PEM-encoded trusted certificate(s) for the ordering endpoint</span><br><span class="line">      --logging-level string       Default logging level and overrides, see core.yaml for full syntax</span><br><span class="line">  -o, --orderer string             Ordering service endpoint</span><br><span class="line">      --test.coverprofile string   Done (default &quot;coverage.cov&quot;)</span><br><span class="line">      --tls                        Use TLS when communicating with the orderer endpoint</span><br><span class="line"></span><br><span class="line">!!!!!!!!!!!!!!! Chaincode instantiation on PEER2 on channel &#39;mychannel&#39; failed !!!!!!!!!!!!!!!!</span><br><span class="line">&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D; ERROR !!! FAILED to execute End-2-End Scenario &#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;</span><br></pre></td></tr></table></figure><p><strong>解决方法：</strong></p><p>这个主要是因为 e2e_cli/base目录下的 peer-base.yaml 文件中的网络名称打成了 <code>e2ecli_default</code>，将其改成 <code>e2e_cli_default</code> 即可。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 区块链 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Hyperledger fabric </tag>
            
            <tag> Docker </tag>
            
            <tag> Docker Compose </tag>
            
            <tag> Go </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>迁移vim-python开发环境</title>
      <link href="2018/08/23/%E8%BF%81%E7%A7%BBvim-python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/"/>
      <url>2018/08/23/%E8%BF%81%E7%A7%BBvim-python%E5%BC%80%E5%8F%91%E7%8E%AF%E5%A2%83/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>之前配置好了自己的 vim python 开发环境，为了方便在其他主机上面迁移之前的开发环境，所以将所有的插件包都打包压缩了一份，和 vim 配置文件 .vimrc 一起上传到了百度云盘（下载链接：<a href="https://pan.baidu.com/s/1QJtx7CPloS4sKmwD3xjj8g">vim插件包</a> 密码：neio）。通过下载这个文件夹就可以在新的主机上部署 vim 的 python 开发环境了。</p><a id="more"></a><h1 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h1><ol><li><p>下载插件包与配置文件</p><p>先使用百度云盘下载这两个文件，然后再通过 ftp 上传到你的 Linux 主机上。我也试过直接在 Linux 里面通过 wget 来下载百度云盘的文件，但是这个要使用浏览器来生成下载链接，挺麻烦的，所以我就不在这里说明了。</p></li><li><p>将 .vimrc 放到用户主目录下，即 <code>~/</code> 目录</p><p>.vimrc 文件里面主要记录需要安装哪些插件，我的 vim python 开发环境安装的插件有：</p><ul><li><code>VundleVim/Vundle.vim</code></li><li><code>Valloric/YouCompleteMe</code></li><li><code>Lokaltog/vim-powerline</code></li><li><code>scrooloose/nerdtree</code></li><li><code>Yggdroot/indentLine</code></li><li><code>jiangmiao/auto-pairs</code></li><li><code>tell-k/vim-autopep8</code></li><li><code>scrooloose/nerdcommenter</code></li><li><code>altercation/vim-colors-solarized</code></li><li><code>w0rp/ale</code></li><li><code>scrooloose/syntastic</code></li><li><code>nvie/vim-flake8</code></li></ul><p>以及一些常用的配置信息，具体如下所示</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~&#x2F;.vimrc</span><br><span class="line">&quot;去掉vi的一致性&quot;</span><br><span class="line">set nocompatible</span><br><span class="line"></span><br><span class="line">filetype off</span><br><span class="line">set rtp+&#x3D;~&#x2F;.vim&#x2F;bundle&#x2F;Vundle.vim</span><br><span class="line">call vundle#begin()</span><br><span class="line">Plugin &#39;VundleVim&#x2F;Vundle.vim&#39;</span><br><span class="line">Plugin &#39;Valloric&#x2F;YouCompleteMe&#39;</span><br><span class="line">Plugin &#39;Lokaltog&#x2F;vim-powerline&#39;</span><br><span class="line">Plugin &#39;scrooloose&#x2F;nerdtree&#39;</span><br><span class="line">Plugin &#39;Yggdroot&#x2F;indentLine&#39;</span><br><span class="line">Plugin &#39;jiangmiao&#x2F;auto-pairs&#39;</span><br><span class="line">Plugin &#39;tell-k&#x2F;vim-autopep8&#39;</span><br><span class="line">Plugin &#39;scrooloose&#x2F;nerdcommenter&#39;</span><br><span class="line">Plugin &#39;altercation&#x2F;vim-colors-solarized&#39;</span><br><span class="line">&quot;Plugin &#39;w0rp&#x2F;ale&#39;</span><br><span class="line">Plugin &#39;scrooloose&#x2F;syntastic&#39;</span><br><span class="line">Plugin &#39;nvie&#x2F;vim-flake8&#39;</span><br><span class="line">call vundle#end()</span><br><span class="line">filetype plugin indent on</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&quot;显示行号&quot;</span><br><span class="line">set number</span><br><span class="line">&quot; 隐藏滚动条&quot;    </span><br><span class="line">&quot;set guioptions-&#x3D;r </span><br><span class="line">&quot;set guioptions-&#x3D;L</span><br><span class="line">&quot;set guioptions-&#x3D;b</span><br><span class="line">&quot;隐藏顶部标签栏&quot;</span><br><span class="line">&quot;set showtabline&#x3D;0</span><br><span class="line">&quot;设置字体&quot;</span><br><span class="line">set guifont&#x3D;Monaco:h13         </span><br><span class="line">set nowrap  &quot;设置不折行&quot;</span><br><span class="line">&quot;set fileformat&#x3D;unix &quot;设置以unix的格式保存文件&quot;</span><br><span class="line">&quot;set cindent     &quot;设置C样式的缩进格式&quot;</span><br><span class="line">set tabstop&#x3D;4   &quot;设置table长度&quot;</span><br><span class="line">set shiftwidth&#x3D;4        &quot;同上&quot;</span><br><span class="line">set showmatch   &quot;显示匹配的括号&quot;</span><br><span class="line">set scrolloff&#x3D;5     &quot;距离顶部和底部5行&quot;</span><br><span class="line">set laststatus&#x3D;2    &quot;命令行为两行&quot;</span><br><span class="line">set fenc&#x3D;utf-8      &quot;文件编码&quot;</span><br><span class="line">set backspace&#x3D;2</span><br><span class="line">set mouse&#x3D;v     &quot;启用鼠标&quot;</span><br><span class="line">set selection&#x3D;exclusive</span><br><span class="line">set selectmode&#x3D;mouse,key</span><br><span class="line">set matchtime&#x3D;5</span><br><span class="line">set ignorecase      &quot;忽略大小写&quot;</span><br><span class="line">set incsearch</span><br><span class="line">set hlsearch        &quot;高亮搜索项&quot;</span><br><span class="line">set noexpandtab     &quot;不允许扩展table&quot;</span><br><span class="line">set whichwrap+&#x3D;&lt;,&gt;,h,l</span><br><span class="line">set autoread</span><br><span class="line">set cursorline      &quot;突出显示当前行&quot;</span><br><span class="line">&quot;set cursorcolumn        &quot;突出显示当前列&quot;</span><br><span class="line">syntax on   &quot;开启语法高亮&quot;</span><br><span class="line">&quot;set background&#x3D;dark     &quot;设置背景色&quot;</span><br><span class="line">&quot;colorscheme solarized</span><br><span class="line">&quot;let g:solarized_termcolors&#x3D;256  &quot;solarized主题设置在终端下的设置&quot;</span><br><span class="line"></span><br><span class="line">&quot;syntastic</span><br><span class="line">let python_highlight_all&#x3D;1</span><br><span class="line">&quot;设置error和warning的标志</span><br><span class="line">let g:syntastic_enable_signs&#x3D;1</span><br><span class="line">let g:syntastic_error_symbol&#x3D;&#39;✗&#39;</span><br><span class="line">let g:syntastic_warning_symbol&#x3D;&#39;►&#39;</span><br><span class="line">&quot;总是打开Location</span><br><span class="line">&quot;List（相当于QuickFix）窗口，如果你发现syntastic因为与其他插件冲突而经常崩溃，将下面选项置0</span><br><span class="line">let g:syntastic_always_populate_loc_list &#x3D; 0</span><br><span class="line">&quot;自动打开LocatonList，默认值为2，表示发现错误时不自动打开，当修正以后没有再发现错误时自动关闭，置1表示自动打开自动关闭，0表示关闭自动打开和自动关闭，3表示自动打开，但不自动关闭</span><br><span class="line">let g:syntastic_auto_loc_list &#x3D; 2</span><br><span class="line">&quot;修改Locaton List窗口高度</span><br><span class="line">let g:syntastic_loc_list_height &#x3D; 3</span><br><span class="line">&quot;打开文件时自动进行检查</span><br><span class="line">let g:syntastic_check_on_open &#x3D; 1</span><br><span class="line">let g:syntastic_check_on_wq &#x3D; 1</span><br><span class="line">&quot;自动跳转到发现的第一个错误或警告处</span><br><span class="line">let g:syntastic_auto_jump &#x3D; 1</span><br><span class="line">&quot;高亮错误</span><br><span class="line">let g:syntastic_enable_highlighting&#x3D;0</span><br><span class="line">&quot;设置pyflakes为默认的python语法检查工具</span><br><span class="line">let g:syntastic_python_checkers &#x3D; [&#39;pyflakes&#39;]</span><br><span class="line"></span><br><span class="line">&quot;按F5运行python&quot;</span><br><span class="line">map &lt;F5&gt; :call RunPython()&lt;CR&gt;</span><br><span class="line">function RunPython()</span><br><span class="line">exec &quot;W&quot;</span><br><span class="line">if &amp;filetype &#x3D;&#x3D; &#39;python&#39;</span><br><span class="line">exec &quot;!time python %&quot;</span><br><span class="line">endif</span><br><span class="line">endfunction</span><br><span class="line"></span><br><span class="line">&quot;默认配置文件路径&quot;</span><br><span class="line">let g:ycm_global_ycm_extra_conf &#x3D; &#39;~&#x2F;.ycm_extra_conf.py&#39;</span><br><span class="line">&quot;打开vim时不再询问是否加载ycm_extra_conf.py配置&quot;</span><br><span class="line">let g:ycm_confirm_extra_conf&#x3D;0</span><br><span class="line">set completeopt&#x3D;longest,menu</span><br><span class="line">&quot;python解释器路径&quot;</span><br><span class="line">let g:ycm_path_to_python_interpreter&#x3D;&#39;&#x2F;usr&#x2F;bin&#x2F;python&#39;</span><br><span class="line">&quot;是否开启语义补全&quot;</span><br><span class="line">let g:ycm_seed_identifiers_with_syntax&#x3D;1 </span><br><span class="line">&quot;是否在注释中也开启补全&quot; </span><br><span class="line">let g:ycm_complete_in_comments&#x3D;1 </span><br><span class="line">let g:ycm_collect_identifiers_from_comments_and_strings &#x3D; 0</span><br><span class="line">&quot;开始补全的字符数&quot;</span><br><span class="line">let g:ycm_min_num_of_chars_for_completion&#x3D;2</span><br><span class="line">&quot;补全后自动关机预览窗口&quot;</span><br><span class="line">let g:ycm_autoclose_preview_window_after_completion&#x3D;1</span><br><span class="line">&quot; 禁止缓存匹配项,每次都重新生成匹配项&quot;</span><br><span class="line">let g:ycm_cache_omnifunc&#x3D;0</span><br><span class="line">&quot;字符串中也开启补全&quot;</span><br><span class="line">let g:ycm_complete_in_strings &#x3D; 1</span><br><span class="line">&quot;离开插入模式后自动关闭预览窗口&quot;</span><br><span class="line">autocmd InsertLeave * if pumvisible() &#x3D;&#x3D; 0|pclose|endif</span><br><span class="line"></span><br><span class="line">&quot;回车即选中当前项&quot;</span><br><span class="line">&quot;inoremap &lt;expr&gt; &lt;CR&gt;       pumvisible() ? &#39;&lt;C-y&gt;&#39; : &#39;\&lt;CR&gt;&#39;</span><br><span class="line">&quot;上下左右键行为&quot;</span><br><span class="line">inoremap &lt;expr&gt; &lt;Down&gt;     pumvisible() ? &#39;\&lt;C-n&gt;&#39; : &#39;\&lt;Down&gt;&#39;</span><br><span class="line">inoremap &lt;expr&gt; &lt;Up&gt;       pumvisible() ? &#39;\&lt;C-p&gt;&#39; : &#39;\&lt;Up&gt;&#39;</span><br><span class="line">inoremap &lt;expr&gt; &lt;PageDown&gt; pumvisible() ? &#39;\&lt;PageDown&gt;\&lt;C-p&gt;\&lt;C-n&gt;&#39; : &#39;\&lt;PageDown&gt;&#39;</span><br><span class="line">inoremap &lt;expr&gt; &lt;PageUp&gt;   pumvisible() ? &#39;\&lt;PageUp&gt;\&lt;C-p&gt;\&lt;C-n&gt;&#39; : &#39;\&lt;PageUp&gt;&#39;</span><br><span class="line"></span><br><span class="line">&quot;F2开启和关闭树&quot;</span><br><span class="line">map &lt;F2&gt; :NERDTreeToggle&lt;CR&gt;</span><br><span class="line">let NERDTreeChDirMode&#x3D;1</span><br><span class="line">&quot;显示书签&quot;</span><br><span class="line">let NERDTreeShowBookmarks&#x3D;1</span><br><span class="line">&quot;设置忽略文件类型&quot;</span><br><span class="line">let NERDTreeIgnore&#x3D;[&#39;\~$&#39;, &#39;\.pyc$&#39;, &#39;\.swp$&#39;]</span><br><span class="line">&quot;窗口大小&quot;</span><br><span class="line">let NERDTreeWinSize&#x3D;25</span><br><span class="line"></span><br><span class="line">&quot;split navigations</span><br><span class="line">nnoremap &lt;C-J&gt; &lt;C-W&gt;&lt;C-J&gt;</span><br><span class="line">nnoremap &lt;C-K&gt; &lt;C-W&gt;&lt;C-K&gt;</span><br><span class="line">nnoremap &lt;C-L&gt; &lt;C-W&gt;&lt;C-L&gt;</span><br><span class="line">nnoremap &lt;C-H&gt; &lt;C-W&gt;&lt;C-H&gt;</span><br><span class="line"></span><br><span class="line">&quot;缩进指示线&quot;</span><br><span class="line">let g:indentLine_char&#x3D;&#39;┆&#39;</span><br><span class="line">let g:indentLine_enabled &#x3D; 1</span><br><span class="line"></span><br><span class="line">&quot;autopep8设置&quot;</span><br><span class="line">let g:autopep8_disable_show_diff&#x3D;1</span><br><span class="line"></span><br><span class="line">let mapleader&#x3D;&#39;,&#39;</span><br><span class="line"></span><br><span class="line">map &lt;F4&gt; &lt;leader&gt;ci &lt;CR&gt;</span><br></pre></td></tr></table></figure></li><li><p>在用户主目录下新建一个 .vim 文件夹，并将插件包解压缩至该文件夹</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ mkdir ~&#x2F;.vim</span><br><span class="line">$ tar -jxv -f bundle.tar.bz2 -C ~&#x2F;.vim</span><br></pre></td></tr></table></figure><p>到这里，除了自动补全的插件 YouCompleteMe ，其实大部分的插件都已经起作用了，我们的插件包有几百兆主要就是因为 YouCompleteMe 这个插件比较大，这也是因为这个插件的功能太强大了，这个插件在下载完成后还需要编译安装，接下来就来完成这个步骤。</p></li><li><p>安装 python 和 python 库</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python python-dev</span><br></pre></td></tr></table></figure><p>这一步没有完成在安装的时候可能会碰到下面的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">WARNING: this script is deprecated. Use the install.py script instead.</span><br><span class="line">Searching Python 2.7 libraries...</span><br><span class="line">ERROR: unable to find an appropriate Python library.</span><br></pre></td></tr></table></figure></li><li><p>安装编译环境</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install cmake gcc build-essential</span><br></pre></td></tr></table></figure><p>未完成这步可能会遇到的问题：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">WARNING: this script is deprecated. Use the install.py script instead.</span><br><span class="line">ERROR: Unable to find executable &#39;cmake&#39;. CMake is required to build ycmd</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">No CMAKE_CXX_COMPILER could be found.</span><br></pre></td></tr></table></figure></li><li><p>执行 YouCompleteMe 安装脚本</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ cd ~&#x2F;.vim&#x2F;bundle&#x2F;YouCompleteMe</span><br><span class="line">$ .&#x2F;install.sh</span><br></pre></td></tr></table></figure><p>完成上面的过程就实现了 YouCompleteMe 的安装，接下来就可以体验 vim 强大的功能啦！</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> VIM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
            <tag> vim </tag>
            
            <tag> YouCompleteMe </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu 配置 shadowsocks 客户端</title>
      <link href="2018/08/21/ubuntu%E9%85%8D%E7%BD%AEshadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF/"/>
      <url>2018/08/21/ubuntu%E9%85%8D%E7%BD%AEshadowsocks%E5%AE%A2%E6%88%B7%E7%AB%AF/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>在日常的工作学习中，经常需要搭建各种环境，而很多环境都是由国外开发并开源的，有一些软件或源码必须要到墙外面才能够下载，所以需要在自己的环境中配置 shadowsocks 客户端来连接国外的网络。在这里将介绍如何在 Ubuntu 系统下搭建 shadowsocks 客户端。</p><a id="more"></a><hr><h1 id="安装-shadowsocks"><a href="#安装-shadowsocks" class="headerlink" title="安装 shadowsocks"></a>安装 shadowsocks</h1><ol><li><p>安装 python pip工具</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install python-pip</span><br></pre></td></tr></table></figure></li><li><p>安装 shadowsocks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo pip install shadowsocks</span><br></pre></td></tr></table></figure></li><li><p>配置 shadowsocks</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi &#x2F;etc&#x2F;shadowsocks.json</span><br></pre></td></tr></table></figure><p>输入以下 json 格式的代码：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;server&quot;: &quot;服务器ip&quot;,</span><br><span class="line">    &quot;server_port&quot;: 服务器端口,</span><br><span class="line">    &quot;password&quot;: &quot;你的密码&quot;,</span><br><span class="line">    &quot;method&quot;: &quot;aes-256-cfb&quot;,</span><br><span class="line">    &quot;timeout&quot;: 300</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>启动 shadowsocks 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sslocal -c &#x2F;etc&#x2F;shadowsocks.json &amp;</span><br></pre></td></tr></table></figure><blockquote><p>加上 &amp; 以让 shadowsocks 进程在后台运行</p></blockquote></li><li><p>设置 shadowsocks 开机自启动</p><p>将启动服务的命令添加到 <code>/etc/rc.local</code> 文件中的 <code>exit 0</code> 之前</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi &#x2F;etc&#x2F;rc.local</span><br><span class="line">……</span><br><span class="line">sslocal -c &#x2F;etc&#x2F;shadowsocks.json &amp;</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure><p>以上就是SS的搭建了，这个时候我们发现上网时并不可以翻墙，原因是需要将sock5代理映射为http代理。代理的软件很多，我选择了推荐度比较高的privoxy，下面是privoxy的配置。</p></li></ol><hr><h1 id="安装-privoxy"><a href="#安装-privoxy" class="headerlink" title="安装 privoxy"></a>安装 privoxy</h1><ol><li><p>安装 privoxy</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo apt install privoxy</span><br></pre></td></tr></table></figure></li><li><p>配置 privoxy</p><p>打开 <code>/etc/privoxy/config</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi &#x2F;etc&#x2F;privoxy&#x2F;config</span><br></pre></td></tr></table></figure><p>找到其中的4.1节，看一下有没有一句<code>listen-address localhost:8118</code>的代码，如果被注释了，取消注释。因为版本不一样这句的状态可能会不一样。 然后再将 <code>localhost</code> 改成 <code>127.0.0.1</code>（这一步很重要，反正我因为这一步的设置问题搞了很久都不知道为什么连不上外网），如图所示：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/VPN%E9%85%8D%E7%BD%AEprivoxy%20%E5%9B%BE%E4%B8%80.png" alt="privoxy配置图"></p><p>接着找到5.2节，在本节末尾加入代码 <code>forward-socks5t / 127.0.0.1:1080 .</code>，注意最后有一个点号，如图：</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/VPN%E9%85%8D%E7%BD%AEprivoxy%20%E5%9B%BE%E4%BA%8C.png" alt="privoxy配置图"></p></li><li><p>重启 privoxy 服务</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;privoxy restart</span><br></pre></td></tr></table></figure></li><li><p>设置开机自启动 privoxy 服务</p><p>将启动服务的命令添加到 <code>/etc/rc.local</code> 文件中的 <code>exit 0</code> 之前：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi &#x2F;etc&#x2F;rc.local</span><br><span class="line">……</span><br><span class="line">sslocal -c &#x2F;etc&#x2F;shadowsocks.json &amp;</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;privoxy start</span><br><span class="line">exit 0</span><br></pre></td></tr></table></figure></li><li><p>代理配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ sudo vi &#x2F;etc&#x2F;profile</span><br><span class="line">export http_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:8118</span><br><span class="line">export https_proxy&#x3D;http:&#x2F;&#x2F;127.0.0.1:8118</span><br><span class="line"></span><br><span class="line">$ source &#x2F;etc&#x2F;profile</span><br></pre></td></tr></table></figure></li></ol><hr><h1 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl www.google.com</span><br></pre></td></tr></table></figure><p>或</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wget www.google.com</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ubuntu </tag>
            
            <tag> shadowsocks </tag>
            
            <tag> privoxy </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Vultr CentOS搭建shadowsocks服务端并开启BBR加速</title>
      <link href="2018/08/21/VPS%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B6%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/"/>
      <url>2018/08/21/VPS%E6%90%AD%E5%BB%BAshadowsocks%E6%9C%8D%E5%8A%A1%E7%AB%AF%E5%B9%B6%E5%BC%80%E5%90%AFBBR%E5%8A%A0%E9%80%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>最近教研室很多同学来问有没有公用的 VPN，教研室以前有师兄去买过一些 VPN，但现在师兄也毕业了就用不了了。为了同学们的方便，作为网管应该尽力满足大家日常查阅资料的需求，于是向老师申请了经费去购买了一台 VPS 来搭建教研室公用的 VPN。</p><a id="more"></a><h1 id="购买-VPS"><a href="#购买-VPS" class="headerlink" title="购买 VPS"></a>购买 VPS</h1><p>我这里购买的是 vultr 的 VPS，在新加坡的节点，每个月5美元，其实是按小时计费，每小时0.007美元，如果出问题了可以方便的停止购买，不像其他厂商按年一次性付费的话，万一不能用了就很亏。操作系统选择 CentOS 7 64位。</p><h1 id="安装过程"><a href="#安装过程" class="headerlink" title="安装过程"></a>安装过程</h1><h3 id="安装-Shadowsocks-服务"><a href="#安装-Shadowsocks-服务" class="headerlink" title="安装 Shadowsocks 服务"></a>安装 Shadowsocks 服务</h3><p>shadowsocks有很多版本，如Python，node.js，libev，Go等，Python版本用的人是最多的，但很久没有更新了，这里选择 Go 版本的shadowsocks。</p><p>在安装shadowsocks之前需要先<strong>安装 Go 语言的环境</strong>：</p><ul><li><p>从官网下载 Linux 平台的源码包</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># wget https:&#x2F;&#x2F;dl.google.com&#x2F;go&#x2F;go1.10.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure></li><li><p>解压到指定目录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># sudo tar zxvf go1.10.3.linux-amd64.tar.gz -C &#x2F;usr&#x2F;local&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>配置环境变量</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi .bashrc</span><br><span class="line">添加</span><br><span class="line">export PATH&#x3D;$PATH:&#x2F;usr&#x2F;local&#x2F;go&#x2F;bin</span><br></pre></td></tr></table></figure><p>保存并使生效：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># source .bashrc</span><br></pre></td></tr></table></figure></li></ul><p><strong>安装 shadowsocks</strong>，使用一键安装脚本（<a href="https://github.com/iMeiji/shadowsocks_install%EF%BC%89">https://github.com/iMeiji/shadowsocks_install）</a></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># wget --no-check-certificate https:&#x2F;&#x2F;raw.githubusercontent.com&#x2F;iMeiji&#x2F;shadowsocks_install&#x2F;master&#x2F;shadowsocks-go.sh</span><br><span class="line"># chmod +x shadowsocks-go.sh</span><br><span class="line"># .&#x2F;shadowsocks-go.sh 2&gt;&amp;1 | tee shadowsocks-go.log</span><br></pre></td></tr></table></figure><p><strong>卸载 shadowsocks 方法：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># .&#x2F;shadowsocks-go.sh uninstall</span><br></pre></td></tr></table></figure><p><strong>shadowsocks 常用命令：</strong></p><ul><li>启动：<code>/etc/init.d/shadowsocks start </code></li><li>停止：<code>/etc/init.d/shadowsocks stop</code></li><li>重启：<code>/etc/init.d/shadowsocks restart</code> </li><li>状态：<code>/etc/init.d/shadowsocks status</code></li></ul><p>执行完前面的安装脚本后，查看 shadowsocks 的运行状态：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># &#x2F;etc&#x2F;init.d&#x2F;shadowsocks status</span><br><span class="line">shadowsocks-go running with PID 1629</span><br></pre></td></tr></table></figure><p>能看到进程 ID 说明 shadowsocks 服务已经在运行了。</p><p><strong>配置 shadowsocks 开机自启动：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;rc.local</span><br><span class="line">添加</span><br><span class="line">&#x2F;etc&#x2F;init.d&#x2F;shadowsocks restart</span><br></pre></td></tr></table></figure><p>这样在系统重启后就可以自动加载 shadowsocks 服务了。</p><p><strong>配置防火墙：</strong></p><p>检查防火墙是否允许你设定的端口进行通信</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># iptables -vnL | grep 8989</span><br></pre></td></tr></table></figure><p>如果没有信息的话，就是防火墙不允许该端口进行通信。 </p><p>需设置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># firewall-cmd --zone&#x3D;public --add-port&#x3D;8989&#x2F;tcp --permanent</span><br><span class="line"># firewall-cmd --reload</span><br></pre></td></tr></table></figure><blockquote><p>由于 CentOS 7 默认安装的是 firewalld，并没有安装 iptables-services，不能使用 iptables-save 来保存iptables 规则并在下次启动时自动加载，所以上面使用是 firewalld 来配置永久规则，这样在关机重启后规则也不会消失。</p></blockquote><p>到这里，shadowsocks 服务器就基本上已经配置好了，你可以使用客户端来上外网了。但这时候的网络连接的速度可能只能够保证查查网页，如果要下载或者看 YouTube 速度很慢，所以后将进行配置TCP 加速。</p><hr><h3 id="TCP-加速"><a href="#TCP-加速" class="headerlink" title="TCP 加速"></a>TCP 加速</h3><p>在后面会升级系统内核，所以先查看一下服务器的内核版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uname -a</span><br><span class="line">Linux vultr.guest 3.10.0-862.3.2.el7.x86_64 #1 SMP Mon May 21 23:36:36 UTC 2018 x86_64 x86_64 x86_64 GNU&#x2F;Linux</span><br></pre></td></tr></table></figure><p>加速有锐速加速和 Google BBR 加速，这里使用 BBR 加速。TCP BBR是谷歌出品的 TCP 拥塞控制算法，目的是要尽量跑满带宽，并且尽量不要有排队的情况。BBR 可以起到单边加速 TCP 连接的效果。</p><p>Google提交到Linux主线并发表在ACM  queue期刊上的TCP-BBR拥塞控制算法。继承了Google“先在生产环境上部署，再开源和发论文”的研究传统。TCP-BBR已经再YouTube服务器和Google跨数据中心的内部广域网(B4)上部署。由此可见出该算法的前途。 </p><p>TCP-BBR的目标就是最大化利用网络上瓶颈链路的带宽。一条网络链路就像一条水管，要想最大化利用这条水管，最好的办法就是给这跟水管灌满水。 </p><p>BBR解决了两个问题： </p><ul><li>在有一定丢包率的网络链路上充分利用带宽。非常适合高延迟，高带宽的网络链路。 </li><li>降低网络链路上的buffer占用率，从而降低延迟。非常适合慢速接入网络的用户。 </li></ul><p>Google 在 2016年9月份开源了他们的优化网络拥堵算法BBR，最新版本的 Linux内核(4.9-rc8)中已经集成了该算法。 </p><p><strong>一键安装脚本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># wget --no-check-certificate https:&#x2F;&#x2F;github.com&#x2F;teddysun&#x2F;across&#x2F;raw&#x2F;master&#x2F;bbr.sh</span><br><span class="line"># chmod +x bbr.sh</span><br><span class="line"># .&#x2F;bbr.sh</span><br></pre></td></tr></table></figure><p>安装完成后会提示重启，重启完成后，查看内核：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># uname -r</span><br><span class="line">4.18.3-1.el7.elrepo.x86_64</span><br></pre></td></tr></table></figure><p>高于 4.9 就可以了</p><p>检查是否开启 BBR：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"># sysctl net.ipv4.tcp_available_congestion_control</span><br><span class="line">net.ipv4.tcp_available_congestion_control &#x3D; reno cubic bbr</span><br><span class="line"></span><br><span class="line"># sysctl net.ipv4.tcp_congestion_control</span><br><span class="line">net.ipv4.tcp_congestion_control &#x3D; bbr</span><br><span class="line"></span><br><span class="line"># sysctl net.core.default_qdisc</span><br><span class="line">net.core.default_qdisc &#x3D; fq</span><br><span class="line"></span><br><span class="line"># lsmod | grep bbr</span><br><span class="line">tcp_bbr                20480  7</span><br><span class="line">#返回值有 tcp_bbr 则说明已经启动</span><br></pre></td></tr></table></figure><p>完成以上步骤，则 TCP 加速也已经配置好了，接下来就可以体验飞快的下载速度以及 1080p 的高清视屏啦！</p><p>shadowsocks 客户端下载连接：<a href="https://shadowsocks.org/en/download/clients.html">Shadowsocks - Clients</a> </p>]]></content>
      
      
      <categories>
          
          <category> VPN </category>
          
      </categories>
      
      
        <tags>
            
            <tag> centos </tag>
            
            <tag> shadowsocks </tag>
            
            <tag> BBR </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVM 虚拟机磁盘扩容</title>
      <link href="2018/07/24/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/"/>
      <url>2018/07/24/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E7%A3%81%E7%9B%98%E6%89%A9%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在 KVM 环境中，通常通过创建一个各种格式的磁盘来安装虚拟机，可能创建时你觉得大小够用，但是可能用着用着到了某一天你发现你的磁盘容量不够用了，很多程序都打不开，你可能会很慌，其实并不需要慌，因为有很多方法可以给你的虚拟机扩容，哈哈哈，如：</p><ul><li>通过<code>virsh attach-disk</code>添加一个新的磁盘</li><li>通过<code>virsh attach-device</code>添加一个新的存储设备</li><li>直接给原来用的磁盘扩容</li></ul><a id="more"></a><p>上面的三种方法都能实现给你的虚拟机扩容，但是本文想介绍的是第三种方法，直接给安装了虚拟机的磁盘来扩容，这样的好处是在你的主机上看来一个虚拟机就是一个磁盘，管理方便，而且只通过这一个磁盘来分享迁移你的虚拟机，也是更方便。</p><p>#创建虚拟机</p><ol><li><p><strong>创建磁盘</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img create -f qcow2 centos.qcow2 50G</span><br></pre></td></tr></table></figure><p>这里创建了一个50G的磁盘，格式为qcow2，这种格式的特点是分配给虚拟机的实际使用的磁盘的大小是动态增长的，并不是一下子把所有的空间都给配给虚拟机，可以通过命令查看磁盘信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ qemu-img info centos.qcow2</span><br><span class="line">image: centos.qcow2</span><br><span class="line">file format: qcow2</span><br><span class="line">virtual size: 50G (53687091200 bytes)</span><br><span class="line">disk size: 1.2G</span><br><span class="line">cluster_size: 65536</span><br><span class="line">Format specific information:</span><br><span class="line">    compat: 1.1</span><br><span class="line">    lazy refcounts: false</span><br><span class="line">    refcount bits: 16</span><br><span class="line">    corrupt: false</span><br></pre></td></tr></table></figure><p>可以看到50G的磁盘目前的实际大小只有1.2个G。</p></li><li><p><strong>安装虚拟机</strong></p><p>可以通过 virt-manager 通过图形界面安装，但是我一般都是通过远程连接服务器的，所以常用命令行安装虚拟机，命令如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ virt-install --virt-type kvm --name test-centos --ram 2048 --vcpus&#x3D;1 \</span><br><span class="line">--cdrom CentOS-7-x86_64-Minimal-1804.iso \</span><br><span class="line">--disk path&#x3D;test-centos.qcow2,format&#x3D;qcow2 \</span><br><span class="line">--network network&#x3D;default,model&#x3D;virtio \</span><br><span class="line">--graphics vnc,listen&#x3D;0.0.0.0 --noautoconsole \</span><br><span class="line">--os-type&#x3D;linux</span><br></pre></td></tr></table></figure><p>系统安装的过程就不介绍了，但在安装系统的过程中，对于磁盘分区部分一般分两个区，根目录 <code>/</code> 和 交换分区 <code>swap</code> 。</p></li><li><p><strong>查看虚拟机磁盘</strong></p><ul><li><p>查看磁盘空间信息</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ df -lh</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;sda2        46G  1.1G   45G   3% &#x2F;</span><br><span class="line">devtmpfs        909M     0  909M   0% &#x2F;dev</span><br><span class="line">tmpfs           920M     0  920M   0% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           920M  8.5M  911M   1% &#x2F;run</span><br><span class="line">tmpfs           920M     0  920M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">tmpfs           184M     0  184M   0% &#x2F;run&#x2F;user&#x2F;1000</span><br><span class="line">tmpfs           184M     0  184M   0% &#x2F;run&#x2F;user&#x2F;0</span><br></pre></td></tr></table></figure><p>可以看到 <code>/dev/sda2</code> 被挂载到了系统根目录 <code>/</code> </p></li><li><p>查看系统磁盘分区</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"># fdisk -l</span><br><span class="line">Disk &#x2F;dev&#x2F;sda: 53.7 GB, 53687091200 bytes, 104857600 sectors</span><br><span class="line">Units &#x3D; sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00015299</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">&#x2F;dev&#x2F;sda1            2048     8390655     4194304   82  Linux swap &#x2F; Solaris</span><br><span class="line">&#x2F;dev&#x2F;sda2   *     8390656   104857599    48233472   83  Linux</span><br></pre></td></tr></table></figure><p>我这里系统磁盘被成了两个区：/dev/sda1 和 /dev/sda2，就是我们前面说的一个用于交换分区，另一个用于挂载到根目录。</p><blockquote><p>注：磁盘分区信息中可以看到原来我们 50个G 的磁盘到这里怎么变成 53.7GB 了呢？其实只是单位不一样而已，前面我们用的是 GiB 为单位，这两个单位的计算方式不同，<code>1 GiB = 1024*1024*1024 Bytes</code>，而 <code>1GB = 1000*1000*1000 Bytes</code> 。</p></blockquote><p>到这里，假如我们发现磁盘空间不够用了，接下来就来看看如何给虚拟机的磁盘扩容吧。</p></li></ul></li></ol><h1 id="磁盘扩容"><a href="#磁盘扩容" class="headerlink" title="磁盘扩容"></a>磁盘扩容</h1><ol><li><p>首先将我们的虚拟机关机，然后进行<strong>磁盘扩容</strong>，在服务器主机上操作：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># qemu-img resize centos.qcow2 60G</span><br><span class="line">Image resized.</span><br></pre></td></tr></table></figure><p>上面我们把磁盘大小扩成了 60G</p></li><li><p>重启虚拟机，在虚拟机内，使用 <code>fdisk</code> 指令<strong>对磁盘进行分区：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"># fdisk &#x2F;dev&#x2F;sda     #我们的整块磁盘是sda，对整个磁盘进行分区</span><br><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk &#x2F;dev&#x2F;sda: 64.4 GB, 64424509440 bytes, 125829120 sectors   #磁盘大小变成64.4GB了，扩容成功</span><br><span class="line">Units &#x3D; sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00015299</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">&#x2F;dev&#x2F;sda1            2048     8390655     4194304   82  Linux swap &#x2F; Solaris</span><br><span class="line">&#x2F;dev&#x2F;sda2   *     8390656   104857599    48233472   83  Linux   #结束sector号小于磁盘的总数</span><br><span class="line"></span><br><span class="line">Command (m for help): n</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (2 primary, 0 extended, 2 free)</span><br><span class="line">   e   extended</span><br><span class="line">Select (default p): e    #添加扩展分区</span><br><span class="line">Partition number (3,4, default 3): 3  #分区号，填写默认的3</span><br><span class="line">First sector (104857600-125829119, default 104857600):   #直接回车选择默认</span><br><span class="line">Using default value 104857600</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (104857600-125829119, default 125829119): #回车选择默认 </span><br><span class="line">Using default value 125829119</span><br><span class="line">Partition 3 of type Extended and of size 10 GiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): p    #再次查看分区表</span><br><span class="line"></span><br><span class="line">Disk &#x2F;dev&#x2F;sda: 64.4 GB, 64424509440 bytes, 125829120 sectors</span><br><span class="line">Units &#x3D; sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00015299</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">&#x2F;dev&#x2F;sda1            2048     8390655     4194304   82  Linux swap &#x2F; Solaris</span><br><span class="line">&#x2F;dev&#x2F;sda2   *     8390656   104857599    48233472   83  Linux</span><br><span class="line">&#x2F;dev&#x2F;sda3       104857600   125829119    10485760    5  Extended   #新添加的扩展分区</span><br><span class="line"></span><br><span class="line">Command (m for help): n    #再添加逻辑分区，因为扩展分区是不能格式化后挂载的</span><br><span class="line">Partition type:</span><br><span class="line">   p   primary (2 primary, 1 extended, 1 free)</span><br><span class="line">   l   logical (numbered from 5)</span><br><span class="line">Select (default p): l    #逻辑分区</span><br><span class="line">Adding logical partition 5</span><br><span class="line">First sector (104859648-125829119, default 104859648):   #回车选择默认</span><br><span class="line">Using default value 104859648</span><br><span class="line">Last sector, +sectors or +size&#123;K,M,G&#125; (104859648-125829119, default 125829119): #回车选择默认</span><br><span class="line">Using default value 125829119</span><br><span class="line">Partition 5 of type Linux and of size 10 GiB is set</span><br><span class="line"></span><br><span class="line">Command (m for help): p</span><br><span class="line"></span><br><span class="line">Disk &#x2F;dev&#x2F;sda: 64.4 GB, 64424509440 bytes, 125829120 sectors</span><br><span class="line">Units &#x3D; sectors of 1 * 512 &#x3D; 512 bytes</span><br><span class="line">Sector size (logical&#x2F;physical): 512 bytes &#x2F; 512 bytes</span><br><span class="line">I&#x2F;O size (minimum&#x2F;optimal): 512 bytes &#x2F; 512 bytes</span><br><span class="line">Disk label type: dos</span><br><span class="line">Disk identifier: 0x00015299</span><br><span class="line"></span><br><span class="line">   Device Boot      Start         End      Blocks   Id  System</span><br><span class="line">&#x2F;dev&#x2F;sda1            2048     8390655     4194304   82  Linux swap &#x2F; Solaris</span><br><span class="line">&#x2F;dev&#x2F;sda2   *     8390656   104857599    48233472   83  Linux</span><br><span class="line">&#x2F;dev&#x2F;sda3       104857600   125829119    10485760    5  Extended</span><br><span class="line">&#x2F;dev&#x2F;sda5       104859648   125829119    10484736   83  Linux   #新添加的逻辑分区</span><br><span class="line"></span><br><span class="line">Command (m for help): w   #保存分区配置，并退出 </span><br><span class="line">The partition table has been altered!</span><br><span class="line"></span><br><span class="line">Calling ioctl() to re-read partition table.</span><br><span class="line"></span><br><span class="line">WARNING: Re-reading the partition table failed with error 16: Device or resource busy.</span><br><span class="line">The kernel still uses the old table. The new table will be used at</span><br><span class="line">the next reboot or after you run partprobe(8) or kpartx(8)</span><br><span class="line">Syncing disks.    #需要重启或者重新获取分区表</span><br><span class="line"># </span><br></pre></td></tr></table></figure></li><li><p><strong>重新获取分区表：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># partprobe</span><br></pre></td></tr></table></figure></li><li><p><strong>格式化分区：</strong></p><p>可以先查看一下其他分区是什么格式的文件系统：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mount |grep &#x2F;dev&#x2F;sda</span><br><span class="line">&#x2F;dev&#x2F;sda2 on &#x2F; type xfs (rw,relatime,seclabel,attr2,inode64,noquota)</span><br></pre></td></tr></table></figure><p><code>/dev/sda2</code> 是 <code>xfs</code> 格式的，CentOS 7默认文件系统格式是xfs，在CentOS 6以及之前的版本，使用的是ext文件系统格式，CentOS 6是ext4格式、CentOS 5是ext3格式。那我们也把 <code>/dev/sda5</code> 格式化成一样格式的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># mkfs -t xfs &#x2F;dev&#x2F;sda5     #-t 指定格式 </span><br><span class="line">meta-data&#x3D;&#x2F;dev&#x2F;sda5              isize&#x3D;512    agcount&#x3D;4, agsize&#x3D;655296 blks</span><br><span class="line">         &#x3D;                       sectsz&#x3D;512   attr&#x3D;2, projid32bit&#x3D;1</span><br><span class="line">         &#x3D;                       crc&#x3D;1        finobt&#x3D;0, sparse&#x3D;0</span><br><span class="line">data     &#x3D;                       bsize&#x3D;4096   blocks&#x3D;2621184, imaxpct&#x3D;25</span><br><span class="line">         &#x3D;                       sunit&#x3D;0      swidth&#x3D;0 blks</span><br><span class="line">naming   &#x3D;version 2              bsize&#x3D;4096   ascii-ci&#x3D;0 ftype&#x3D;1</span><br><span class="line">log      &#x3D;internal log           bsize&#x3D;4096   blocks&#x3D;2560, version&#x3D;2</span><br><span class="line">         &#x3D;                       sectsz&#x3D;512   sunit&#x3D;0 blks, lazy-count&#x3D;1</span><br><span class="line">realtime &#x3D;none                   extsz&#x3D;4096   blocks&#x3D;0, rtextents&#x3D;0</span><br></pre></td></tr></table></figure></li><li><p><strong>挂载磁盘：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount &#x2F;dev&#x2F;sda5  &#x2F;mnt&#x2F;newdisk</span><br></pre></td></tr></table></figure><p>将 <code>/dev/sda5</code> 挂载到 <code>/mnt/newdisk</code>，需要注意的是，<code>newdisk</code> 最好是一个空文件夹，不然挂载之后文件夹内的文件将会暂时隐藏，直到你卸载到磁盘后才能恢复。</p></li><li><p><strong>查看磁盘空间信息：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"># df -lh</span><br><span class="line">Filesystem      Size  Used Avail Use% Mounted on</span><br><span class="line">&#x2F;dev&#x2F;sda2        46G  1.1G   45G   3% &#x2F;</span><br><span class="line">devtmpfs        909M     0  909M   0% &#x2F;dev</span><br><span class="line">tmpfs           920M     0  920M   0% &#x2F;dev&#x2F;shm</span><br><span class="line">tmpfs           920M  8.5M  911M   1% &#x2F;run</span><br><span class="line">tmpfs           920M     0  920M   0% &#x2F;sys&#x2F;fs&#x2F;cgroup</span><br><span class="line">tmpfs           184M     0  184M   0% &#x2F;run&#x2F;user&#x2F;1000</span><br><span class="line">&#x2F;dev&#x2F;sda5        10G   33M   10G   1% &#x2F;mnt&#x2F;newdisk</span><br></pre></td></tr></table></figure><p>到这里就基本上结束了，你的磁盘又多了 10个G 的容量，可以正常读写磁盘啦。</p></li></ol><h1 id="命令附录"><a href="#命令附录" class="headerlink" title="命令附录"></a>命令附录</h1><p>这里先介绍几个会用到的关于Linux磁盘操作指令：</p><ol><li><p><strong>df 指令</strong>：磁盘信息命令 </p><ul><li><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ df [OPTION]... [FILE]...</span><br></pre></td></tr></table></figure></li><li><p>功能说明：</p><blockquote><p>使用 df 指令查看磁盘空间的信息。指令可以查看指定文件系统的占用情况。如果指令中未指定文件名，将显示当前所有挂载的文件系统的可用空间。</p></blockquote></li><li><p>参数说明：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-a</td><td align="center">显示包括0区块在内的所有文件系统的情况</td></tr><tr><td align="center">-h</td><td align="center">以可读性较高的方式显示信息</td></tr><tr><td align="center">-H</td><td align="center">相当于“-h”但在计算时，1K=1000，而不是1024</td></tr><tr><td align="center">-i</td><td align="center">显示 inode 节点信息</td></tr><tr><td align="center">-k</td><td align="center">区块大小为1024字节</td></tr><tr><td align="center">-l</td><td align="center">尽显示本地文件系统</td></tr><tr><td align="center">–no-sync</td><td align="center">取得磁盘信息前，忽略 sync 指令</td></tr><tr><td align="center">-P</td><td align="center">输出 POSIX 格式</td></tr><tr><td align="center">–sync</td><td align="center">在取得磁盘信息前，先执行 sync 指令</td></tr><tr><td align="center">-T</td><td align="center">显示文件系统类型</td></tr><tr><td align="center">–block-size=<size></td><td align="center">指定区块大小</td></tr><tr><td align="center">-t filesystem-type</td><td align="center">只显示选定文件系统的磁盘信息</td></tr><tr><td align="center">-x filesystem-type</td><td align="center">不显示选定文件系统的磁盘信息</td></tr><tr><td align="center">–help</td><td align="center">帮助信息</td></tr><tr><td align="center">–version</td><td align="center">版本信息</td></tr></tbody></table></li><li><p>常用命令：<code>$ df -lh</code></p></li></ul></li><li><p><strong>fdisk 指令</strong>：Linux磁盘分区命令 </p><ul><li><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">fdisk [options] &lt;disk&gt;    change partition table</span><br><span class="line">fdisk [options] -l &lt;disk&gt; list partition table(s)</span><br><span class="line">fdisk -s &lt;partition&gt;      give partition size(s) in blocks</span><br></pre></td></tr></table></figure></li><li><p>功能说明：</p><blockquote><p>fdisk 指令是Linux下管理分区的程序。应用该程序不仅可以创建磁盘分区，还可以对磁盘进行维护，改变分区类型。</p></blockquote></li><li><p>参数说明：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-b <size></td><td align="center">指定各分区大小</td></tr><tr><td align="center">-l</td><td align="center">列出分区表情况</td></tr><tr><td align="center">-s <number></td><td align="center">输出指定分区大小到标准输出设备</td></tr><tr><td align="center">-u</td><td align="center">与“-l”参数搭配，显示分区数目</td></tr><tr><td align="center">-v</td><td align="center">版本信息</td></tr></tbody></table><p>【fdisk 程序指令】</p><ul><li><strong>a：</strong>设置/删除可引导分区标记</li><li><strong>d：</strong>删除指定分区</li><li><strong>l：</strong>列出分区类型</li><li><strong>m：</strong>显示 fdisk 程序指令</li><li><strong>n：</strong>新建分区</li><li><strong>p：</strong>列出当前分区信息</li><li><strong>q：</strong>退出 fdisk 分区，对更改不保存</li><li><strong>t：</strong>改变分区 ID</li><li><strong>v：</strong>检测当前分区信息</li><li><strong>w：</strong>退出 fdisk 分区，保存更改</li></ul><p><strong>注：</strong>不同的版本略差别</p></li></ul></li><li><p><strong>mkfs 指令</strong>：建立各种文件系统</p><ul><li><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkfs [options] [-t &lt;type&gt;] [fs-options] &lt;device&gt; [&lt;size&gt;]</span><br></pre></td></tr></table></figure></li><li><p>功能说明：</p><blockquote><p> mkfs 指令可用来在指定的设备上建立各种文件系统，它通过调用相关的程序来执行文件系统的构建，本身并不执行系统构建。</p></blockquote></li><li><p>参数说明：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center">-c</td><td align="center">在创建文件系统之前，检查是否有损坏的区块</td></tr><tr><td align="center">fs</td><td align="center">指定建立文件系统时的参数，针对不同的文件系统的参数不同</td></tr><tr><td align="center">-t <filesystem type></td><td align="center">指定要创建的文件系统的类型，默认为ext2</td></tr><tr><td align="center">-v</td><td align="center">显示详细的处理信息</td></tr><tr><td align="center">-V</td><td align="center">版本信息</td></tr></tbody></table></li><li><p>常用命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mkfs -t ext3 &#x2F;dev&#x2F;sda3</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>mount 指令</strong>：挂载文件系统</p><ul><li><p>语法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount [options] &lt;source&gt; &lt;directory&gt;</span><br></pre></td></tr></table></figure></li><li><p>功能说明：</p><blockquote><p> 使用 mount 指令可将指定设备挂载到已存在的目录。当文件系统挂载完成后，用户可通过该目录进行操作，来实现对指定设备的文件读写等操作。</p></blockquote></li><li><p>必要参数说明：</p><table><thead><tr><th align="center">参数</th><th align="center">说明</th></tr></thead><tbody><tr><td align="center"><souce></td><td align="center">指定要挂载的设备</td></tr><tr><td align="center"><directory></td><td align="center">指定要挂载的目录</td></tr></tbody></table></li><li><p>常用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"># mount &#x2F;dev&#x2F;sda3  &#x2F;mnt</span><br></pre></td></tr></table></figure></li></ul></li></ol><hr>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> 磁盘扩容 </tag>
            
            <tag> df </tag>
            
            <tag> fdisk </tag>
            
            <tag> mkfs </tag>
            
            <tag> mount </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于Linux Shell新的收获</title>
      <link href="2018/07/21/%E5%85%B3%E4%BA%8EShell%E6%96%B0%E7%9A%84%E6%94%B6%E8%8E%B7/"/>
      <url>2018/07/21/%E5%85%B3%E4%BA%8EShell%E6%96%B0%E7%9A%84%E6%94%B6%E8%8E%B7/</url>
      
        <content type="html"><![CDATA[<p>最近又翻阅了几本Linux相关的工具书，在这里记录一些关于Linux shell的新的小小的收获。</p><a id="more"></a><h1 id="查看正在使用的shell"><a href="#查看正在使用的shell" class="headerlink" title="查看正在使用的shell"></a>查看正在使用的shell</h1><p>有很多方法可以查看当前正在使用的shell：</p><ul><li><p>使用特殊参数<code>$0</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $0</span><br><span class="line">-bash</span><br></pre></td></tr></table></figure><p>对于这里有点疑问的是有资料说在<strong>本地系统</strong>执行可能的结果会是<code>/bin/bash</code>，但是我尝试了一下发现结果还是<code>bash</code>或者<code>-bash</code>。不知道资料中说的本地系统指的是什么意思。</p></li><li><p>输入不存在的命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ asdf</span><br><span class="line">-bash: asdf: command not found</span><br></pre></td></tr></table></figure><p>从shell提示中可以看出当前正在使用的shell是bash。</p></li></ul><h1 id="查看用户登录默认的shell"><a href="#查看用户登录默认的shell" class="headerlink" title="查看用户登录默认的shell"></a>查看用户登录默认的shell</h1><ul><li><p>通过查看<code>/etc/passwd</code>文件找到用户对应的那一行，最后一列就是用户登录的shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">user1@ubuntu:~$ cat &#x2F;etc&#x2F;passwd | grep user1</span><br><span class="line">user1:x:1000:1000:user1,,,:&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li><li><p>最常用的方法：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure></li><li><p>从环境变量中查看：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ env |grep SHELL</span><br><span class="line">SHELL&#x3D;&#x2F;bin&#x2F;bash</span><br></pre></td></tr></table></figure><h1 id="切换用户正在使用的shell"><a href="#切换用户正在使用的shell" class="headerlink" title="切换用户正在使用的shell"></a>切换用户正在使用的shell</h1></li></ul><p>直接输入对应shell的命令即可切换：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ echo $0</span><br><span class="line">-bash    &lt;&#x3D;&#x3D;当前正在使用的shell</span><br><span class="line">$ zsh    &lt;&#x3D;&#x3D;运行zsh</span><br><span class="line">$ echo $0</span><br><span class="line">zsh      &lt;&#x3D;&#x3D;当前正在使用的shell已经变成zsh</span><br></pre></td></tr></table></figure><h1 id="修改用户的登录shell"><a href="#修改用户的登录shell" class="headerlink" title="修改用户的登录shell"></a>修改用户的登录shell</h1><ul><li><p>首先可以查看用户合法的shell：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -l</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;sbin&#x2F;nologin   &lt;&#x3D;&#x3D;合法不可登录的shell</span><br><span class="line">&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;bin&#x2F;csh</span><br><span class="line">&#x2F;bin&#x2F;mksh</span><br><span class="line">&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure><p><code>chsh -l</code>命令并不总是可用，对于某些Linux发行版，<code>chsh</code>命令没有<code>-l</code>的选项，如<code>ubuntu16.04</code>，但是可以直接查看/etc/shells文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ cat &#x2F;etc&#x2F;shells</span><br><span class="line">&#x2F;bin&#x2F;sh</span><br><span class="line">&#x2F;bin&#x2F;bash</span><br><span class="line">&#x2F;sbin&#x2F;nologin   &lt;&#x3D;&#x3D;合法不可登录的shell</span><br><span class="line">&#x2F;bin&#x2F;tcsh</span><br><span class="line">&#x2F;bin&#x2F;csh</span><br><span class="line">&#x2F;bin&#x2F;mksh</span><br><span class="line">&#x2F;bin&#x2F;ksh</span><br><span class="line">&#x2F;bin&#x2F;zsh</span><br></pre></td></tr></table></figure></li><li><p>修改用户登录shell</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ chsh -s &#x2F;bin&#x2F;zsh</span><br><span class="line">Password:</span><br><span class="line">$ cat &#x2F;etc&#x2F;passwd | grep user1</span><br><span class="line">user1:x:1000:1000:user1,,,:&#x2F;home&#x2F;user1:&#x2F;bin&#x2F;zsh   &lt;&#x3D;&#x3D; &#x2F;etc&#x2F;passwd文件中已经发生变化</span><br><span class="line">$ echo $SHELL</span><br><span class="line">&#x2F;bin&#x2F;bash      &lt;&#x3D;&#x3D;但是再次查看$SHELL，发现并没有变，其实退出shell再次登录就会看到变化了</span><br></pre></td></tr></table></figure></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Shell </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> linux </tag>
            
            <tag> chsh </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自动化脚本与程序实现</title>
      <link href="2018/07/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/"/>
      <url>2018/07/09/%E8%87%AA%E5%8A%A8%E5%8C%96%E8%84%9A%E6%9C%AC%E4%B8%8E%E7%A8%8B%E5%BA%8F%E5%AE%9E%E7%8E%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>最近的项目中有远程登录虚拟机并执行相关命令的需求，所以尝试了远程免密码登录虚拟机（在另一篇博客中有介绍<a href="https://cao0507.github.io/2018/07/07/%E8%BF%9C%E7%A8%8B%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Openstack%E5%AE%9E%E4%BE%8B/">链接</a>)。但是发现这还不够，因为登录远程虚拟机后执行的脚本可能会有需要交互的操作，比如<code>sudo</code>命令需要输入密码，所以就想实现一个完全自动化的脚本，包括登录时的密码自动输入以及登录后执行命令的自动交互。查阅相关资料后学习到，在Linux中可以用<code>expect</code>来实现自动化的交互，且在python中也有相应的一个模块pexpect具有此功能。本文将先介绍<strong>shell自动化交互脚本</strong>的实现，然后介绍其<strong>python程序实现</strong>。</p><a id="more"></a><h1 id="shell脚本"><a href="#shell脚本" class="headerlink" title="shell脚本"></a>shell脚本</h1><h2 id="Expect介绍"><a href="#Expect介绍" class="headerlink" title="Expect介绍"></a>Expect介绍</h2><ol><li><p>简要介绍：</p><p>Expect 是由Don Libes基于<code>Tcl（Tool Command Language）</code>语言开发的，主要应用于自动化交互式操作的场景，借助expect处理交互的命令，可以将交互过程如：ssh登录，ftp登录等写在一个脚本上，使之自动化完成。尤其适用于需要对多台服务器执行相同操作的环境中，可以大大提高系统管理人员的工作效率 。</p></li><li><p>主要命令：</p><ul><li><p><strong>spawn</strong>：启动新的进程</p><p><code>spawn</code>命令会<code>fork</code>一个子进程去执行<code>command</code>命令，然后在此子进程中执行后面的命令；<code>spawn</code>后的<code>send</code>和<code>expect</code>命令都是和<code>spawn</code>打开的进程进行交互的。如果没有<code>spawn</code>语句，整个<code>Expect</code>就无法进行下去，当然，如果真的不要<code>spawn</code>过程也没有关系，虽然这样就没有办法单独执行，但是这个脚本可以与任何调用它的进程进行交互。 </p><p><strong>使用方法：</strong>ssh自动登录脚本中，通过<code>spawn ssh user_name@ip_addr</code>，<code>fork</code>一个子进程执行ssh登录命令；连接远程ftp服务器，<code>spawn ftp ftp.server.com</code>。</p></li><li><p><strong>expect</strong>：从进程接收字符串</p><p><code>expect</code>命令是Expect解释器的关键命令，它的一般用法为 <code>expect “string”</code>，即期望获取到<code>string</code>字符串，可在在<code>string</code>字符串里使用 * 等通配符。</p><p><strong>使用方法：</strong>在执行<code>spawn</code>命令ssh登录时，子进程会要求输入密码，因此可以使用<code>expect</code>命令检查子进程中的输出中是否包含<code>“password”</code>子字符串，命令为<code>expect &quot;password&quot;</code>。</p></li><li><p><strong>send</strong>：用于向进程发送字符串</p><p>send命令的一般用法为 send “string”，它们会我们平常输入命令一样向命令行输入一条信息，当然不要忘了在string后面添加上 \r 表示输入回车 。</p><p><strong>使用方法：</strong>在使用expect命令接收到字符串“password”后，就需要使用send命令来发送“PASSWORD”。</p></li><li><p><strong>interact</strong>：允许用户交互</p><p><code>interact</code>命令很简单，执行到此命令时，脚本<code>fork</code>的子进程会将操作权交给用户，允许用户与当前shell进行交互，让人在适当的时候干预这个过程了 。</p><p><strong>使用方法：</strong>直接在脚本适当的位置加入一行<code>interact</code>。</p></li></ul></li><li><p>安装方法：</p><p><code>$ sudo apt-get install expect</code></p></li></ol><h2 id="脚本编写"><a href="#脚本编写" class="headerlink" title="脚本编写"></a>脚本编写</h2><p>我需要实现一个脚本，其功能是ssh登录虚拟机，并在远程虚拟机用户目录下记录远程登录的日志文件，然后修改其<code>iptables</code>规则，禁止转发tcp 22号端口的报文。</p><ul><li><p>ssh登录</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;(yes&#x2F;no)&quot; &#123;send &quot;yes\r&quot;; exp_continue&#125;</span><br><span class="line">    &quot;password:&quot; &#123;send &quot;$password\r&quot;&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>expect中可能会接收到两种字符串，”(yes/no)”表示你的主机还未登录过远程虚拟机，即你的用户目录下的文件<code>~/.ssh/know_hosts</code>中还未记录该远程虚拟机，问你是否需要将其添加到<code>know_hosts</code>中，回复”yes”，下次再登录就不会出现这个提醒了；然后就会收到<code>&quot;password:&quot;</code>，这时就需要将密码发送过去，这样就已经登录到远程虚拟机。</p></li><li><p>记录日志文件</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect &quot;*$&quot; &#123;send &quot;echo &#39;login +1&#39; &gt;&gt; ~&#x2F;remote_login.log\r&quot;&#125;</span><br></pre></td></tr></table></figure><p>登录之后会收到”$”或”#”的命令行提示符，然后就可以发送需要执行的命令了。</p></li><li><p>修改<code>iptables</code>规则</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">expect &quot;*$&quot; &#123;send &quot;sudo iptables -A FORWARD -p tcp --dport 22 -j REJECT\r&quot;&#125;</span><br><span class="line">expect &quot;password&quot; &#123;send &quot;$password\r&quot;&#125;</span><br></pre></td></tr></table></figure></li><li><p>退出子程序</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">expect &quot;*$&quot; &#123;send exit\r&#125;</span><br></pre></td></tr></table></figure></li></ul><p><strong>完整的脚本：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#!&#x2F;usr&#x2F;bin&#x2F;expect</span><br><span class="line">set ip 192.168.1.75</span><br><span class="line">set user openstack</span><br><span class="line">set passwd 123456</span><br><span class="line">set timeout 5</span><br><span class="line"></span><br><span class="line">spawn ssh $user@$ip</span><br><span class="line">expect &#123;</span><br><span class="line">    &quot;(yes&#x2F;no)&quot; &#123;send &quot;yes\r&quot;; exp_continue&#125;</span><br><span class="line">    &quot;password:&quot; &#123;send &quot;$password\r&quot;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">expect &quot;*$&quot; &#123;send &quot;echo &#39;login +1&#39; &gt;&gt; ~&#x2F;remote_login.log\r&quot;&#125;;</span><br><span class="line"></span><br><span class="line">expect &quot;*$&quot; &#123;send &quot;sudo iptables -A FORWARD -p tcp --dport 22 -j REJECT\r&quot;&#125;;</span><br><span class="line">expect &quot;password&quot; &#123;send &quot;$passwd\r&quot;&#125;;</span><br><span class="line"></span><br><span class="line">expect &quot;*$&quot; &#123;send exit\r&#125;;</span><br><span class="line">expect eof;</span><br></pre></td></tr></table></figure><h1 id="python程序"><a href="#python程序" class="headerlink" title="python程序"></a>python程序</h1><h2 id="Pexpect介绍"><a href="#Pexpect介绍" class="headerlink" title="Pexpect介绍"></a>Pexpect介绍</h2><p>Pexpect 是Expect 的一个 Python 实现，是一个用来启动子程序，并使用正则表达式对程序输出做出特定响应，以此实现与其自动交互的 Python 模块。 Pexpect 的使用范围很广，可以用来实现与 <code>ssh、ftp 、telnet</code>  等程序的自动交互；可以用来自动复制软件安装包并在不同机器自动安装；还可以用来实现软件测试中与命令行交互的自动化。</p><p>其依赖 <code>pty module</code> ，所以 <code>Pexpect</code> 还不能在 Windows 的标准 python 环境中执行，如果想在 Windows 平台使用，可以使用在 Windows 中运行 Cygwin 做为替代方案。</p><p><code>pexpect</code>主要包含两个接口，一个是<code>run()</code>函数，另一个是<code>spawn</code>类。<code>spawn</code>类的功能很强大，<code>run()</code>函数要更简单，更适用于快速调用程序。</p><ol><li><p><code>spawn class</code></p><p>使用这个类来开始和控制子程序。</p><ul><li><p><code>spawn</code>的构造函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">class spawn:</span><br><span class="line">    def __init__(self,command,args&#x3D;[],timeout&#x3D;30,maxread&#x3D;2000,\</span><br><span class="line">    searchwindowsize&#x3D;None, logfile&#x3D;None, cwd&#x3D;None, env&#x3D;None)</span><br></pre></td></tr></table></figure><p><code>spawn</code>是<code>Pexpect</code>模块主要的类，用以实现启动子程序，它有丰富的方法与子程序交互从而实现用户对子程序的控制。它主要使用 <code>pty.fork()</code> 生成子进程，并调用 <code>exec()</code> 系列函数执行 <code>command</code> 参数的内容。  使用示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">child &#x3D; pexpect.spawn(&#39;&#x2F;usr&#x2F;bin&#x2F;ftp&#39;)</span><br><span class="line">child &#x3D; pexpect.spawn(&#39;&#x2F;usr&#x2F;bin&#x2F;ssh user@example.com&#39;)</span><br></pre></td></tr></table></figure><p>由于需要实现不断匹配子程序输出， <code>searchwindowsize</code> 指定了从输入缓冲区中进行模式匹配的位置，默认从开始匹配。 </p></li><li><p>使用<code>pexpect</code>控制子程序</p><ul><li><p><code>expect()</code>定义</p><p><code>expect(self, pattern, timeout=-1, searchwindowsize=None)</code> </p><p>在参数中： <code>pattern</code> 可以是正则表达式， <code>pexpect.EOF</code> ， <code>pexpect.TIMEOUT</code>  ，或者由这些元素组成的列表。需要注意的是，当 <code>pattern</code>  的类型是一个列表时，且子程序输出结果中不止一个被匹配成功，则匹配返回的结果是缓冲区中最先出现的那个元素，或者是列表中最左边的元素。使用  <code>timeout</code> 可以指定等待结果的超时时间 ，该时间以秒为单位。当超过预订时间时， <code>expect</code> 匹配到<code>pexpect.TIMEOUT</code>。</p><p><code>expect</code> 不断从读入缓冲区中匹配目标正则表达式，当匹配结束时 <code>pexpect</code> 的 <code>before</code> 成员中保存了缓冲区中匹配成功处之前的内容， <code>pexpect</code> 的 <code>after</code> 成员保存的是缓冲区中与目标正则表达式相匹配的内容。  </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print child.before</span><br><span class="line">print child.after</span><br></pre></td></tr></table></figure></li><li><p><code>send</code>系列函数</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">send(self, s) </span><br><span class="line">sendline(self, s&#x3D;&#39;&#39;) </span><br><span class="line">sendcontrol(self, char)</span><br></pre></td></tr></table></figure><p>这些方法用来向子程序发送命令，模拟输入命令的行为。 与 <code>send()</code> 不同的是 <code>sendline()</code> 会额外输入一个回车符 ，更加适合用来模拟对子程序进行输入命令的操作。 当需要模拟发送 <code>“Ctrl+c”</code> 的行为时，还可以使用 <code>sendcontrol()</code> 发送控制字符。 </p><p><code>child.sendcontrol(&#39;c&#39;)</code> </p><p>由于 <code>send()</code> 系列函数向子程序发送的命令会在终端显示，所以也会在子程序的输入缓冲区中出现，因此不建议使用 <code>expect</code> 匹配最近一次 <code>sendline()</code> 中包含的字符。否则可能会在造成不希望的匹配结果。 </p></li><li><p>interact()定义</p><p><code>interact(self, escape_character = chr(29), input_filter = None, output_filter = None)</code> </p><p>Pexpect还可以调用<code>interact()</code> 让出控制权，用户可以继续当前的会话控制子程序。用户可以敲入特定的退出字符跳出，其默认值为<code>“^]”</code> 。 </p></li></ul></li></ul></li><li><p><code>run() function</code></p><ul><li><p><code>run()</code>的定义</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">run(command,timeout&#x3D;-1,withexitstatus&#x3D;False,events&#x3D;None,\</span><br><span class="line">    extra_args&#x3D;None,logfile&#x3D;None, cwd&#x3D;None, env&#x3D;None)</span><br></pre></td></tr></table></figure><p>函数 <code>run</code> 可以用来运行命令，其作用与 <code>Python os</code> 模块中 <code>system()</code> 函数相似。<code>run()</code> 是通过 <code>Pexpect spawn</code>类实现的。 </p></li><li><p>使用run()执行命令svn命令</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pexpect import *</span><br><span class="line">run (&quot;svn ci -m &#39;automatic commit&#39; my_file.py&quot;)</span><br></pre></td></tr></table></figure><p>与 <code>os.system()</code> 不同的是，使用 <code>run()</code> 可以方便地同时获得命令的输出结果与命令的退出状态 。 </p></li><li><p>run()的返回值</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">from pexpect import *</span><br><span class="line">(command_output, exitstatus) &#x3D; run (&#39;ls -l &#x2F;bin&#39;, withexitstatus&#x3D;1)</span><br></pre></td></tr></table></figure><p><code>command_out</code> 中保存的就是 /bin 目录下的内容。</p></li></ul></li></ol><p>更多关于pexpect的内容请看<a href="http://pexpect.readthedocs.io/en/stable/api/pexpect.html#run-function">pexpect</a>.</p><ul><li><p>安装python pexpect模块</p><p><code>sudo pip install pexpect</code></p></li></ul><h2 id="程序编写"><a href="#程序编写" class="headerlink" title="程序编写"></a>程序编写</h2><p>还是一样的实现一个程序，其功能是ssh登录虚拟机，并在远程虚拟机用户目录下记录远程登录的日志文件，然后修改其<code>iptables</code>规则，禁止转发tcp 22号端口的报文。</p><p>完整程序：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">import pexpect</span><br><span class="line"></span><br><span class="line">ip &#x3D; &quot;192.168.1.75&quot;</span><br><span class="line">user &#x3D; &quot;chl&quot;</span><br><span class="line">passwd &#x3D; &quot;123456&quot;</span><br><span class="line">                                                                                                                                        </span><br><span class="line">ssh_newkey &#x3D; &quot;Y|yes&#x2F;no&quot;</span><br><span class="line">child &#x3D; pexpect.spawn(&#39;ssh %s@%s&#39; % (user, ip))</span><br><span class="line">index &#x3D; child.expect([pexpect.EOF, pexpect.TIMEOUT, ssh_newkey, &quot;password:&quot;])</span><br><span class="line">if index &#x3D;&#x3D; 1:</span><br><span class="line">    print &quot;TimeoutError!&quot;</span><br><span class="line">if index &#x3D;&#x3D; 2:</span><br><span class="line">    child.sendline(&quot;yes&quot;)</span><br><span class="line">    child.expect(&quot;password&quot;)</span><br><span class="line">    child.sendline(passwd)</span><br><span class="line">if index &#x3D;&#x3D; 3:</span><br><span class="line">    child.sendline(passwd)</span><br><span class="line"></span><br><span class="line">child.expect(&quot;chl@&quot;)</span><br><span class="line">child.sendline(&quot;echo &#39;login +1&#39; &gt;&gt; ~&#x2F;remote_login.log&quot;)</span><br><span class="line"></span><br><span class="line">child.expect(&quot;chl@&quot;)</span><br><span class="line">child.sendline(&quot;sudo iptables -A FORWARD -p tcp --dport 22 -j REJECT&quot;)</span><br><span class="line">child.expect(&quot;password&quot;)</span><br><span class="line">child.sendline(passwd)</span><br><span class="line"></span><br><span class="line">child.expect(&quot;chl@&quot;)</span><br><span class="line">child.sendline(&quot;exit&quot;)</span><br></pre></td></tr></table></figure><p><strong>注：</strong>需要注意的是python中正则表达式与Linux中的通配符是有区别的，不能直接用通配符来编写python正则表达式。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 运维 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> shell </tag>
            
            <tag> python </tag>
            
            <tag> Expect </tag>
            
            <tag> pexpect </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>远程免密码登录Openstack实例</title>
      <link href="2018/07/07/%E8%BF%9C%E7%A8%8B%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Openstack%E5%AE%9E%E4%BE%8B/"/>
      <url>2018/07/07/%E8%BF%9C%E7%A8%8B%E5%85%8D%E5%AF%86%E7%A0%81%E7%99%BB%E5%BD%95Openstack%E5%AE%9E%E4%BE%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="背景"><a href="#背景" class="headerlink" title="背景"></a>背景</h1><p>一般情况下，可以通过<code>Openstack Dashboard</code>的控制台来访问用户创建的实例<code>Instance</code>，对于管理员来说，通过这种方法来访问会觉得很不方便，因为每次都需要打开浏览器来输入网址，每次点击都需要等待响应，登录到实例后控制台的响应也不是很及时且有卡顿。因此，本文介绍如何通过命名空间来实现免密码登录Openstack实例。</p><a id="more"></a><h1 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h1><p>在Linux中，网络命名空间可以被认为是隔离的拥有单独网络栈（网卡、路由转发表、iptables）的环境。网络命名空间经常用来隔离网络设备和服务，只有拥有同样网络命名空间的设备，才能看到彼此。openstack中就采用命名空间来实现不同网络的隔离。</p><ul><li><p>使用<code>ip netns</code>来查看已经存在的命名空间：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ip netns</span><br><span class="line">qrouter-e94975e8-4688-4858-8f64-86a18eea81ed</span><br><span class="line">qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8</span><br></pre></td></tr></table></figure><p><code>qdhcp</code>开头的名字空间是dhcp服务器使用的，<code>qrouter</code>开头的则是router服务使用的。 </p></li><li><p>查看openstack的网络：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ openstack network list</span><br><span class="line">+--------------------------------------+---------+--------------------------------------+</span><br><span class="line">| ID                                   | Name    | Subnets                              |</span><br><span class="line">+--------------------------------------+---------+--------------------------------------+</span><br><span class="line">| 34ba192f-ceea-4c86-addc-a5d14c6a34a8 | private | 74dbc6f4-ae59-4af5-b941-1f4d04918607 |</span><br><span class="line">| fc9b502a-d472-46f5-8570-b0d3915759cf | public  | de903618-fb31-412a-b46d-6ab593985b03 |</span><br><span class="line">+--------------------------------------+---------+--------------------------------------+</span><br></pre></td></tr></table></figure><p>可以看到<code>private</code>网络的dhcp服务器对应的命名空间<code>qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8</code>的名字中包含了<code>private</code>网络的ID。而本次测试的远程实例就是创建在private网络下的。</p></li><li><p>通过 <code>ip netns exec namespace_id command</code> 来在指定的网络名字空间中执行网络命令，记得加上<code>sudo</code>权限，例如 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip netns exec qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8 ifconfig</span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:190 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:190 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:65824 (65.8 KB)  TX bytes:65824 (65.8 KB)</span><br><span class="line"></span><br><span class="line">tap4e2f68bb-84 Link encap:Ethernet  HWaddr fa:16:3e:32:19:6b  </span><br><span class="line">          inet addr:10.0.0.2  Bcast:10.0.0.63  Mask:255.255.255.192</span><br><span class="line">          inet6 addr: fe80::f816:3eff:fe32:196b&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1450  Metric:1</span><br><span class="line">          RX packets:110210 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:107493 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:21335986 (21.3 MB)  TX bytes:8426397 (8.4 MB)</span><br></pre></td></tr></table></figure></li><li><p>ssh远程登录实例：</p><p><code>sudo ip netns exec namespace_id ssh $username@ip</code></p><p>通过该命令来实现从控制节点通过ssh服务远程访问Openstack实例。</p></li></ul><h1 id="发送公共秘钥"><a href="#发送公共秘钥" class="headerlink" title="发送公共秘钥"></a>发送公共秘钥</h1><p>要实现免密码远程登录实例，首先需要将控制节点<code>root用户</code>的ssh的公共秘钥发送到远程实例，也就是<code>/root/.ssh/id_rsa.pub</code>文件中的内容，远程实例收到后会将公共密钥保存到登录用户的<code>.ssh/authorized_keys</code>文件中，这样下次登录远程实例时就不再需要密码。</p><ul><li><p>发送公共密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip netns exec qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8 ssh-copy-id -i &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub openstack@10.0.0.9</span><br><span class="line"></span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: Source of key(s) to be installed: &quot;&#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub&quot;</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: attempting to log in with the new key(s), to filter out any that are already installed</span><br><span class="line">&#x2F;usr&#x2F;bin&#x2F;ssh-copy-id: INFO: 1 key(s) remain to be installed -- if you are prompted now it is to install the new keys</span><br><span class="line">openstack@10.0.0.9&#39;s password: </span><br><span class="line"></span><br><span class="line">Number of key(s) added: 1</span><br><span class="line"></span><br><span class="line">Now try logging into the machine, with:   &quot;ssh &#39;openstack@10.0.0.9&#39;&quot;</span><br><span class="line">and check to make sure that only the key(s) you wanted were added.</span><br></pre></td></tr></table></figure><p><strong>注意：</strong>发送的公共秘钥必须是控制节点<code>root</code>用户的，因为在进入命名空间执行命令时需要加上<code>sudo</code>权限，而<code>sudo</code>是用来以其他身份来执行命令的，预设的身份为<code>root</code>，这样在<code>ssh</code>登录远程实例时是以控制节点的<code>root</code>用户来登录远程实例的<code>openstack</code>用户，因此需要将控制节点<code>root</code>用户的公共密钥发送给远程实例，root用户的公共密钥的路径是<code>/root/.ssh/id_rsa.pub</code>。</p></li><li><p>查看远程实例的<code>authorized_keys</code>：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ vi ~&#x2F;.ssh&#x2F;authorized_keys</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjXQQUtIcLLcvBXVudZDBbQFK8BT&#x2F;hB67oOrs792sfCuMhxvxvFRbma5UmnxwxOhXUIRjdz4u7tWhR3VVhqqnlHGDKOQVje&#x2F;t2QtTlXXcBI3kGnc0Epem2NRMgRKp&#x2F;h&#x2F;Y1EOwtPNHRDVfr8C2znilXpWW1ueigHuJF4TWT7vEjgbApmWhopZcOXKbLkSu5dxLGUO3TzGqkASgpLG2XyuUJVqoREr5wbAZytq7R2p5KCxUZ6T7sDUQG+xmFPsfPg3MUHQmatTvtSf+mImotTkNSqOp2Itct9afX7SPkRncrXVWJ0qutbrRrkjRJm1l&#x2F;sCjFBOD0x6txcFBX30nPvkDx root@controller</span><br></pre></td></tr></table></figure></li><li><p>查看控制节点<code>root</code>用户公共密钥：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;root&#x2F;.ssh&#x2F;id_rsa.pub</span><br><span class="line">ssh-rsa AAAAB3NzaC1yc2EAAAADAQABAAABAQCjXQQUtIcLLcvBXVudZDBbQFK8BT&#x2F;hB67oOrs792sfCuMhxvxvFRbma5UmnxwxOhXUIRjdz4u7tWhR3VVhqqnlHGDKOQVje&#x2F;t2QtTlXXcBI3kGnc0Epem2NRMgRKp&#x2F;h&#x2F;Y1EOwtPNHRDVfr8C2znilXpWW1ueigHuJF4TWT7vEjgbApmWhopZcOXKbLkSu5dxLGUO3TzGqkASgpLG2XyuUJVqoREr5wbAZytq7R2p5KCxUZ6T7sDUQG+xmFPsfPg3MUHQmatTvtSf+mImotTkNSqOp2Itct9afX7SPkRncrXVWJ0qutbrRrkjRJm1l&#x2F;sCjFBOD0x6txcFBX30nPvkDx root@controller</span><br></pre></td></tr></table></figure><p>可以看到，两者是一样的，说明控制节点的<code>root</code>用户已经被授权通过公共密钥来访问远程实例。</p></li></ul><h1 id="免密码登录"><a href="#免密码登录" class="headerlink" title="免密码登录"></a>免密码登录</h1><ul><li><p>免密码登录远程实例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ sudo ip netns exec qdhcp-34ba192f-ceea-4c86-addc-a5d14c6a34a8 ssh openstack@10.0.0.9</span><br></pre></td></tr></table></figure><p>这样就通过<code>ssh</code>服务免密码远程登录<code>Openstack</code>实例，而不需要通过<code>Dashboard</code>的控制台来登录实例。</p></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Openstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Namespace </tag>
            
            <tag> SSH </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>NAT网关设计</title>
      <link href="2018/05/21/NAT%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1/"/>
      <url>2018/05/21/NAT%E7%BD%91%E5%85%B3%E8%AE%BE%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="目的"><a href="#目的" class="headerlink" title="目的"></a>目的</h1><p>本文的目的是将<code>Linux</code>配置成<code>NAT</code>网关，具备<code>NAT、DHCP、DNS</code>功能，实现内网访问外网的通信、实现外网对特定主机的访问、实现内网主机的IP地址动态分配以及域名解析的功能。</p><a id="more"></a><h1 id="环境"><a href="#环境" class="headerlink" title="环境"></a>环境</h1><h2 id="实验环境介绍："><a href="#实验环境介绍：" class="headerlink" title="实验环境介绍："></a>实验环境介绍：</h2><ul><li><p>一台搭建了<code>KVM</code>环境的物理服务器，命名为<code>Server</code>，并在该服务器上创建两台虚拟机<code>VM</code>；</p></li><li><p>第一台虚拟机用作<strong>NAT网关</strong>，命名为<code>Gateway</code>，分配两张网卡，<code>eth0</code>连接内网，<code>eth1</code>连接外网；</p></li><li><p>第二台虚拟机作为<strong>内网主机</strong>，命名为<code>Host</code>，分配一张网卡<code>eth0</code>连接内网。</p></li><li><p>内网网段为：<code>10.0.0.0/24</code></p></li><li><p>外网网段为：<code>192.168.1.0/24</code></p><p><strong>注：</strong>本实验其实也可以在<code>VMware workstation</code>或者<code>virtualBox</code>环境下进行，但是由于博主的电脑配置不高，不想在个人电脑上搭建该环境，且身边的服务器刚好有空闲的资源，所以就在服务器上搭建了该环境，至于如何在服务器上搭建<code>KVM</code>环境可以参照我的另一篇博客的部分内容 <a href="https://cao0507.github.io/2017/12/03/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2openstack%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/">快速链接</a>。</p></li></ul><h2 id="搭建实验环境："><a href="#搭建实验环境：" class="headerlink" title="搭建实验环境："></a>搭建实验环境：</h2><ul><li><p>创建内部网桥：服务器<code>Server</code>上创建一个虚拟网桥br-int，作为连接内网的交换机。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ sudo brctl addbr br-int</span><br><span class="line"></span><br><span class="line">$ brctl show</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-int8000.000000000000no</span><br><span class="line"></span><br><span class="line">$ sudo ifconfig br-int up</span><br></pre></td></tr></table></figure><p><strong>注：</strong>在<code>VMware workstation</code>中搭建环境时需要在<strong>虚拟网络编辑器</strong>中将<strong>使用本地DHCP服务将IP分配给虚拟机</strong>选项取消勾选，因为我们需要实现NAT网关来给虚拟机分配IP。另外在创建虚拟网桥后一定要开启该网桥。</p></li><li><p>创建<strong>NAT网关</strong>虚拟机</p><p>其网络配置信息如下：</p><ul><li><p>eth0</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/Gateway_VM_nic0.png" alt="Gateway_NIC0"></p></li><li><p>eth1</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/Gateway_VM_nic1.png" alt="Gateway_NIC1">通过<code>ifconfig</code>查看网络信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:1c:83:53  </span><br><span class="line">          inet6 addr: fe80::5054:ff:fe1c:8353&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">eth1      Link encap:Ethernet  HWaddr 52:54:00:de:e8:51  </span><br><span class="line">          inet addr:192.168.1.123  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fede:e851&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure><p>可见NAT网关的<code>eth0</code>网卡因为没有DHCP服务器所以没有分配到IP，但外网网卡<code>eth1</code>已经有一个外网IP。</p></li></ul></li><li><p>创建<strong>内部主机</strong>虚拟机</p><p>其网络配置信息如下：</p><ul><li><p>eth0</p><p><img src="https://raw.githubusercontent.com/cao0507/My-Pictures-Repository/master/blog/Host_VM_nic.png" alt="Host_NIC0">通过<code>ifconfig</code>查看网络信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:1a:a1:78  </span><br><span class="line">          inet6 addr: fe80::5054:ff:fe1a:a178&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          ...</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          ...</span><br></pre></td></tr></table></figure><p>可见其内网网卡<code>eth0</code>没有分配IP。</p><p>其实，在启动这两个虚拟机时，因为内部网络没有DHCP服务器，他们的内网网卡会一直等待DHCP服务器给它们分配IP，等待的时间大概是5分钟，最终还是没有获得IP。</p></li></ul></li><li><p>修改两个虚拟机的网络配置文件</p><ul><li><p><strong>NAT网关</strong>：<code>$ sudo vi /etc/network/interfaces</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;network&#x2F;interfaces.d&#x2F;*</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet static</span><br><span class="line">address 10.0.0.1</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">gateway 10.0.0.1</span><br><span class="line"></span><br><span class="line">auto eth1</span><br><span class="line">iface eth1 inet dhcp</span><br></pre></td></tr></table></figure><p>因为NAT网关的<code>eth0</code>将做内网的网关，故将其IP设置为静态IP：<code>10.0.0.1</code>，这样更容易识别，且不会因为重启而改变。</p></li><li><p><strong>内部主机</strong>：<code>$ sudo vi /etc/network/interfaces</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">source &#x2F;etc&#x2F;network&#x2F;interfaces.d&#x2F;*</span><br><span class="line"></span><br><span class="line"># The loopback network interface</span><br><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"></span><br><span class="line"># The primary network interface</span><br><span class="line">auto eth0</span><br><span class="line">iface eth0 inet dhcp</span><br></pre></td></tr></table></figure></li></ul></li><li><p>在服务器Server上查看虚拟网桥的信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ brctl show br-int</span><br><span class="line">bridge namebridge idSTP enabledinterfaces</span><br><span class="line">br-int8000.fe54001aa178novnet1</span><br><span class="line">           vnet3</span><br></pre></td></tr></table></figure><p>可以看到虚拟网桥<code>br-int</code>上面已经有两个网络接口，对应两个虚拟机的内部网卡。</p></li></ul><h1 id="NAT-功能实现"><a href="#NAT-功能实现" class="headerlink" title="NAT 功能实现"></a>NAT 功能实现</h1><p>NAT网关的功能是通过Linux中自带的iptables来实现，NAT功能包括SNAT和DNAT。SNAT是源地址转换，在内网主机访问外网时发挥作用，可以将内网主机的ip地址转换为网关的ip地址。DNAT是目的地址转换，在外网的主机通过NAT网关的ip和端口对内网主机发起访问时发挥作用，可以将NAT网关的ip地址与端口转换为对应内网主机的ip，从而实现从外网对内网中某一特定主机的访问。当然要将Linux虚拟机配置成NAT网关，首先得要开启Linux虚拟机的网络转发功能。下面将介绍NAT功能的实现过程：</p><ol><li><p>开启网络转发功能</p><ul><li><p>临时开启网络转发功能，需要切换到<code>root</code>用户，命令如下：</p><p><code># echo 1 &gt; /proc/sys/net/ipv4/ip_forward</code></p><p>这样在下次虚拟机重启后该功能会自动关闭，因此可以修改配置文件的方式来开启该功能并永久生效。</p></li><li><p>永久开启网络转发功能：</p><p><code># vi /etc/sysctl.conf</code></p><p>在文件里面添加一行<code>net.ipv4.ip_foward=1</code>，在下次重启之后就不会还原了。</p></li></ul></li><li><p>SNAT的实现</p><p>在<code>iptables</code>的<code>nat表</code>的<code>POSTROUTING规则链</code>中添加规则，使得从<code>10.0.0.0/24</code>网络发到NAT网关的数据包，从<code>eth1</code>转发出去，并将数据包的源ip地址修改为NAT网关的外网地址，命令如下 ：</p><p><code>sudo iptables -t nat -A POSTROUTING -s 10.0.0.0/24 -o eth1 -j SNAT --to-source 192.168.1.123</code></p><p><code>192.168.1.123</code>是NAT网关的外网网卡<code>eth1</code>的IP。</p></li><li><p>DNAT的实现</p><p>在<code>iptables</code>的<code>nat表</code>的<code>PREROUTING规则链</code>中添加规则，使得从外网发往NAT网关固定端口（如：8080）的<code>TCP</code>（这里也可以添加其他网络协议）数据包转发到内网的某固定主机上，命令如下：</p><p><code>sudo iptables -t nat -A PREROUTING -i eth1 -d 192.168.1.67 -p tcp --dport 8080 -j DNAT --to-destination 10.0.0.107:22</code></p><p><code>10.0.0.107</code>是内网某主机的IP，<strong>这里说明一下</strong>：实际实现的过程中，最好先实现DHCP与DNS的功能。</p></li><li><p>保存<code>iptables</code>规则</p><p><code>sudo iptables-save | sudo tee /etc/iptables.sav</code></p></li><li><p>编辑<code>/etc/rc.local</code>文件，将下面的一行添加到<code>&quot;exit 0&quot;</code>之前：</p><p><code>iptables-restore &lt; /etc/iptables.sav</code></p><p>这样每次重启机器时都会自动加载NAT相关的<code>iptables</code>规则。</p></li></ol><h1 id="DHCP与DNS功能实现"><a href="#DHCP与DNS功能实现" class="headerlink" title="DHCP与DNS功能实现"></a>DHCP与DNS功能实现</h1><p>实现DHCP服务器可以使用<code>isc-dhcp-server</code>工具包，实现DNS服务器可以使用<code>bind9</code>工具包，但是本实验考虑使用<code>DNSmasq</code>工具来同时实现DHCP服务器与DNS服务器的功能。<code>DNSmasq</code>是一个小巧且方便地用于配置DHCP和DNS的工具，适用于小型网络。作为域名解析服务器（DNS），<code>DNSmasq</code>可以通过缓存DNS请求来提高对访问过的网址的连接速度。作为DHCP服务器，<code>DNSmasq</code>可以用于为局域网电脑分配内网ip地址和提供路由。</p><ul><li><p>安装DNSmasq工具：</p><p><code>$ sudo apt-get install dnsmasq</code></p></li><li><p>编辑<code>DNSmasq</code>的配置文件<code>/etc/dnsmasq.conf</code>，添加下面两行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">interface&#x3D;eth0</span><br><span class="line">dhcp-range&#x3D;10.0.0.100,10.0.0.200,72h</span><br></pre></td></tr></table></figure><p>其中<code>interface</code>是用作内网网关的网卡，也就是NAT网关的<code>eth0</code>网卡；<code>dhcp-range</code>是动态分配的IP地址池；<code>72h</code>表示分配的IP的有效时间是72个小时，到时间后需要重新分配IP。</p></li><li><p>重启<code>DNSmasq</code>服务：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ sudo &#x2F;etc&#x2F;init.d&#x2F;dnsmasq restart</span><br><span class="line">[ ok ] Restarting dnsmasq (via systemctl): dnsmasq.service.</span><br></pre></td></tr></table></figure><p>到这里就配置内容就完成了。然后需要重启这两个虚拟机。</p></li></ul><h1 id="测试结果"><a href="#测试结果" class="headerlink" title="测试结果"></a>测试结果</h1><ul><li><p>DHCP服务</p><p>在完成DHCP服务器配置重启虚拟机后，会发现在启动过程中不再需要等待5分钟来获取IP了，进入<strong>内部主机</strong>查看网络信息：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:1a:a1:78 </span><br><span class="line">          inet addr:10.0.0.176  Bcast:10.0.0.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fe1a:a178&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:17 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:21 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:36 txqueuelen:1000 </span><br><span class="line">          RX bytes:1642 (1.6 KB)  TX bytes:2182 (2.1 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:164 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:164 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:12200 (12.2 KB)  TX bytes:12200 (12.2 KB)</span><br></pre></td></tr></table></figure><p>可以看到eth0分配到了一个在DHCP地址池内的一个IP：<code>10.0.0.176</code>。</p></li><li><p>DNS与NAT服务</p><p>这里将同时对DNS服务与NAT服务进行测试</p><ul><li><p>内网到外网</p><p>由于我所在的网络所有的<code>ping</code>外网的报文都会被拦截，所以没有办法通过<code>ping</code>来测试网络的连通性，这里采用<code>wget</code>命令在内部主机测试：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ wget http:&#x2F;&#x2F;www.baidu.com</span><br><span class="line">--2018-07-08 16:30:37--  http:&#x2F;&#x2F;www.baidu.com&#x2F;</span><br><span class="line">Resolving www.baidu.com (www.baidu.com)... 180.97.33.108, 180.97.33.107</span><br><span class="line">Connecting to www.baidu.com (www.baidu.com)|180.97.33.108|:80... connected.</span><br><span class="line">HTTP request sent, awaiting response... 200 OK</span><br><span class="line">Length: 2381 (2.3K) [text&#x2F;html]</span><br><span class="line">Saving to: ‘index.html’</span><br><span class="line"></span><br><span class="line">index.html               100%[&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&#x3D;&gt;]   2.33K  --.-KB&#x2F;s    in 0s      </span><br><span class="line"></span><br><span class="line">2018-07-08 16:30:37 (61.1 MB&#x2F;s) - ‘index.html’ saved [2381&#x2F;2381]</span><br></pre></td></tr></table></figure><p>上面的测试说明内网主机到外网的连通性，并且也实现了域名解析的功能。</p></li><li><p>外网到内网</p><p>在博主的个人Windows电脑上去访问内网主机，以此来测试外网到内网的连通性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">[c:\~]$ ssh openstack-image@192.168.1.152 8080</span><br><span class="line"></span><br><span class="line">Connecting to 192.168.1.152:8080...</span><br><span class="line">Connection established.</span><br><span class="line">To escape to local shell, press &#39;Ctrl+Alt+]&#39;.</span><br><span class="line"></span><br><span class="line">Welcome to Ubuntu 16.04.3 LTS (GNU&#x2F;Linux 4.4.0-87-generic x86_64)</span><br><span class="line"></span><br><span class="line"> * Documentation:  https:&#x2F;&#x2F;help.ubuntu.com</span><br><span class="line"> * Management:     https:&#x2F;&#x2F;landscape.canonical.com</span><br><span class="line"> * Support:        https:&#x2F;&#x2F;ubuntu.com&#x2F;advantage</span><br><span class="line"></span><br><span class="line">134 packages can be updated.</span><br><span class="line">55 updates are security updates.</span><br><span class="line"></span><br><span class="line">Last login: Sun Jul  8 16:13:54 2018</span><br><span class="line">openstack-image@ubuntu:~$ ifconfig</span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 52:54:00:d0:51:38  </span><br><span class="line">          inet addr:10.0.0.176  Bcast:10.0.0.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::5054:ff:fed0:5138&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:96 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:125 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:516 txqueuelen:1000 </span><br><span class="line">          RX bytes:17842 (17.8 KB)  TX bytes:15515 (15.5 KB)</span><br><span class="line"></span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:176 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:176 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1 </span><br><span class="line">          RX bytes:13392 (13.3 KB)  TX bytes:13392 (13.3 KB)</span><br></pre></td></tr></table></figure><p>可以访问，外网到内网也是连通的。到此，需要实现的功能都已经实现了。</p></li></ul></li></ul><hr>]]></content>
      
      
      <categories>
          
          <category> Linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Linux </tag>
            
            <tag> NAT </tag>
            
            <tag> DHCP </tag>
            
            <tag> DNS </tag>
            
            <tag> iptables </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>虚拟化技术与云计算平台报告</title>
      <link href="2018/03/22/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E6%8A%A5%E5%91%8A/"/>
      <url>2018/03/22/%E8%99%9A%E6%8B%9F%E5%8C%96%E6%8A%80%E6%9C%AF%E4%B8%8E%E4%BA%91%E8%AE%A1%E7%AE%97%E5%B9%B3%E5%8F%B0%E6%8A%A5%E5%91%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>从2006年谷歌首次提出“云计算”的概念到现在，云计算已经经历的十多年的发展，有众多厂商、组织和学者投入其中。一些云服务厂商有自己的云计算平台，但只是为客户提供云服务，外部开发者无法对这些厂商的云平台进行开发。另外也有一些组织机构或厂商开发的云计算平台是开源的，吸引大量开发者在这些开源平台上开展自己的工作。</p><a id="more"></a><p>目前，主流的开源云计算平台有很多种，本问将对这些平台进行调研以选择最适合于自己需求的平台。另外，虚拟化技术又是云计算的核心支撑技术，是将各种计算及存储资源充分整合和高效利用的关键技术，当前虚拟化技术也是多种多样，并且开源云计算平台往往又支持多种底层的虚拟化技术，因此也有必要对虚拟化技术进行调研，以选择最适合云平台和上层应用的虚拟化技术。综上，本报告的主要目标就是对多种虚拟化技术和多种开源云计算平台进行对比，以选出最满足需求的技术与平台。</p><p>本文将首先简单对比虚拟化与云计算。其后，由于虚拟化技术是云计算的基础，本报告将先对虚拟化技术展开论述，然后再对云计算平台进行论述。</p><h1 id="虚拟化与云计算"><a href="#虚拟化与云计算" class="headerlink" title="虚拟化与云计算"></a>虚拟化与云计算</h1><p>借助虚拟化技术，用户可以单个物理硬件系统为基础创建多个模拟环境或专用资源。并使用一款名为“Hypervisor”(虚拟机监控程序)的软件直接连接到硬件，从而将一个系统划分为不同的、单独安全环境，即虚拟机 (VM)。Hypervisor 能够将计算机资源与硬件分离并适当分配资源，而虚拟机则依赖这些功能运行。</p><p>云计算则由多种规则和方法组合而成，可以跨任何网络向用户按需提供计算、网络和存储基础架构资源、服务、平台和应用。这些基础架构资源、服务和应用来源于云。 简单来讲，云就是一系列管理及自动化软件编排而成的虚拟资源池，旨在帮助用户通过支持自动扩展和动态资源分配的自助服务门户，按需对这些资源进行访问。</p><p>下面对虚拟化与云计算做一个简单的对比：</p><table><thead><tr><th align="center"></th><th align="center">虚拟化</th><th align="center">云</th></tr></thead><tbody><tr><td align="center">定义</td><td align="center">技术</td><td align="center">方法论</td></tr><tr><td align="center">目的</td><td align="center">从一个物理硬件系统创建多个虚拟环境</td><td align="center">汇聚并自动化分配虚拟资源以供按需使用</td></tr><tr><td align="center">用途</td><td align="center">针对具体用途为特定用户提供打包资源</td><td align="center">针对多种用途为用户群组提供不同资源</td></tr><tr><td align="center">使用寿命</td><td align="center">数年（长期）</td><td align="center">数小时至数月</td></tr><tr><td align="center">成本</td><td align="center">资本支出（CAPEX）高<br>运营支出（OPEX）低</td><td align="center">共有云：CAPEX高、OPEX低<br>私有云：CAPEX低、OPEX高</td></tr><tr><td align="center">可扩展性</td><td align="center">纵向扩展</td><td align="center">横向扩展</td></tr><tr><td align="center">工作负载</td><td align="center">有状态</td><td align="center">无状态</td></tr><tr><td align="center">租赁</td><td align="center">单一租户</td><td align="center">多个租户</td></tr></tbody></table><h1 id="虚拟化技术"><a href="#虚拟化技术" class="headerlink" title="虚拟化技术"></a>虚拟化技术</h1><p>按照虚拟化的对象分类，虚拟化可分为服务器虚拟化、操作系统虚拟化、存储虚拟化、网络虚拟化等。其中服务器虚拟化对CPU、内存、设备与I/O这三种硬件资源的虚拟化技术已经相当成熟，但对GPU的虚拟化却还有很大的提升空间。下面将分别介绍服务器虚拟化中CPU虚拟化及GPU虚拟化相关的技术，然后对现在主流的虚拟化平台做一些比较。</p><h2 id="一、CPU虚拟化"><a href="#一、CPU虚拟化" class="headerlink" title="一、CPU虚拟化"></a>一、CPU虚拟化</h2><p>目前，为了解决x86体系结构下的CPU虚拟化问题，业界提出了全虚拟化和半虚拟化两种不同的软件方案。除了通过软件的方式实现CPU虚拟化外，业界还提出了在硬件层添加支持功能的硬件辅助虚拟化方案来处理那些敏感的高级别指令。</p><p>全虚拟化在宿主机底层物理硬件与VM之间增加一个软件层，即虚拟机监控器（VMM或hypervisor），此时，VMM充当主机操作系统，用来管理不同的虚拟机，如图1所示。它隐藏了特定计算平台的实际物理特性，为用户提供抽象的、统一的、模拟的计算环境（称为虚拟机）。在VMM平台上，可以模拟出多套虚拟机，实现了在单机上运行多个不同类型操作系统的虚拟机。全虚拟化的优点是不需要修改客户机操作系统，因此支持多种操作系统，缺点是VMM层工作负荷较大，并占用一定的宿主机资源，性能不如裸机。主要代表有VMware vSphere，Microsoft公司的Virtual PC、Redhat公司的RED HAT ENTERPRISE VIRTUALIZATION等。 </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E5%85%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="全虚拟化架构"></p><p>半虚拟化与全虚拟化类似，不同之处是需要修改客户机操作系统的核心代码，即增加一个专门的虚拟化应用程序接口，优化客户操作系统发出的指令，与VMM能够协同工作，以减轻VMM和宿主机的负担，进一步提升了虚拟机的性能，如图2所示。缺点是需要修改客户操作系统，影响了技术的普及。主要代表有使用开源虚拟化技术的Citrix的Xenserver、Microsoft的Hyper-V 。</p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E5%8D%8A%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="半虚拟化架构"></p><p>为了更好地实现全、半虚拟化技术，Intel与AMD对传统X86架构进行改进，分别设计了Intel-VT和AMD-V CPU硬件辅助虚拟化技术。将原来的特权等级Ring 0、1、2、3 定义为Non-Root mode，新增了一个Root mode 特权等级（或称为Ring -1），这种情况下，OS 即可运行在原来Ring0 的等级，而VMM 则调整到更底层的Root Mode 等级，其架构如图3。硬件辅助虚拟化有效地解决了虚拟机效率低的问题，它使虚拟机可以运行ring 0 的指令，不用再进行操作系统的ring 切换，提高了虚拟机的整体效率。 现在主流的半、全虚拟化产品都支持硬件辅助虚拟化，代表有Oracle公司的VirtualBox、RHEV、VMware vSphere和Xneserver。</p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E7%A1%AC%E4%BB%B6%E8%BE%85%E5%8A%A9%E8%99%9A%E6%8B%9F%E5%8C%96%E6%9E%B6%E6%9E%84.png" alt="硬件辅助虚拟化"></p><h2 id="二、GPU虚拟化"><a href="#二、GPU虚拟化" class="headerlink" title="二、GPU虚拟化"></a>二、GPU虚拟化</h2><p>GPU虚拟化相关技术还垄断在少数厂商手中，并没有像CPU、内存、存储一样在开源社区推广普及。下面将介绍三大显卡厂商GPU虚拟化的发展。</p><p>NVIDIA，早在2013年，NVIDIA就推出了行业内第一款GPU虚拟化显卡GRID K1/K2，同期联合Citrix推出了商用的vGPU虚拟桌面解决方案，这比AMD提前了近3年。GPU虚拟化技术的出现，给一直被诟病性能不足的桌面虚拟化带来了转机。在2016年，NVIDIA推出第二款GPU虚拟化显卡，Maxwell架构的Tesla M6/M10/M60，新版的GRID将使用授权分为 3 个不同版本，依据版本不同收取额外软件授权使用费。 在2017年8月份NVIDIA推出了最新版GRID 5.0，虚拟化显卡新增Pascal架构的Tesla P4/P6/P40/P100，其中Quadro Virtual Datacenter Workstation版的授权支持vGPU在图形渲染模式和高性能计算模式之间切换，这是硬件厂商首次在vGPU层面将图形渲染和高性能计算进行了统一，又一次引领了行业趋势和市场需求。NVIDIA的虚拟化显卡只是硬件，还需要相应的服务器虚拟化系统的支持，这和Intel的CPU需要操作系统Windows和Linux来配合一样。现在只有Xen和ESXi能够支持GRID virtual GPU solution，被大量第三方厂商采用的KVM虚拟化平台还没有出现在GRID的支持列表中，因此可以说GPU另外一只脚还没能踏进云计算时代。2017年7月份NVIDIA和Nutanix宣布将合作在年底推出AHV版本的GRID，这算是KVM虚拟化走出了第 一步。在解决GPU虚拟化后，如何将虚拟机的画面传送到客户端，这是KVM虚拟化可以商用的第二步。KVM上默认配置的Spice协议对3D的支持并不好，Nutanix以及其他KVM方案解决商还需自行开发出可用的桌面传输协议，这才算是彻底完成了GRID在KVM上的应用。</p><p>AMD，AMD在NVIDIA推出GRID K1/K2 的两年半后才推出了自己的GPU虚拟化产品MxGPU，算是姗姗来迟。共有三款FirePro S系列的GPU支持MxGPU，一块GPU最多可以支持 32 个用户。当MxGPU上的虚拟机比较少时，能够达到图形工作站的性能。随着虚拟机数量增多，每个虚拟机获得的GPU性能逐步降低。有别于NVIDIA GRID通过软件实现的显卡虚拟化方式，AMD MxGPU是“全球首款基于硬件的虚拟化GPU解决方案”。MxGPU每个虚拟机能分得一定数量的独享流处理器和显存空间，这样可以避免不同虚拟机对GPU资源的抢夺，造成用户噪音。这种噪音问题直到今年8月底推出NVIDIA GRID 5. 0 才得到解决。MxGPU在定价上采用的是更符合买方逻辑的营销方法，只向用户收取需付硬件的购买费用。不过遗憾的是，目前只有VMware的ESXi支持MxGPU，Xen暂时只有技术验证版。没能同时支持两种主流化的虚拟化系统，一定程度上阻碍了MxGPU在市场的普及速度。Citrix的用户还是可以用过vSphere+XenDesktop的方案用上MxGPU，相比使用免费的XenServer，要多支付vSphere的费用。</p><p>Intel，Intel官方将不同的Intel GPU虚拟化技术分别命名为Intel GVT-s，Intel GVT-d和Intel GVT-g，分布对应API转发，直通，完全虚拟化。Intel GVT-g和NVIDIA vGPU类似，支持Xen/KVM平台，每个GPU最多能分享给7个用户同时使用。其中XenGT在 2016 年最早实现了业界的vGPU在线迁移，NVIDIA GRID直到这个季度才和Citrix合作完成了vGPU在线迁移。 2016 年的 2017 年2月份，Linux 4.10中加入Intel GVT-g for KVM。这是三大GPU厂商中，第一个支持KVM平台的完全虚拟化方案，意味着第三方采用KVM的云计算厂商终于有了一个可用的vGPU方案。不过Intel GPU虚拟化，由于核显性能的原因，只能满足图像密集型的用户体验，不能像GRID vGPU和MxGPU一样满足图形渲染的重度使用场景。Intel GPU虽然支持了大多数虚拟化桌面厂商使用的Xen/KVM两大类服务器虚拟化系统，可是硬件却和VDI高密度的使用场景不太搭。首先Intel的完全虚拟化只支持Broadwell架构以后的核芯显卡，作为VDI服务器中常用的Xeon E5/E7 v4 系列，以及第 一个的Xeon Scalable处理器，都没有核芯显卡。这在很大程度上限定了Intel GPU虚拟化在VDI的使用规模，有种落入有枪无弹的尴尬境地。</p><h2 id="三、虚拟化平台比较"><a href="#三、虚拟化平台比较" class="headerlink" title="三、虚拟化平台比较"></a>三、虚拟化平台比较</h2><p>服务器虚拟化技术日益成熟，并具有广泛的应用前景，目前有很多厂商进行虚拟化技术产品的开发和生产，包括：VMware、Microsoft、Citrix、IBM和RedHat等，其各自产品都有不同的特点，产品功能日益强大。下面将比较一下四种主流服务器虚拟化平台，如下表 ：</p><table><thead><tr><th align="center"></th><th align="center">VMware</th><th align="center">Xen</th><th align="center">KVM</th><th align="center">Hyper-V</th></tr></thead><tbody><tr><td align="center">厂商</td><td align="center">VMware</td><td align="center">Citrix</td><td align="center">Red Hat</td><td align="center">Microsoft</td></tr><tr><td align="center">是否免费</td><td align="center">付费</td><td align="center">开源免费</td><td align="center">开源免费</td><td align="center">付费</td></tr><tr><td align="center">宿主机系统</td><td align="center">Windows<br>Linux</td><td align="center">NetBSD<br>Linux<br>Solaris</td><td align="center">Linux</td><td align="center">Windows server 2008及以上系统</td></tr><tr><td align="center">客户机系统</td><td align="center">Windows 2003、Windows 2008、RedHat、Debian、Ubuntu、Centos</td><td align="center">Xen-PV：纯Linux；Xen-HVM：支持Windows、Linux</td><td align="center">Linux、Windows</td><td align="center">Windows系列、Linux</td></tr><tr><td align="center">支持技术</td><td align="center">硬件辅助虚拟化（全虚拟化）</td><td align="center">硬件辅助虚拟化（HVM全虚拟化、PV半虚拟化）</td><td align="center">硬件辅助虚拟化（全虚拟化）</td><td align="center">硬件辅助虚拟化（半虚拟化）</td></tr><tr><td align="center">支持的vGPU产品</td><td align="center">NVIDIA GRID<br>AMD MxGPU</td><td align="center">NVIDIA GRID<br>AMD MxGPU（技术验证版）</td><td align="center">Intel GVT-g for KVM</td><td align="center"></td></tr><tr><td align="center">优点</td><td align="center">相对成熟的商业软件，市场占有率较大</td><td align="center">性能较好，支持半虚拟化</td><td align="center">是内核本身的一部分，因此可以利用内核的优化和改进；高性能，稳定，无需修改客户机系统</td><td align="center">对Windows的支持较好</td></tr><tr><td align="center">缺点</td><td align="center">不开源，费用较高</td><td align="center">操作复杂，维护成本较高，目前已被RedHat抛弃</td><td align="center">虚拟机性能比Xen略低</td><td align="center">对Linux的支持较差，性能损失大</td></tr></tbody></table><p>开源云计算平台Openstack对这四种虚拟化平台都有支持，默认使用的是KVM，Openstack与KVM结合的方案也已经相当成熟。另外，考虑到KVM是开源免费的虚拟化技术；宿主机系统支持绝大多数Linux系统，对于使用Linux系统的服务器都有很好的支持；而客户机操作系统不仅支持Linux，还支持Windows，可以满足绝大多数用户的需求，因此选择KVM作为Openstack底层的虚拟化技术的理由是很充分的。不过，KVM对于虚拟GPU的支持不是很好，只有Intel GVT-g for KVM可以支持KVM平台的全虚拟化方案，但是Intel GPU虚拟化由于核显性能的原因，只能满足图像密集型的用户体验，不能满足图形渲染等重度使用的场景。</p><h1 id="云计算平台"><a href="#云计算平台" class="headerlink" title="云计算平台"></a>云计算平台</h1><p>目前已经有多个云计算平台的开源实现，主要的开源云计算项目有Openstack、Eucalyptus、CloudStack和OpenNebula等，现比较如下：</p><table><thead><tr><th align="center"></th><th align="center">Openstack</th><th align="center">Eucalyptus</th><th align="center">CloudStack</th><th align="center">OpenNebula</th></tr></thead><tbody><tr><td align="center">发布时间</td><td align="center">2010年7月</td><td align="center">2008年5月</td><td align="center">2010年5月</td><td align="center">2008年7月</td></tr><tr><td align="center">最新版本</td><td align="center">Queens</td><td align="center">4.4</td><td align="center">4.11</td><td align="center">5.4</td></tr><tr><td align="center">授权协议</td><td align="center">Apache v2.0</td><td align="center">GPL v3.0</td><td align="center">Apache v2.0</td><td align="center">Apache v2.0</td></tr><tr><td align="center">基本架构</td><td align="center">Nova、Glance、Neutron、Keystone、Horizon、swift、Tacker等</td><td align="center">Cloud Controller、Cluster Controller、Node Controller、Walrus、 Storage Controller</td><td align="center">主要包括管理服务、云基础设施和网络三大部分</td><td align="center">主要包括接口与API、用户与组、主机、网络、存储、集群6个部分</td></tr><tr><td align="center">虚拟化技术支持</td><td align="center">KVM、LXC、QEMU、UML、Vmware ESX/ESXi、Xen、Hyper-V</td><td align="center">Xen、KVM、ESXi</td><td align="center">KVM、Xen、ESXi、OVM、Baremetal</td><td align="center">Xen、KVM、Vmware</td></tr><tr><td align="center">用户界面</td><td align="center">Dashboard，较简单</td><td align="center">web界面</td><td align="center">Web Console，功能较完善</td><td align="center">web界面</td></tr><tr><td align="center">社区活跃程度</td><td align="center">人数多，活跃用户数最多</td><td align="center">人数多，但活跃用户数较少</td><td align="center">人数少，但活跃用户数较多</td><td align="center">人数较少，活跃用户数也少</td></tr><tr><td align="center">兼容云平台</td><td align="center">Amazon EC2，S3</td><td align="center">Amazon EC2，S3</td><td align="center">Amazon EC2，S3</td><td align="center">Amazon EC2，S3</td></tr><tr><td align="center">开发主导</td><td align="center">开源社区</td><td align="center">Eucalyptus System Inc</td><td align="center">Citrix公司</td><td align="center">开源社区</td></tr><tr><td align="center">主要支持厂商</td><td align="center">160家左右，包括NASA、Rackspace、HP、Dell、UnitedStack等</td><td align="center">亚马逊、戴尔、惠普、Intel、Redhat、Vmware等</td><td align="center">不到60家，包括诺基亚、日本电话电报公司、阿尔卡特、迪士尼等</td><td align="center">IBM、Akamai、Blackberry、Fuze、Telefonica、Indigital</td></tr><tr><td align="center">官方文档</td><td align="center">非常详细</td><td align="center">不够详细</td><td align="center">详细</td><td align="center">详细</td></tr><tr><td align="center">检测和审计</td><td align="center">Telemetry Service</td><td align="center">Accounting system</td><td align="center">Event/Audit logs</td><td align="center">Accounting system、periodically-Monitoring</td></tr><tr><td align="center">数据库</td><td align="center">PostareSQL、MySQL、SQLite</td><td align="center">HyperSQL Database</td><td align="center">MySQL</td><td align="center">SQLite、MySQL</td></tr><tr><td align="center">部署</td><td align="center">私有云、共有云、混合云</td><td align="center">私有云、混合云</td><td align="center">私有云、共有云、混合云</td><td align="center">私有云、共有云、混合云</td></tr><tr><td align="center">操作系统</td><td align="center">Debian 7.0、openSUSE、SUSE、Red Hat、CentOS、Fedora、Ubuntu</td><td align="center">CentOS、RHEL</td><td align="center">CentOS、RHEL6.3+、Ubuntu</td><td align="center">Red Hat、Ubuntu、SUSE、CentOS、Debian</td></tr><tr><td align="center">开发语言</td><td align="center">Python</td><td align="center">Java、C/C++</td><td align="center">Java</td><td align="center">C、Ruby、shell</td></tr><tr><td align="center">开源市场部署比例</td><td align="center">69%</td><td align="center">3%</td><td align="center">14%</td><td align="center">无统计数据</td></tr></tbody></table><p>这四种主流的开源云计算平台都经过了近十年的发展，更新迭代了很多版本，能够从众多云计算平台的竞争中存活下来，都有相应的支持厂商和用户，说明它们各有各的特点，如在开发语言上就各有特色，Openstack使用的是Python语言，Eucalyptus使用Java、C/C++，CloudStack仅使用Java，而OpenNebula却显得比较奇怪，使用的是C语言、Ruby和shell，多种语言混杂而成。但不同平台之间还是有较大差距，从结果来看，在开源市场的部署比例，Openstack 69%的比例占据了绝对统治地位，Openstack能占据这样的地位有多方面的原因，如Openstack支持绝大多数的虚拟化技术，支持的操作系统也很多，使得Openstack具有广阔的应用范围；Openstack的官方文档非常详细，也降低了其学习成本；Openstack具有一个充满活力的开源社区，开发者不断为Openstack的发展作出贡献；OpenStack的支持厂商有160家左右，有如此多的厂商支持，给OpenStack的发展提供了根本保障。综合以上多方面的原因，本项目采用Openstack作为底层的云计算平台为上层提供基础设施资源也是理所当然的。另外，在2018年2月28日发布的Openstack Queens最新版本中，新引入的Marquee功能正是为了提供对vGPU的内置支持能力，这意味着用户能够将GPU添加至虚拟机中，为本项目的上层应用，如深度学习等需要强大GPU运算能力的应用提供了支持。</p><h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>通过以上的分析，能够清楚的了解各种虚拟化技术及各种云计算平台的差异，对于要选择满足自己需求的技术与平台会有一些帮助。</p><hr>]]></content>
      
      
      <categories>
          
          <category> 云计算 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> Openstack </tag>
            
            <tag> 云计算 </tag>
            
            <tag> 虚拟化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openstack环境下手动安装Mistral</title>
      <link href="2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Mistral/"/>
      <url>2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Mistral/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>在openstack平台中能够成功安装Tacker，但是安装的Tacker并不能用，因为在tacker中创建VIM时需要调用Mistral工作流组件。因此本文就来介绍在openstack环境中手动安装Mistral的过程。</p><a id="more"></a><p><strong>注：</strong> 安装的openstack是在Ubuntu 16.04系统下的Ocata版本；本文中涉及的密码都统一设置成 <em>“openstack”</em>。</p><p>参考<a href="https://docs.openstack.org/mistral/latest/install/installation_guide.html"><em>官方文档</em></a></p><h1 id="一、安装必要组件"><a href="#一、安装必要组件" class="headerlink" title="一、安装必要组件"></a>一、安装必要组件</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ apt-get install python-dev python-setuptools python-pip libffi-dev \</span><br><span class="line">  libxslt1-dev libxml2-dev libyaml-dev libssl-dev</span><br></pre></td></tr></table></figure><h1 id="二、安装Mistral-server"><a href="#二、安装Mistral-server" class="headerlink" title="二、安装Mistral server"></a>二、安装Mistral server</h1><h2 id="1、下载Mistral源码，并进入下载目录"><a href="#1、下载Mistral源码，并进入下载目录" class="headerlink" title="1、下载Mistral源码，并进入下载目录"></a>1、下载Mistral源码，并进入下载目录</h2><pre><code>$ git clone https://github.com/openstack/mistral.git$ cd mistral</code></pre><h2 id="2、安装Mistral环境依赖包"><a href="#2、安装Mistral环境依赖包" class="headerlink" title="2、安装Mistral环境依赖包"></a>2、安装Mistral环境依赖包</h2><pre><code>$ pip install -r requirements.txt</code></pre><h2 id="3、安装Mistral"><a href="#3、安装Mistral" class="headerlink" title="3、安装Mistral"></a>3、安装Mistral</h2><pre><code>$ python setup.py install</code></pre><h2 id="4、生成配置文件"><a href="#4、生成配置文件" class="headerlink" title="4、生成配置文件"></a>4、生成配置文件</h2><pre><code>$ oslo-config-generator --config-file tools/config/config-generator.mistral.conf --output-file etc/mistral.conf</code></pre><h2 id="5、创建Mistral日志文件和配置文件夹"><a href="#5、创建Mistral日志文件和配置文件夹" class="headerlink" title="5、创建Mistral日志文件和配置文件夹"></a>5、创建Mistral日志文件和配置文件夹</h2><pre><code># mkdir -p /etc/mistral /var/log/mistral</code></pre><h2 id="6、复制配置文件到配置文件夹"><a href="#6、复制配置文件到配置文件夹" class="headerlink" title="6、复制配置文件到配置文件夹"></a>6、复制配置文件到配置文件夹</h2><pre><code># cp etc/* /etc/mistral/</code></pre><h2 id="7、修改配置文件"><a href="#7、修改配置文件" class="headerlink" title="7、修改配置文件"></a>7、修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"># vi &#x2F;etc&#x2F;mistral&#x2F;mistral.conf </span><br><span class="line"></span><br><span class="line">[keystone_authtoken]</span><br><span class="line">auth_uri &#x3D; http:&#x2F;&#x2F;controller:5000</span><br><span class="line">auth_version &#x3D; 3</span><br><span class="line">identity_uri &#x3D; http:&#x2F;&#x2F;controller:35357&#x2F;</span><br><span class="line">admin_user &#x3D; admin</span><br><span class="line">admin_password &#x3D; openstack</span><br><span class="line">admin_tenant_name &#x3D; admin</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">connection &#x3D; mysql+pymysql:&#x2F;&#x2F;mistral:openstack@controller&#x2F;mistral </span><br><span class="line"></span><br><span class="line">[DEFAULT]</span><br><span class="line">transport_url &#x3D; rabbit:&#x2F;&#x2F;openstack:openstack@controller</span><br></pre></td></tr></table></figure><h2 id="8、创建数据库"><a href="#8、创建数据库" class="headerlink" title="8、创建数据库"></a>8、创建数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># mysql</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE mistral;</span><br><span class="line">MariaDB [mistral]&gt; GRANT ALL PRIVILEGES ON mistral.* TO &#39;mistral&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;openstack&#39;;</span><br><span class="line">MariaDB [mistral]&gt; GRANT ALL PRIVILEGES ON mistral.* TO &#39;mistral&#39;@&#39;%&#39; IDENTIFIED BY &#39;openstack&#39;;</span><br><span class="line">MariaDB [mistral]&gt; flush privileges;</span><br><span class="line">MariaDB [mistral]&gt; exit;</span><br></pre></td></tr></table></figure><h2 id="9、创建服务和endpoint"><a href="#9、创建服务和endpoint" class="headerlink" title="9、创建服务和endpoint"></a>9、创建服务和endpoint</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ openstack service create --name mistral --description &quot;Openstack Workflow service&quot; workflow</span><br><span class="line">$ openstack endpoint create --region RegionOne workflow public http:&#x2F;&#x2F;controller:8989&#x2F;v2</span><br><span class="line">$ openstack endpoint create --region RegionOne workflow internal http:&#x2F;&#x2F;controller:8989&#x2F;v2</span><br><span class="line">$ openstack endpoint create --region RegionOne workflow admin http:&#x2F;&#x2F;controller:8989&#x2F;v2</span><br></pre></td></tr></table></figure><h2 id="10、初始化数据库信息"><a href="#10、初始化数据库信息" class="headerlink" title="10、初始化数据库信息"></a>10、初始化数据库信息</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">root@controller:&#x2F;home&#x2F;openstack# mistral-db-manage --config-file &#x2F;etc&#x2F;mistral&#x2F;mistral.conf upgrade head</span><br><span class="line"></span><br><span class="line">INFO  [alembic.runtime.migration] Context impl MySQLImpl.</span><br><span class="line">INFO  [alembic.runtime.migration] Will assume non-transactional DDL.</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade  -&gt; 001, Kilo release</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 001 -&gt; 002, Kilo</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 002 -&gt; 003, cron_trigger_constraints</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 003 -&gt; 004, add description for execution</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 004 -&gt; 005, Increase executions_v2 column size from JsonDictType to JsonLongDictType</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 005 -&gt; 006, add a Boolean column &#39;processed&#39; to the table  delayed_calls_v2</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 006 -&gt; 007, Move system flag to base definition</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 007 -&gt; 008, Increase size of state_info column from String to Text</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 008 -&gt; 009, Add database indices</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 009 -&gt; 010, add_resource_members_v2_table</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 010 -&gt; 011, add workflow id for execution</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 011 -&gt; 012, add event triggers table</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 012 -&gt; 013, split_execution_table_increase_names</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 013 -&gt; 014, fix_past_scripts_discrepancies</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 014 -&gt; 015, add_unique_keys_for_non_locking_model</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 015 -&gt; 016, Increase size of task_executions_v2.unique_key</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 016 -&gt; 017, Add named lock table</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 017 -&gt; 018, increate_task_execution_unique_key_size</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 018 -&gt; 019, Change scheduler schema.</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 019 -&gt; 020, add type to task execution</span><br><span class="line">INFO  [alembic.runtime.migration] Running upgrade 020 -&gt; 021, Increase environments_v2 column size from JsonDictType to JsonLongDictType</span><br></pre></td></tr></table></figure><h2 id="11、添加自带的action"><a href="#11、添加自带的action" class="headerlink" title="11、添加自带的action"></a>11、添加自带的action</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">root@controller:&#x2F;home&#x2F;openstack# mistral-db-manage --config-file &#x2F;etc&#x2F;mistral&#x2F;mistral.conf populate</span><br><span class="line">*输出结果可能为：*</span><br><span class="line">No handlers could be found for logger &quot;mistral.actions.openstack.action_generator.base&quot;</span><br><span class="line">*也可能会出错：*</span><br><span class="line">……</span><br><span class="line">2017-12-22 22:21:24.486 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;actions&#x2F;openstack&#x2F;mapping.json</span><br><span class="line">2017-12-22 22:21:24.551 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;actions&#x2F;openstack&#x2F;mapping.json</span><br><span class="line">2017-12-22 22:21:24.761 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;actions&#x2F;openstack&#x2F;mapping.json</span><br><span class="line">2017-12-22 22:21:24.878 16802 INFO mistral.actions.openstack.action_generator.base [-] Processing OpenStack action mapping from file: &#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;actions&#x2F;openstack&#x2F;mapping.json</span><br><span class="line">2017-12-22 22:21:24.883 16802 WARNING oslo_config.cfg [-] Option &quot;auth_uri&quot; from group &quot;keystone_authtoken&quot; is deprecated for removal (The auth_uri option is deprecated in favor of www_authenticate_uri and will be removed in the S  release.).  Its value may be silently ignored in the future.</span><br><span class="line">^C2017-12-22 22:21:25.382 16802 CRITICAL Mistral [-] Unhandled error: KeyboardInterrupt</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral Traceback (most recent call last):</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;bin&#x2F;mistral-db-manage&quot;, line 10, in &lt;module&gt;</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     sys.exit(main())</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;db&#x2F;sqlalchemy&#x2F;migration&#x2F;cli.py&quot;, line 137, in main</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     CONF.command.func(config, CONF.command.name)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;db&#x2F;sqlalchemy&#x2F;migration&#x2F;cli.py&quot;, line 75, in do_populate</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     action_manager.sync_db()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;services&#x2F;action_manager.py&quot;, line 80, in sync_db</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     register_action_classes()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;services&#x2F;action_manager.py&quot;, line 126, in register_action_classes</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     _register_dynamic_action_classes()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;services&#x2F;action_manager.py&quot;, line 86, in _register_dynamic_action_classes</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     actions &#x3D; generator.create_actions()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;actions&#x2F;openstack&#x2F;action_generator&#x2F;base.py&quot;, line 143, in create_actions</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     client_method &#x3D; class_.get_fake_client_method()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;actions&#x2F;openstack&#x2F;base.py&quot;, line 75, in get_fake_client_method</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return cls._get_client_method(cls._get_fake_client())</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;mistral&#x2F;actions&#x2F;openstack&#x2F;actions.py&quot;, line 380, in _get_fake_client</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return cls._get_client_class()(session&#x3D;sess)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;ironic_inspector_client&#x2F;v1.py&quot;, line 88, in __init__</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     super(ClientV1, self).__init__(**kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;ironic_inspector_client&#x2F;common&#x2F;http.py&quot;, line 134, in __init__</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     region_name&#x3D;region_name)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;keystoneauth1&#x2F;session.py&quot;, line 856, in get_endpoint</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return auth.get_endpoint(self, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;keystoneauth1&#x2F;identity&#x2F;base.py&quot;, line 212, in get_endpoint</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     service_catalog &#x3D; self.get_access(session).service_catalog</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;keystoneauth1&#x2F;identity&#x2F;base.py&quot;, line 136, in get_access</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     self.auth_ref &#x3D; self.get_auth_ref(session)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;keystoneauth1&#x2F;identity&#x2F;generic&#x2F;base.py&quot;, line 198, in get_auth_ref</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return self._plugin.get_auth_ref(session, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;keystoneauth1&#x2F;identity&#x2F;v3&#x2F;base.py&quot;, line 167, in get_auth_ref</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     authenticated&#x3D;False, log&#x3D;False, **rkwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;keystoneauth1&#x2F;session.py&quot;, line 766, in post</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return self.request(url, &#39;POST&#39;, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;positional&#x2F;__init__.py&quot;, line 101, in inner</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     return wrapped(*args, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;keystoneauth1&#x2F;session.py&quot;, line 616, in request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     resp &#x3D; send(**kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;keystoneauth1&#x2F;session.py&quot;, line 674, in _send_request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     resp &#x3D; self.session.request(method, url, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;requests&#x2F;sessions.py&quot;, line 508, in request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     resp &#x3D; self.send(prep, **send_kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;requests&#x2F;sessions.py&quot;, line 618, in send</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     r &#x3D; adapter.send(request, **kwargs)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;requests&#x2F;adapters.py&quot;, line 440, in send</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     timeout&#x3D;timeout</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;urllib3&#x2F;connectionpool.py&quot;, line 601, in urlopen</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     chunked&#x3D;chunked)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;urllib3&#x2F;connectionpool.py&quot;, line 380, in _make_request</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     httplib_response &#x3D; conn.getresponse(buffering&#x3D;True)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;httplib.py&quot;, line 1136, in getresponse</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     response.begin()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;httplib.py&quot;, line 453, in begin</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     version, status, reason &#x3D; self._read_status()</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;httplib.py&quot;, line 409, in _read_status</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     line &#x3D; self.fp.readline(_MAXLINE + 1)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral   File &quot;&#x2F;usr&#x2F;lib&#x2F;python2.7&#x2F;socket.py&quot;, line 480, in readline</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral     data &#x3D; self._sock.recv(self._rbufsize)</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral KeyboardInterrupt</span><br><span class="line">2017-12-22 22:21:25.382 16802 ERROR Mistral</span><br></pre></td></tr></table></figure><p>纠结了很久后发现这些都不用太在意，直接跳过，哈哈！</p><h1 id="三、安装Mistral-client"><a href="#三、安装Mistral-client" class="headerlink" title="三、安装Mistral client"></a>三、安装Mistral client</h1><h2 id="1、下载Mistral-client源码"><a href="#1、下载Mistral-client源码" class="headerlink" title="1、下载Mistral-client源码"></a>1、下载Mistral-client源码</h2><pre><code>$ git clone git://git.openstack.org/openstack/python-mistralclient.git -b stable/ocata$ cd python-mistralclient</code></pre><h2 id="2、安装Mistral-client模块"><a href="#2、安装Mistral-client模块" class="headerlink" title="2、安装Mistral-client模块"></a>2、安装Mistral-client模块</h2><pre><code>$ pip install -r requirements.txt$ python setup.py install</code></pre><h1 id="四、安装Mistral-horizon"><a href="#四、安装Mistral-horizon" class="headerlink" title="四、安装Mistral horizon"></a>四、安装Mistral horizon</h1><h2 id="1、下载Mistral-horizon源码"><a href="#1、下载Mistral-horizon源码" class="headerlink" title="1、下载Mistral-horizon源码"></a>1、下载Mistral-horizon源码</h2><pre><code>$ git clone https://git.openstack.org/openstack/mistral-dashboard.git -b stable/ocata$ cd mistral-dashboard/</code></pre><h2 id="2、安装Mistral-horizon模块"><a href="#2、安装Mistral-horizon模块" class="headerlink" title="2、安装Mistral-horizon模块"></a>2、安装Mistral-horizon模块</h2><pre><code>$ pip install -r requirements.txt$ python setup.py install</code></pre><h2 id="3、复制一个文件"><a href="#3、复制一个文件" class="headerlink" title="3、复制一个文件"></a>3、复制一个文件</h2><pre><code># cp -b mistraldashboard/enabled/_50_mistral.py /usr/share/openstack-dashboard/openstack_dashboard/enabled/_50_mistral.py</code></pre><h2 id="4、重启apache2服务"><a href="#4、重启apache2服务" class="headerlink" title="4、重启apache2服务"></a>4、重启apache2服务</h2><pre><code># service apache2 restart</code></pre><p>安装好Mistral-horizon后，admin用户登录dashboard界面就可以看到Mistral相关的workflow，如图：<br><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/mistral%20horizon.png" alt="Mistral-horizon界面"></p><h1 id="五、运行Mistral-server"><a href="#五、运行Mistral-server" class="headerlink" title="五、运行Mistral server"></a>五、运行Mistral server</h1><p>运行下面的第一条命令：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">root@controller:&#x2F;home&#x2F;openstack&#x2F;mistral# python mistral&#x2F;cmd&#x2F;launch.py --server all --config-file &#x2F;etc&#x2F;mistral&#x2F;mistral.conf</span><br><span class="line"></span><br><span class="line">|\\    &#x2F;&#x2F;|           ||                       ||</span><br><span class="line">||\\  &#x2F;&#x2F;||      __   ||      __      __       ||</span><br><span class="line">|| \\&#x2F;&#x2F; || ||  &#x2F;&#x2F;  ||||||  ||  \\  &#x2F;&#x2F;  \\     ||</span><br><span class="line">||  \&#x2F;  ||     \\    ||    ||     ||    \\    ||</span><br><span class="line">||      || ||   \\   ||    ||     ||    &#x2F;\\   ||</span><br><span class="line">||      || || __&#x2F;&#x2F;   ||_&#x2F;&#x2F; ||      \\__&#x2F;&#x2F; \\_ ||</span><br><span class="line">Mistral Workflow Service, version 6.0.0</span><br><span class="line"></span><br><span class="line">Launching server components [engine,event-engine,api,executor]...</span><br><span class="line">2017-12-22 22:42:58.373 16966 INFO mistral.event_engine.default_event_engine [-] Starting event notification task...</span><br><span class="line">2017-12-22 22:42:58.571 16966 INFO mistral.event_engine.default_event_engine [-] Found 0 event triggers.</span><br><span class="line">&#x2F;usr&#x2F;local&#x2F;lib&#x2F;python2.7&#x2F;dist-packages&#x2F;oslo_messaging&#x2F;server.py:341: FutureWarning: blocking executor is deprecated. Executor default will be removed. Use explicitly threading or eventlet instead in version &#39;pike&#39; and will be removed in version &#39;rocky&#39;</span><br><span class="line">  category&#x3D;FutureWarning)</span><br><span class="line">2017-12-22 22:42:58.913 16966 WARNING oslo_config.cfg [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Option &quot;auth_uri&quot; from group &quot;keystone_authtoken&quot; is deprecated for removal (The auth_uri option is deprecated in favor of www_authenticate_uri and will be removed in the S  release.).  Its value may be silently ignored in the future.</span><br><span class="line">2017-12-22 22:42:58.915 16966 WARNING oslo_config.cfg [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Option &quot;auth_uri&quot; from group &quot;keystone_authtoken&quot; is deprecated. Use option &quot;www_authenticate_uri&quot; from group &quot;keystone_authtoken&quot;.</span><br><span class="line">2017-12-22 22:42:58.925 16966 WARNING keystonemiddleware.auth_token [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] AuthToken middleware is set with keystone_authtoken.service_token_roles_required set to False. This is backwards compatible but deprecated behaviour. Please set this to True.</span><br><span class="line">2017-12-22 22:42:58.926 16966 WARNING keystonemiddleware.auth_token [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Use of the auth_admin_prefix, auth_host, auth_port, auth_protocol, identity_uri, admin_token, admin_user, admin_password, and admin_tenant_name configuration options was deprecated in the Mitaka release in favor of an auth_plugin and its related options. This class may be removed in a future release.</span><br><span class="line">2017-12-22 22:42:58.931 16966 INFO oslo.service.wsgi [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] mistral_api listening on 0.0.0.0:8989</span><br><span class="line">2017-12-22 22:42:58.932 16966 INFO oslo_service.service [req-46885c1b-de53-4bba-958d-97484cd17783 - - - - -] Starting 4 workers</span><br><span class="line">API server started.</span><br><span class="line">API server started.</span><br><span class="line">API server started.</span><br><span class="line">API server started.</span><br><span class="line">Event engine server started.</span><br><span class="line">Executor server started.</span><br><span class="line">Engine server started.</span><br></pre></td></tr></table></figure><h1 id="六、测试一下Mistral是否可用"><a href="#六、测试一下Mistral是否可用" class="headerlink" title="六、测试一下Mistral是否可用"></a>六、测试一下Mistral是否可用</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">openstack@controller:~&#x2F;mistral&#x2F;etc$ mistral workbook-list</span><br><span class="line">+--------+--------+------------+------------+</span><br><span class="line">| Name   | Tags   | Created at | Updated at |</span><br><span class="line">+--------+--------+------------+------------+</span><br><span class="line">| &lt;none&gt; | &lt;none&gt; | &lt;none&gt;     | &lt;none&gt;     |</span><br><span class="line">+--------+--------+------------+------------+</span><br><span class="line"></span><br><span class="line">openstack@controller:~&#x2F;mistral&#x2F;etc$ mistral action-list</span><br><span class="line">+--------+--------+-----------+--------+-------------+--------+------------+------------+</span><br><span class="line">| ID     | Name   | Is system | Input  | Description | Tags   | Created at | Updated at |</span><br><span class="line">+--------+--------+-----------+--------+-------------+--------+------------+------------+</span><br><span class="line">| &lt;none&gt; | &lt;none&gt; | &lt;none&gt;    | &lt;none&gt; | &lt;none&gt;      | &lt;none&gt; | &lt;none&gt;     | &lt;none&gt;     |</span><br><span class="line">+--------+--------+-----------+--------+-------------+--------+------------+------------+</span><br></pre></td></tr></table></figure><p>OK，成功了，开心！！！</p><hr>]]></content>
      
      
      <categories>
          
          <category> Openstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Tacker </tag>
            
            <tag> Mistral </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Openstack环境下手动安装Tacker</title>
      <link href="2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Tacker/"/>
      <url>2017/12/23/Openstack%E7%8E%AF%E5%A2%83%E4%B8%8B%E6%89%8B%E5%8A%A8%E5%AE%89%E8%A3%85Tacker/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>本文参考官方文档，在现有的openstack平台上，手动安装Tacker。基础的openstack平台包含了最核心的keystone、glance、nova、neutron、horizon这5个组件，但是Tacker还需要预先安装好Mistral和Barbican这两个组件，在安装好这两个组件后就可以开始按照以下步骤安装Tacker了。</p><a id="more"></a><p>参考：<a href="https://docs.openstack.org/tacker/latest/install/manual_installation.html"><em>官方文档链接</em></a></p><p><strong>注：</strong> 本文涉及到的密码都统一设置成<em>openstack</em>。</p><h1 id="一、安装Tacker-server"><a href="#一、安装Tacker-server" class="headerlink" title="一、安装Tacker server"></a>一、安装Tacker server</h1><h2 id="1、创建数据库"><a href="#1、创建数据库" class="headerlink" title="1、创建数据库"></a>1、创建数据库</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># mysql</span><br><span class="line">MariaDB [(none)]&gt; CREATE DATABASE tacker;</span><br><span class="line">MariaDB [tacker]&gt; GRANT ALL PRIVILEGES ON tacker.* TO &#39;tacker&#39;@&#39;localhost&#39; IDENTIFIED BY &#39;openstack&#39;;</span><br><span class="line">MariaDB [tacker]&gt; GRANT ALL PRIVILEGES ON tacker.* TO &#39;tacker&#39;@&#39;%&#39; IDENTIFIED BY &#39;openstack&#39;;</span><br><span class="line">MariaDB [tacker]&gt; exit;</span><br></pre></td></tr></table></figure><h2 id="2、创建user、role、endpoints"><a href="#2、创建user、role、endpoints" class="headerlink" title="2、创建user、role、endpoints"></a>2、创建user、role、endpoints</h2><h3 id="1-获得admin凭证"><a href="#1-获得admin凭证" class="headerlink" title="1)获得admin凭证"></a>1)获得admin凭证</h3><pre><code># . admin-openrc</code></pre><h3 id="2-创建tacker用户，密码为openstack"><a href="#2-创建tacker用户，密码为openstack" class="headerlink" title="2)创建tacker用户，密码为openstack"></a>2)创建tacker用户，密码为openstack</h3><pre><code># openstack user create --domain default --password openstack tacker</code></pre><h3 id="3-给tacker用户赋予admin权限"><a href="#3-给tacker用户赋予admin权限" class="headerlink" title="3)给tacker用户赋予admin权限"></a>3)给tacker用户赋予admin权限</h3><pre><code># openstack role add --project service --user tacker admin</code></pre><h3 id="4-创建tacker服务"><a href="#4-创建tacker服务" class="headerlink" title="4)创建tacker服务"></a>4)创建tacker服务</h3><pre><code># openstack service create --name tacker \    --description &quot;Tacker Project&quot; nfv-orchestration</code></pre><h3 id="5-创建endpoints"><a href="#5-创建endpoints" class="headerlink" title="5)创建endpoints"></a>5)创建endpoints</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># openstack endpoint create --region RegionOne nfv-orchestration \</span><br><span class="line">           public http:&#x2F;&#x2F;controller:9890&#x2F;</span><br><span class="line"># openstack endpoint create --region RegionOne nfv-orchestration \</span><br><span class="line">           internal http:&#x2F;&#x2F;controller:9890&#x2F;</span><br><span class="line"># openstack endpoint create --region RegionOne nfv-orchestration \</span><br><span class="line">           admin http:&#x2F;&#x2F;controller:9890&#x2F;</span><br></pre></td></tr></table></figure><h2 id="3、下载Tacker源码"><a href="#3、下载Tacker源码" class="headerlink" title="3、下载Tacker源码"></a>3、下载Tacker源码</h2><pre><code># git clone https://github.com/openstack/tacker -b stable/ocata</code></pre><h2 id="4、安装Tacker环境依赖包"><a href="#4、安装Tacker环境依赖包" class="headerlink" title="4、安装Tacker环境依赖包"></a>4、安装Tacker环境依赖包</h2><pre><code># cd tacker# pip install -r requirements.txt</code></pre><h2 id="5、安装Tacker"><a href="#5、安装Tacker" class="headerlink" title="5、安装Tacker"></a>5、安装Tacker</h2><pre><code># python setup.py install</code></pre><h2 id="6、创建Tacker日志文件夹"><a href="#6、创建Tacker日志文件夹" class="headerlink" title="6、创建Tacker日志文件夹"></a>6、创建Tacker日志文件夹</h2><pre><code># mkdir -p /var/log/tacker</code></pre><h2 id="7、生成配置文件"><a href="#7、生成配置文件" class="headerlink" title="7、生成配置文件"></a>7、生成配置文件</h2><pre><code># ./tools/generate_config_file_sample.sh这时生成的配置文件在etc/tacker/tacker.conf.sample，需要将其重命名为tacker.conf# mv etc/tacker/tacker.conf.sample  etc/tacker/tacker.conf</code></pre><h2 id="8、修改配置文件"><a href="#8、修改配置文件" class="headerlink" title="8、修改配置文件"></a>8、修改配置文件</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"># vi etc&#x2F;tacker&#x2F;tacker.conf</span><br><span class="line"></span><br><span class="line">[DEFAULT]</span><br><span class="line">auth_strategy &#x3D; keystone</span><br><span class="line">policy_file &#x3D; &#x2F;usr&#x2F;local&#x2F;etc&#x2F;tacker&#x2F;policy.json</span><br><span class="line">debug &#x3D; True</span><br><span class="line">use_syslog &#x3D; False</span><br><span class="line">bind_host &#x3D; 10.0.0.11</span><br><span class="line">bind_port &#x3D; 9890</span><br><span class="line">service_plugins &#x3D; nfvo,vnfm</span><br><span class="line"></span><br><span class="line">state_path &#x3D; &#x2F;var&#x2F;lib&#x2F;tacker</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[nfvo]</span><br><span class="line">vim_drivers &#x3D; openstack</span><br><span class="line"></span><br><span class="line">[keystone_authtoken]</span><br><span class="line">memcached_servers &#x3D; 11211</span><br><span class="line">region_name &#x3D; RegionOne</span><br><span class="line">auth_type &#x3D; password</span><br><span class="line">project_domain_name &#x3D; Default</span><br><span class="line">user_domain_name &#x3D; Default</span><br><span class="line">username &#x3D; tacker</span><br><span class="line">project_name &#x3D; service</span><br><span class="line">password &#x3D; openstack</span><br><span class="line">auth_url &#x3D; http:&#x2F;&#x2F;controller:35357</span><br><span class="line">auth_uri &#x3D; http:&#x2F;&#x2F;controller:5000</span><br><span class="line">...</span><br><span class="line"></span><br><span class="line">[agent]</span><br><span class="line">root_helper &#x3D; sudo &#x2F;usr&#x2F;local&#x2F;bin&#x2F;tacker-rootwrap &#x2F;usr&#x2F;local&#x2F;etc&#x2F;tacker&#x2F;rootwrap.conf</span><br><span class="line"></span><br><span class="line">[database]</span><br><span class="line">connection &#x3D; mysql:&#x2F;&#x2F;tacker:openstack@controller:3306&#x2F;tacker?charset&#x3D;utf8</span><br><span class="line"></span><br><span class="line">[tacker]</span><br><span class="line">monitor_driver &#x3D; ping,http_ping</span><br></pre></td></tr></table></figure><h2 id="9、复制配置文件到配置文件夹"><a href="#9、复制配置文件到配置文件夹" class="headerlink" title="9、复制配置文件到配置文件夹"></a>9、复制配置文件到配置文件夹</h2><pre><code># cp etc/tacker/tacker.conf  /usr/local/etc/tacker/</code></pre><h2 id="10、初始化数据库信息"><a href="#10、初始化数据库信息" class="headerlink" title="10、初始化数据库信息"></a>10、初始化数据库信息</h2><pre><code># /usr/local/bin/tacker-db-manage --config-file /usr/local/etc/tacker/tacker.conf upgrade head</code></pre><h1 id="二、安装Tacker-client"><a href="#二、安装Tacker-client" class="headerlink" title="二、安装Tacker client"></a>二、安装Tacker client</h1><h2 id="1、下载Tacker-client源码"><a href="#1、下载Tacker-client源码" class="headerlink" title="1、下载Tacker-client源码"></a>1、下载Tacker-client源码</h2><pre><code># git clone https://github.com/openstack/python-tackerclient -b stable/ocata</code></pre><h2 id="2、安装Tacker-client模块"><a href="#2、安装Tacker-client模块" class="headerlink" title="2、安装Tacker-client模块"></a>2、安装Tacker-client模块</h2><pre><code># cd python-tackerclient# python setup.py install</code></pre><h1 id="三、安装Tacker-horizon"><a href="#三、安装Tacker-horizon" class="headerlink" title="三、安装Tacker horizon"></a>三、安装Tacker horizon</h1><h2 id="1、下载Tacker-horizon源码"><a href="#1、下载Tacker-horizon源码" class="headerlink" title="1、下载Tacker-horizon源码"></a>1、下载Tacker-horizon源码</h2><pre><code># git clone https://github.com/openstack/tacker-horizon -b stable/ocata</code></pre><h2 id="2、安装Tacker-horizon模块"><a href="#2、安装Tacker-horizon模块" class="headerlink" title="2、安装Tacker-horizon模块"></a>2、安装Tacker-horizon模块</h2><pre><code># cd tacker-horizon# python setup.py install</code></pre><p>安装好tacker-horizon后，admin用户登录dashboard界面就可以看到Tacker相关的VNFM和NFVO，如图：<br><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/tacker%20horizon.png" alt="tacker-horizon"></p><h1 id="四、开启Tacker-server"><a href="#四、开启Tacker-server" class="headerlink" title="四、开启Tacker server"></a>四、开启Tacker server</h1><p>打开一个新的终端，开启Tacker-server，因为Tacker-server的程序会独占这个终端。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">sudo python &#x2F;usr&#x2F;local&#x2F;bin&#x2F;tacker-server \</span><br><span class="line">    --config-file &#x2F;usr&#x2F;local&#x2F;etc&#x2F;tacker&#x2F;tacker.conf \</span><br><span class="line">    --log-file &#x2F;var&#x2F;log&#x2F;tacker&#x2F;tacker.log</span><br></pre></td></tr></table></figure><hr><p><strong>需注意的一个问题：</strong></p><p>在安装完Tacker而没有装Mistral时创建VIM的结果如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">root@controller:&#x2F;home&#x2F;openstack# tacker vim-register --is-default --config-file config.yaml test_vim</span><br><span class="line">The resource could not be found.</span><br><span class="line"></span><br><span class="line">或者是这种错误：Expecting to find domain in project. The server could not comply with the request since it is either malformed or otherwise incorrect. The client is assumed to be in error.</span><br></pre></td></tr></table></figure><p>经过查阅资料，知道这个问题是因为Tacker在创建VIM时要调用Mistral而造成的。所以在使用tacker之前需要先安装好Mistral（可以在安装tacker前安装Mistral，也可以在tacker安装之后安装Mistral，后续还需继续了解）。</p><hr>]]></content>
      
      
      <categories>
          
          <category> Openstack </category>
          
      </categories>
      
      
        <tags>
            
            <tag> Openstack </tag>
            
            <tag> Tacker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>KVM虚拟机部署openstack的网络配置</title>
      <link href="2017/12/03/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2openstack%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/"/>
      <url>2017/12/03/KVM%E8%99%9A%E6%8B%9F%E6%9C%BA%E9%83%A8%E7%BD%B2openstack%E7%9A%84%E7%BD%91%E7%BB%9C%E9%85%8D%E7%BD%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><p>这篇文章记录的是按照官方文档在<strong>KVM环境</strong>下部署<strong>双节点openstack</strong>过程中，前期准备KVM环境和网络配置相关的内容，在完成这篇博客涉及到的工作之后就可以按照官方文档手动安装openstack了。本文涉及的主要工作，首先是在服务器的<strong>ubuntu 16.04 desktop版</strong>系统上搭建kvm环境，然后在服务器上安装VNC远程桌面，最后在KVM环境中开启两台虚拟机，分别两张网卡，第一张网卡使用<strong>桥接模式</strong>，第二张网卡使用<strong>NAT模式</strong>。下面开始介绍一下这个过程。</p><a id="more"></a><h1 id="服务器搭建KVM环境"><a href="#服务器搭建KVM环境" class="headerlink" title="服务器搭建KVM环境"></a>服务器搭建KVM环境</h1><h2 id="查看CPU是否支持KVM"><a href="#查看CPU是否支持KVM" class="headerlink" title="查看CPU是否支持KVM"></a>查看CPU是否支持KVM</h2><p><code>$ egrep -c &quot;(svm|vmx)&quot; /proc/cpuinfo</code></p><p>输出结果大于0证明CPU支持KVM虚拟化 </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/infocpu.png" alt="虚拟CPU个数"></p><h2 id="安装KVM及相关依赖包"><a href="#安装KVM及相关依赖包" class="headerlink" title="安装KVM及相关依赖包"></a>安装KVM及相关依赖包</h2><p><code>$ sudo apt-get install qemu-kvm qemu virt-manager virt-viewer libvirt-bin bridge-utils</code></p><h2 id="启用桥接网络"><a href="#启用桥接网络" class="headerlink" title="启用桥接网络"></a>启用桥接网络</h2><p>在服务器上启用桥接网络需要配置一个桥接设备br0，配置br0有两种方式，通过手动配置和通过修改文件配置。 </p><h3 id="通过手动配置"><a href="#通过手动配置" class="headerlink" title="通过手动配置"></a>通过手动配置</h3><ul><li><p>创建br0网桥</p><p> <code># brctl addbr br0</code></p></li><li><p>将eth0网卡添加到br0上，此时可能会断网</p><p><code># brctl addif br0 eth0</code></p></li><li><p>删除eth0上的IP地址</p><p><code># ip addr del dev eth0 192.168.1.25/24 </code></p></li><li><p>配置br0的IP地址并启动br0网桥设备</p><p><code># ifconfig br0 192.168.1.25/24 up</code></p></li><li><p>重新加入默认网关</p><p><code># route add default gw 192.168.1.1</code></p></li><li><p>查看配置是否生效 </p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># route     &#x2F;&#x2F;查看默认网关，输出结果如下</span><br><span class="line">Kernel IP routing table</span><br><span class="line">Destination             Gateway             Genmask         Flags     Metric      Ref    Use     Iface</span><br><span class="line">default              192.168.1.1             0.0.0.0          UG        0          0      0        br0</span><br><span class="line">192.168.1.0             *                 255.255.255.0       U         0          0      0        br0</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"># ifconfig     &#x2F;&#x2F;查看eth0和br0的IP信息，输出结果如下，可以发现现在br0有IP而eth0没有IP了</span><br><span class="line">br0       Link encap:Ethernet  HWaddr 00:e0:81:e2:3c:3d  </span><br><span class="line">          inet addr:192.168.1.25  Bcast:192.168.1.255  Mask:255.255.255.0</span><br><span class="line">          inet6 addr: fe80::2e0:81ff:fee2:3c3d&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:1316822 errors:0 dropped:5787 overruns:0 frame:0</span><br><span class="line">          TX packets:365475 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:581279124 (581.2 MB)  TX bytes:562586852 (562.5 MB)</span><br><span class="line"> </span><br><span class="line">eth0      Link encap:Ethernet  HWaddr 00:e0:81:e2:3c:3d  </span><br><span class="line">          inet6 addr: fe80::2e0:81ff:fee2:3c3d&#x2F;64 Scope:Link</span><br><span class="line">          UP BROADCAST RUNNING MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:6671034 errors:0 dropped:9627 overruns:0 frame:0</span><br><span class="line">          TX packets:840972 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:1346523816 (1.3 GB)  TX bytes:614510541 (614.5 MB)</span><br><span class="line">          Memory:dfb80000-dfbfffff</span><br><span class="line"> </span><br><span class="line">lo        Link encap:Local Loopback  </span><br><span class="line">          inet addr:127.0.0.1  Mask:255.0.0.0</span><br><span class="line">          inet6 addr: ::1&#x2F;128 Scope:Host</span><br><span class="line">          UP LOOPBACK RUNNING  MTU:65536  Metric:1</span><br><span class="line">          RX packets:1450290 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:1450290 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:24027042487 (24.0 GB)  TX bytes:24027042487 (24.0 GB)</span><br></pre></td></tr></table></figure><p>这就是通过手动来配置桥接设备br0的方法，这种方法在配置好之后马上就生效了，但是在系统重启之后这些配置信息都会被清除，要想使配置永久生效则需要修改网络配置文件，也就是下面的方法。 </p></li></ul><h3 id="通过修改文件配置"><a href="#通过修改文件配置" class="headerlink" title="通过修改文件配置"></a>通过修改文件配置</h3><ul><li><p>修改前先将网络配置文件进行备份</p><p><code># cp  /etc/network/interfaces  /etc/network/interfaces.bak</code></p></li><li><p>修改网络配置文件<code>/etc/network/interfaces</code></p><p><code># vi  /etc/network/interfaces    //修改结果如下</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">auto lo</span><br><span class="line">iface lo inet loopback</span><br><span class="line"> </span><br><span class="line"># Enabing Bridge networking br0 interface</span><br><span class="line">auto br0</span><br><span class="line">iface br0 inet static</span><br><span class="line">address 192.168.1.25</span><br><span class="line">network 192.168.1.0</span><br><span class="line">netmask 255.255.255.0</span><br><span class="line">broadcast 192.168.1.255</span><br><span class="line">gateway 192.168.1.1</span><br><span class="line">dns-nameservers 223.5.5.5</span><br><span class="line">bridge_ports eth0</span><br><span class="line">bridge_stp off</span><br></pre></td></tr></table></figure><p>保存后退出，关机重启中配置文件就生效了。这种方法只需要修改配置文件然后重启就可以，比较简单，而且是永久生效，比较符合我们的需求，因为我们的虚拟机通过桥接模式连接外网的话都是连接到br0上的。 </p></li></ul><h2 id="修改virbr0的网段"><a href="#修改virbr0的网段" class="headerlink" title="修改virbr0的网段"></a>修改virbr0的网段</h2><p>在服务器上安装好虚拟化软件后，KVM会自动生成一个<code>virbr0</code>的桥接设备，它的作用是为连接其上的虚拟网卡提供NAT访问外网的功能，并提供DHCP服务。<code>virbr0</code>默认分配的IP是<code>192.168.122.1</code>，使用 <code>ifconfig</code> 命令查看得<code>virbr0</code>的信息如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$  ifconfig</span><br><span class="line">……</span><br><span class="line"> </span><br><span class="line">virbr0    Link encap:Ethernet  HWaddr 52:54:00:f8:70:e3  </span><br><span class="line">          inet addr:192.168.122.1  Bcast:192.168.122.255  Mask:255.255.255.0</span><br><span class="line">          UP BROADCAST MULTICAST  MTU:1500  Metric:1</span><br><span class="line">          RX packets:0 errors:0 dropped:0 overruns:0 frame:0</span><br><span class="line">          TX packets:0 errors:0 dropped:0 overruns:0 carrier:0</span><br><span class="line">          collisions:0 txqueuelen:1000</span><br><span class="line">          RX bytes:0 (0.0 B)  TX bytes:0 (0.0 B)</span><br></pre></td></tr></table></figure><p> 在这种情况下，连接到virbr0上的虚拟机的虚拟网卡也是在192.168.122.0网段上的，如果让连接到virbr0上的虚拟网卡在自定义的网段上就需要修改virbr0的网段，修改方法如下： </p><p><code># virsh  net-edit  default</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">&lt;network&gt;</span><br><span class="line">  &lt;name&gt;default&lt;&#x2F;name&gt;</span><br><span class="line">  &lt;uuid&gt;91cc230a-bf53-487c-b296-10323705d7e8&lt;&#x2F;uuid&gt;</span><br><span class="line">  &lt;forward mode&#x3D;&#39;nat&#39;&#x2F;&gt;</span><br><span class="line">  &lt;bridge name&#x3D;&#39;virbr0&#39; stp&#x3D;&#39;on&#39; delay&#x3D;&#39;0&#39;&#x2F;&gt;</span><br><span class="line">  &lt;mac address&#x3D;&#39;52:54:00:f8:70:e3&#39;&#x2F;&gt;</span><br><span class="line">  &lt;ip address&#x3D;&#39;10.0.0.1&#39; netmask&#x3D;&#39;255.255.255.0&#39;&gt;</span><br><span class="line">    &lt;dhcp&gt;</span><br><span class="line">      &lt;range start&#x3D;&#39;10.0.0.2&#39; end&#x3D;&#39;10.0.0.254&#39;&#x2F;&gt;</span><br><span class="line">    &lt;&#x2F;dhcp&gt;</span><br><span class="line">  &lt;&#x2F;ip&gt;</span><br><span class="line">&lt;&#x2F;network&gt;</span><br></pre></td></tr></table></figure><p>这样就将<code>virbr0</code>的网段改成<code>10.0.0.0/24</code>，连接到<code>virbr0</code>的虚拟网卡的IP将会在<code>10.0.0.2/24 - 10.0.0.254/24</code>范围内自动分配一个。如果有需要可以自己手动给虚拟网卡配置IP并写到配置文件中去。 </p><h1 id="服务器安装VNC远程桌面"><a href="#服务器安装VNC远程桌面" class="headerlink" title="服务器安装VNC远程桌面"></a>服务器安装VNC远程桌面</h1><p>因为服务器上安装的<code>Ubuntu 16.04 LTS  desktop</code>版的系统，在后续的工作中需要远程登录到服务器，虽然可以通过SSH远程管理服务器，但是可视化的界面往往会给新手用户提供很大的便利，所以可以在服务器上安装VNC。开始在服务器上安装VNC试过很多方法，VNC服务器端也有多种选择，如<code>VNC4server</code>、<code>tigervncserver</code>，感觉很麻烦，而且还不一定能安装成功，我安装的VNC服务器端是<code>x11VNC</code>，按照步骤可以很顺利地完成安装，步骤如下： </p><h2 id="安装x11VNC软件包"><a href="#安装x11VNC软件包" class="headerlink" title="安装x11VNC软件包"></a>安装x11VNC软件包</h2><p><code>$ sudo  apt-get  install  x11vnc</code></p><h2 id="配置访问密码"><a href="#配置访问密码" class="headerlink" title="配置访问密码"></a>配置访问密码</h2><p><code>$ sudo  x11vnc  -storepasswd  /etc/x11vnc.pass</code></p><h2 id="创建服务"><a href="#创建服务" class="headerlink" title="创建服务"></a>创建服务</h2><p><code># vi  /lib/systemd/system/x11vnc.service      //粘贴一下代码，最后:wq 保存，请使用root用户，否则没有权限</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">[Unit]</span><br><span class="line">Description&#x3D;Start x11vnc at startup.</span><br><span class="line">After&#x3D;multi-user.target</span><br><span class="line">[Service]</span><br><span class="line">Type&#x3D;simple</span><br><span class="line">ExecStart&#x3D;&#x2F;usr&#x2F;bin&#x2F;x11vnc -auth guess -forever -loop -noxdamage -repeat -rfbauth &#x2F;etc&#x2F;x11vnc.pass -rfbport 5900 -shared</span><br><span class="line">[Install]</span><br><span class="line">WantedBy&#x3D;multi-user.target</span><br></pre></td></tr></table></figure><h2 id="配置防火墙，配置和启动服务"><a href="#配置防火墙，配置和启动服务" class="headerlink" title="配置防火墙，配置和启动服务"></a>配置防火墙，配置和启动服务</h2><p><code># ufw allow 5900</code></p><p><code># systemctl enable x11vnc.service</code></p><p><code># systemctl daemon-reload</code></p><p><code># systemctl start x11vnc.service</code></p><p>完成这四个步骤然后重启就可以了。（这个VNC的安装过程可以参考<a href="http://blog.csdn.net/longhr/article/details/51657610%EF%BC%89">http://blog.csdn.net/longhr/article/details/51657610）</a> </p><p>最后在你自己的电脑需要有一个vnc viewer的软件，可以在这里下载（链接：<a href="https://pan.baidu.com/s/1o8kPqXG">https://pan.baidu.com/s/1o8kPqXG</a> 密码：v5r2） </p><h1 id="创建VM并配置相关信息"><a href="#创建VM并配置相关信息" class="headerlink" title="创建VM并配置相关信息"></a>创建VM并配置相关信息</h1><p>在安装好VNC后就可以登录服务器的远程桌面，打开一个terminal，在terminal中输入下面的命令可以打开Virtual Machine  Manager（注意，使用SSH远程登录服务器是无法打开virt-manager的界面的，一定要在登录了远程桌面后才能打开界面）</p><p><img src="https://img-blog.csdn.net/20171201233200479" alt="VMM"></p><p>使用Virtual Machine Manager的界面可以很方便的创建虚拟机，当然也可以在命令行中使用命令创建虚拟机，这个我就不在这里说了。 </p><h2 id="按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute"><a href="#按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute" class="headerlink" title="按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute"></a>按照Openstack官网安装文档的主机网络配置两台虚拟机Controller和Compute</h2><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/openstack%20network.png" alt="openstack network"></p><p>控制节点和计算节点这两个虚拟机分别两张网卡，一张配置为桥接模式，另一张配置为NAT模式。创建虚拟机时默认是添加一张网卡的，后面可以在虚拟机的硬件信息中添加。两张虚拟网卡的配置信息如图： </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/%E6%A1%A5%E6%8E%A5%E6%A8%A1%E5%BC%8F%E7%BD%91%E5%8D%A1.png" alt="compute1"></p><p>上图显示的是桥接模式网卡的配置信息，Network source选择为<code>Bridge br0：Host device eth0</code> </p><p><img src="https://raw.githubusercontent.com/cao0507/Pictures/master/blog/NAT%E7%BD%91%E5%8D%A1.png" alt="NAT"></p><p>上图显示的是NAT模式网卡的配置信息，Network source选择为<code>Virtual network ‘default’：NAT</code> </p><p>这样按照官方文档部署双节点Openstack的前期准备工作就已经做完，后面就可以按照官方文档开始安装openstack了，祝你成功。附上官方文档链接<a href="https://docs.openstack.org/ocata/zh_CN/install-guide-ubuntu/index.html">https://docs.openstack.org/ocata/zh_CN/install-guide-ubuntu/index.html</a> （注：这个是在ubuntu系统下安装Ocata版本Openstack中文文档） </p><hr>]]></content>
      
      
      <categories>
          
          <category> KVM </category>
          
      </categories>
      
      
        <tags>
            
            <tag> KVM </tag>
            
            <tag> Openstack </tag>
            
            <tag> vnc </tag>
            
            <tag> ubuntu </tag>
            
            <tag> Virtual Machine </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
